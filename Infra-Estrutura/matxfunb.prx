#include "protheus.ch"
#include "matxfunb.ch"

Static aFormBatch:={}
Static __cFileLog
Static __aErrAuto	:= {}
Static __CtbFilVld		// Filial para validacao CTB
Static __aCache := {}
Static __aCTBConta 	:= {}
Static __aCTBCusto 	:= {}
Static __aCTBItem 	:= {}
Static __aCTBClVlr 	:= {}
Static __lFILEMOT
Static __aMotRead
Static __lEspecie
Static __lCacheIs
Static lConsPrev	:=NIL
Static __lAgltDup	:= NIL
Static __lDataRef	:= NIL
Static __lTPCondPg	:= NIL
Static __lCndTipo3  := NIL
Static __lIPI		:= NIL
Static __lDiaCont	:= NIL
Static __cCalcImpV  := NIL
Static __cMv_Agente := NIL
Static __nTamE1Valor:= NIL
Static __nTamRat	:= NIL
Static __ProcName	:= NIL
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ DATA   ³ BOPS ³Prograd.³ALTERACAO							  		  ³±±
±±ÃÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³16.12.98³XXXXXX³Andreia ³Inclusao da Funcao TEMBXCANC()				  ³±±
±±³04.01.99³XXXXXX³Pilar   ³Acerto do nome da variavel cPicture- TmContab ³±±
±±³06.01.99³19274A³Andreia ³Acerto na funcao FA070JUROS() quando juros	  ³±±
±±³		  ³	   ³		   ³composto.									  ³±±
±±³14.01.99³xxxxxx³RODRIGO ³Incluida funcao A207Um()					  ³±±
±±³22/01/99³META  ³Rodrigo ³Incluida funcao AvalQtdPre					  ³±±
±±³22.01.99³xxxxxA³Pilar   ³Travamento CNAB II							  ³±±
±±³26.01.99³META  ³Rodrigo ³Incluidas funcoes para OPs/SCs Firme/Prevista ³±±
±±³19.02.99³******³Julio   ³Transf. Funcao ConaOk() do ConxFun.prx		  ³±±
±±³19.02.99³XXXXXX³Fernando³Incl.fun‡”es QA_ULTRV, QA_VERNUM, QA_NUMDEC   ³±±
±±³  	     ³	   ³		   ³QA_GRCOD e QA_SEQU do QAXFUN.PRW		  ³±±
±±³20.02.99³XXXXXX³Fernando³Incl.fun‡„o A200SKTE do QIEA200.PRW			  ³±±
±±³20.02.99³XXXXXX³Fernando³Incl.fun‡„o READMOTBX do FINXFUN.PRX. 		  ³±±
±±³15.03.99³xxxxxx³Pilar   ³Estava pulando linha indevida no CNAB2		  ³±±
±±³18.03.99³xxxxxx³Marcelo ³Inclus„o da fun‡„o QA_CHOICE.				  ³±±
±±³22.03.99³META  ³Julio   ³Acrescentar col. Cheque na Tab. Mot.Baixa.	  ³±±
±±³08.04.99³xxxxxx³Vera    ³Exclusao das funcoes do Siga Quality		  ³±±
±±³19.04.99³PROTH.³Julio   ³Melhoria da fun‡„o fa070juros() sem usar 	  ³±±
±±³		  ³	   ³		   ³ErrorBlock(). 								  ³±±
±±³17.07.99³xxxxxx³Wag/Kota³Substituicao da Serial.dll					  ³±±
±±³21.07.99³22934A³CesarVal³Alterar fun‡ao E_FIELD - SIGAEIC p/ 2.06/4.06 ³±±
±±³28.07.99³xxxxxx³Fabio FP³Alterada fun‡ao E_FIELD						  ³±±
±±³12.08.99³xxxxxx³Joly    ³Na MSROTAUTO nao mudar o Indice do SX3 s/ness.³±±
±±³25.08.99³XXXXXX³Mauricio³Reposicionar alias de entrada na TEMBXCANC()  ³±±
±±³25.08.99³23454A³Aline CV³Acerto na funcao Condicao nos Tipo 6 e Tipo 3 ³±±
±±³17.09.99³XXXXXX³Julio W ³Acerto na chave da Funcao TemBxCanc()         ³±±
±±³09.11.99³23514A³Kotaki  ³Inclusao de um PE. para MARLOCK               ³±±
±±³23.11.99³XXXXXX³Fabio R ³VerIficar se existe o Sigaloja.???            ³±±
±±³20.12.99³XXXXXX³Julio W ³Implementa‡„o na Leitura do CNAB II -> Le uma ³±±
±±³        ³      ³        ³linha inteira (at‚ encontrar Chr(13)+Chr(10)) ³±±
±±³22.12.99³226744³Lucas   ³Considerar Remitso SCM/SCN na xCalcEst().     ³±±
±±³26.01.00³XXXXXX³Stiefano³Acerto na xProcedure - AS400                  ³±±
±±³03.02.00³XXXXXX³Mauricio³Acerto na TemBxCan() - Vicente                ³±±
±±³04.02.00³XXXXXX³Sandro  ³Acerto na MSRotAuto,MSVldGAuto,MSVldACAuto    ³±±
±±³04.02.00³XXXXXX³Sandro  ³Inclusao da funcao MSExecAuto()				  ³±±
±±³11.02.00³25504A³Julio W ³Acerto no pulo de Segmento no CNAB II         ³±±
±±³02.03.00³xxxxxx³Sandro  ³Implementaco na funcao condicao para funcionar³±±
±±³        ³      ³        ³sem o cadastro SE4                            ³±±
±±³11.05.00³xxxxxx³Bruno   ³Acertar a CalcEst para entradas e saidas de   ³±±
±±³        ³      ³        ³ localizacoes.                                ³±±
±±³13.07.00³      ³Sandro  ³Inclusao de funcao para mostrar o autoerro.log³±±
±±³        ³      ³        ³na tela                                       ³±±
±±³01.12.00³6931  ³Iuspa   ³ASC2SLD() Obedecendo decimais do X3 (C2_QUANT)³±±
±±³07.02.01³      ³F Garbin³Alteracao da funcao MostraErro, p/ utilizacao ³±±
±±³        ³      ³        ³em caso de JOBs                               ³±±
±±³02.03.01³xxxxxx³Naldo   ³Passagem de Novo Paramentro para fDesc()  para³±±
±±³        ³      ³        ³o tratamento de Filiais.                      ³±±
±±³28.08.01³xxxxxx³Naldo   ³Alterada fDesc() para quando nao for  localiza³±±
±±³        ³      ³        ³da a Chave retornar com Space de nBytes.      ³±±
±±³21.05.02³xxxxxx³Naldo   ³Alterada MsMm() para Destravar os    Registros³±±
±±³        ³      ³        ³travados com RecLock() quando Exclusao de Memo³±±
±±³27.06.02³xxxxxx³Naldo   ³Alterada fDesc() para utilizar MsSeek() ao  in³±±
±±³        ³      ³        ³ves de dbSeek() e passagem de novo   parametro³±±
±±³        ³      ³        ³p/ a Selecao de Ordem						  ³±±
±±³03.09.02³xxxxxx³Naldo   ³Retirada do Teste da Variavel Inclui em fDesc ³±±
±±³08.09.02³xxxxxx³Bruno   ³Desconsiderar Remitso SCM/SCN na xCalcEst().  ³±±
±±³23.12.02³xxxxxx³Naldo   ³Exclusao da Variavel Local lNovo em fDesc().  ³±±
±±³03.04.03³Melhor³Naldo   ³fDesc() podera retornar o conteudo de Qualquer³±±
±±³        ³      ³        ³Campo independente do Tipo.					  ³±±
±±³        ³      ³        ³fDesc() nao precisara mais restaurar a Area de³±±
±±³        ³      ³        ³entrada uma vez que a pesquisa e feita por  re³±±
±±³        ³      ³        ³ferencia de Alias ( cAlias )->( Exp. )		  ³±±
±±³17.10.03³Melhor³Naldo   ³Alterada MsMm para Utilizar Soma1() para obter³±±
±±³        ³      ³        ³a sequencia a  sergravada, utilizar FieldPos()³±±
±±³        ³      ³        ³para verificar a Existencia dos campos,  utili³±±
±±³        ³      ³        ³lizacao de Begin/End Sequence para  padronizar³±±
±±³        ³      ³        ³o retorno, e otimizacao do processo de  verifi³±±
±±³        ³      ³        ³cacao da filial evitando chamada desnecessaria³±±
±±³        ³      ³        ³a xFilial() ( A macro cFilial foi  substituida³±±
±±³        ³      ³        ³por uma variavel que chama a xFilial() uma uni³±±
±±³        ³      ³        ³ca vez), gravar a chave do Memo somente apos a³±±
±±³        ³      ³        ³gravacao de todas as Linhas					  ³±±
±±³17.10.03³Acerto³Naldo   ³Alterada MsMm para Utilizar Soma1() para  veri³±±
±±³        ³      ³        ³ficar corretamente a Linha conforme nLin	  ³±±
±±³20.03.04³Melhor³Naldo   ³Verificar xFilial() em fDesc() apenas para  ar³±±
±±³        ³      ³        ³quivos que possuam _FILIAL                 	  ³±±
±±³26.03.04³Acerto³Naldo   ³Garantir o posicionamento no SX3 na fDesc     ³±±
±±³04.05.07³122616³Norbert ³Incluido tratamento de desconto no calculo de ³±±
±±³        ³      ³        ³juros do titulo na rotina FA070Juros().       ³±±
±±³15.10.12³TFTRE0³Luis    ³Ajuste para verificar se sera gerada (ou nao) ³±±
±±³        ³024091³Artuso  ³linha em branco no arquivo magnetico (CNAB2)  ³±±
±±³        ³  2012³        ³de liquidos.                                  ³±±
±±³05.10.16³TVUBQE³Cícero  ³Ajuste na função MSMM para chamar a função do ³±±
±±³        ³      ³Alves   ³RH RHMSMM para gravar os campos memo na tabela³±±
±±³        ³      ³        ³RDY e não na SYP							  ³±±
±±ÀÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Array 	 ³  aProcedure ³ Autor ³ Vicente Sementilli ³ Data ³ 27.07.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ O array aProcedure foi criado para armazenar os nomes de   ³±±
±±³			 ³ procedures para evitar a checagem constante de sua existen-³±±
±±³			 ³ cia no Banco de Dados                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static aProcedures := {}

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³A330GRAVASB6³ Autor ³ Marcos Bregantim    ³ Data ³ 07/07/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Custo do Poder de Terceiros                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A330GRAVASB6(xPar1,xPar2)                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA330                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A330GRAVASB6(cAlias,aCusto,aCustoFF,lCusFIfO,lCstPart,aRegraCP,aRetPartes,lCusRep,aCMRep)
Local lEof
Local cMoedaCM := SuperGetMv('MV_MOEDACM',.F.,"2345")

lCusFIfO := IIf(lCusFIfO==Nil,.F.,lCusFIfO)

DEFAULT lCstPart := .F.
DEFAULT lCusRep  := .F.
DEFAULT aCMRep   := {0,0,0,0,0}

If cAlias == "SD1"
	DbSelectArea("SB6")
	DbSetOrder(3)
	DbSeek ( xFilial() + SD1->D1_IDENTB6 + SD1->D1_COD + "R")
	lEof := .t.
	While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD1->D1_IDENTB6 + SD1->D1_COD
		If SB6->B6_TIPO == "D"
			lEof := .f.
			Exit
		EndIf
		DbSkip()
	End
	If !lEof
		Reclock("SB6",.F.)
		SB6->B6_QUANT		:= SD1->D1_QUANT
		If lCusFIfO
			SB6->B6_CUSFF1 := aCusto[1]
			SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
		Else
			SB6->B6_CUSTO1 := aCusto[1]
			SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
			If lCusRep
				SB6->B6_CUSRP1 := aCMRep[1]
				SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
				SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
				SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
				SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
			EndIf
		EndIf
		MsUnlock()
	Else
		Reclock("SB6",.T.)
		SB6->B6_QUANT	:= SD1->D1_QUANT
		SB6->B6_FILIAL := xFIlial("SB6")
		SB6->B6_PRODUTO:= SD1->D1_COD
		SB6->B6_CLIfOR := SD1->D1_FORNECE
		SB6->B6_LOJA	:= SD1->D1_LOJA
		SB6->B6_IDENT := SD1->D1_IDENTB6
		SB6->B6_TPCF := Iif(SD1->D1_TIPO $"DB","C","F")
		SB6->B6_TIPO := "D"
		If lCusFIfO
			SB6->B6_CUSFF1 := aCusto[1]
			SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCusto[5],0)
		Else
			SB6->B6_CUSTO1 := aCusto[1]
			SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
			If lCusRep
				SB6->B6_CUSRP1 := aCMRep[1]
				SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
				SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
				SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
				SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
    		EndIf
		EndIf
		MsUnlock()
	EndIf
Else
	DbSelectArea("SB6")
	DbSetOrder(3)
	DbSeek ( xFilial() + SD2->D2_IDENTB6 + SD2->D2_COD + "R" )
	lEof := .t.
	While !Eof() .and. B6_FILIAL == xFilial("SB6") .and. B6_IDENT+B6_PRODUTO == SD2->D2_IDENTB6 + SD2->D2_COD
		If SB6->B6_TIPO == "E"
			lEof := .f.
			Exit
		EndIf
		DbSkip()
	End
	If !lEof
		Reclock("SB6",.F.)
		SB6->B6_QUANT		:= SD2->D2_QUANT
		If lCusFIfO
			SB6->B6_CUSFF1 := aCustoFF[1]
			SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
			SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
			SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
			SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
		Else
			SB6->B6_CUSTO1 := aCusto[1]
			SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
			If lCusRep
				SB6->B6_CUSRP1 := aCMRep[1]
				SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
				SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
				SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
				SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
			EndIf
		EndIf
		MsUnlock()
	Else
		Reclock("SB6",.t.)
		SB6->B6_QUANT		:= SD2->D2_QUANT
		SB6->B6_FILIAL := xFIlial("SB6")
		SB6->B6_PRODUTO := SD2->D2_COD
		SB6->B6_CLIfOR := SD2->D2_CLIENTE
		SB6->B6_LOJA := SD2->D2_LOJA
		SB6->B6_IDENT := SD2->D2_IDENTB6
		SB6->B6_TPCF := Iif(SD2->D2_TIPO $"DB","F","C")
		SB6->B6_TIPO := "E"
		If lCusFIfO
			SB6->B6_CUSFF1 := aCustoFF[1]
			SB6->B6_CUSFF2 := If("2" $ cMoedaCM,aCustoFF[2],0)
			SB6->B6_CUSFF3 := If("3" $ cMoedaCM,aCustoFF[3],0)
			SB6->B6_CUSFF4 := If("4" $ cMoedaCM,aCustoFF[4],0)
			SB6->B6_CUSFF5 := If("5" $ cMoedaCM,aCustoFF[5],0)
		Else
			SB6->B6_CUSTO1 := aCusto[1]
			SB6->B6_CUSTO2 := If("2" $ cMoedaCM,aCusto[2],0)
			SB6->B6_CUSTO3 := If("3" $ cMoedaCM,aCusto[3],0)
			SB6->B6_CUSTO4 := If("4" $ cMoedaCM,aCusto[4],0)
			SB6->B6_CUSTO5 := If("5" $ cMoedaCM,aCusto[5],0)
			If lCusRep
				SB6->B6_CUSRP1 := aCMRep[1]
				SB6->B6_CUSRP2 := If("2" $ cMoedaCM,aCMRep[2],0)
				SB6->B6_CUSRP3 := If("3" $ cMoedaCM,aCMRep[3],0)
				SB6->B6_CUSRP4 := If("4" $ cMoedaCM,aCMRep[4],0)
				SB6->B6_CUSRP5 := If("5" $ cMoedaCM,aCMRep[5],0)
			EndIf
		EndIf
		MsUnlock()
	EndIf
EndIf
GravaCusCP(lCstPart,aRegraCP,aCusto,"SB6",SB6->B6_PRODUTO,aRetPartes,NIL,NIL,ACLONE(aCusto))
Return (aCusto)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³CheckCols   ³ Autor ³ Juan Jose Pereira   ³ Data ³ 27/03/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ VerIfica se linha do aCols foi preenchido 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lRet:=CheckCols(n,aCols) 											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³LinOk																		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CheckCols(n,aCols)

Local lRet:=.T.,lVazio:=.T.

If n==Len(aCols)
	Aeval(aCols[n],{|x|If(lVazio,lVazio:=Empty(x),lVazio)})
	If lVazio
		lRet:=.F.
		Help(" ",1,"CHECKCOLS")
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ EvalMacro	 ³Autor ³ Juan Jose Pereira	 ³Data³ 08/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Executa Macro															  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION EvalMacro(cMacro)
Return(If(Empty(cMacro),NIL,&(cMacro)))

Function MSFILTER(cFiltro)
Local cExpress, nAt, cNewFilter := ""

Set Filter To &(cFiltro)
DbGoTop()
Return



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ NumImp	³ Autor ³ Alessandro B. Freire  ³ Data ³ 19.05.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o numero correto de impressao							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Cabec(titulo,cabec1,cabec2,tamanho,NumImp()) 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 																			  ³±±
±±³			 ³ 																			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NumImp()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Esta funcao somente deve ser usada como parametro de impressao da funcao	 ³
//³ cabec.																							 ³
//³ Retornos:																						 ³
//³ 15 - Comprimido ( Cabec nao imprime o caractere 15, a funcao utiliza este  ³
//³		numero apenas como referencia ao tipo de impressao )						 ³
//³																									 ³
//³ 18 - Normal ( O mesmo acima )															 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nTipo := Iif( aReturn[4] == 1, 15, 18 )
Return( nTipo )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³AcessaPerg³ Autor ³ Mauricio Pequim Jr	  ³ Data ³ 19/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Acessa a fun‡„o pergunte a partir de uma chave				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AcessaPerg(cPergunta,lModo)
lModo := Iif(lModo=Nil,.T.,lModo)
pergunte(cPergunta,lModo)
Return (.T.)
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³  MSMM 	³ Autor ³ Gilson Nascimento	  	³ Data ³ 09/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Pesquisa especial para campo MEMO da integracao SIGAEIC/Adv³±±
±±³			 ³ (AVERAGE/MICROSIGA)										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ MSMM(ExprC1,ExprN1,ExprN2,ExprC2,ExprN3)					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ Retorna String pesquisada								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ SIGAEIC													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function MSMM( cChave , nTam , nLin , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias, lSoInclui )
Local nPos, nTexto
Local cFilSYP
Local uRet      := " "
Local lUsaSx8   := (cChave == NIL .Or. Empty(cChave))
Local cLine     := ""
Local lField    := .F.
Local nLen1
Local nLen2
Local cSeq
Local lGrv := .F.
Local nPos2
Local nTamSeq
Local cPrefixo
Local nLenSYP

Local nYP_TEXTO
Local nYP_CHAVE
Local nYP_FILIAL
Local nYP_SEQ
Local lRH	:= .F.
local aAreaAtu := GetArea()


dbSelectArea("SX2")
lRH := If(!Empty(Alias()), SX2->(dbSeek(Alias())) .And. strzero(SX2->X2_MODULO,2) $ "07|16|53|70|20|26|40|18", .F.) 
RestArea(aAreaAtu)

If lRh .Or. cModulo $ "GPE|PON|APD|ORG|RSP|TRM|CSA|TCF"  .Or. (Valtype(cRealAlias) <> "U" .And. cRealAlias == "RDY")
	Return RHMSMM( cChave, nTam, nLin, cString, nOpc, nTabSize, lWrap, cAlias, cCpochave, cRealAlias, lSoInclui )
EndIf

DEFAULT cChave := StrZero(0,6)
DEFAULT	nLin := 0
DEFAULT cString := ""
DEFAULT nOpc := 3
DEFAULT cRealAlias := "SYP"
DEFAULT lSoInclui := .F.

cPrefixo := PrefixoCpo(cRealAlias)
cFilSYP := xFilial(cRealAlias)
nTamSeq := TamSx3(cPrefixo+"_SEQ")[1]
//Ponto de entrada exclusivo para uso interno do SSIM
//NAO DIVULGAR PARA CLIENTE


Begin Sequence
	If nOpc == 3 // Ler Memo
		If nLin > 0 // Linha especficia
			uRet := MSMM( cChave , nTam , 0 , cString , nOpc , nTabSize , lWrap , cAlias , cCpochave , cRealAlias )
			
			// Atribui valores defaults
			nTabSize := IF(ValType(nTabSize)=="N",nTabSize,nil)
			lWrap := IF(ValType(lWrap)=="L",lWrap,nil)
			
			uRet := MemoLine(uRet,nTam,nLin,nTabSize,lWrap)
			
			RestArea(aAreaAtu)
			Return uRet
		Endif
    Else
		//Se não Possuir Chave e String Vazia Abandona
		IF ( Empty( cChave ) .and. Empty( cString ) )
			Break
		EndIF
		//verifica se o campo existe na tabela
		If ( cCpoChave <> NIL )
			cCpoChave := Trim(cCpoChave)
			IF !( lField := ( ( cAlias )->( FieldPos( cCpoChave  ) ) > 0.00 ) )
				Break
			EndIF
		EndIf
	EndIf

	DbSelectArea(cRealAlias)
	DbSetOrder(1)
	DbSeek(cFilSYP + cChave, .T.)

	nYP_TEXTO := FieldPos(cPrefixo+"_TEXTO")
	nYP_CHAVE := FieldPos(cPrefixo+"_CHAVE")
	nYP_FILIAL := FieldPos(cPrefixo+"_FILIAL")
	nYP_SEQ := FieldPos(cPrefixo+"_SEQ")
	nLenSYP := Len(FieldGet(nYP_TEXTO))

	DEFAULT nTam    := nLenSYP

	// Ler campo MEMO
	If nOpc == 3
		//cSeqAux := Replicate( "9" , nTamSeq )
		While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
			/* contornado com a utilização da função MemoLine()
			If nLin > 0
				nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
				If ( nPos == 0 )
					cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
					If ( nPos2 := At("\14\10", cLine) ) > 0
						cString += StrTran( cLine, "\14\10", Space(6) )
					Else
						cString += cLine
					EndIf
				Else
					cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1)
				EndIf
				Exit
			EndIf
			*/

			nPos := At("\13\10",Subs(FieldGet(nYP_TEXTO),1,nTam+6))
			If ( nPos == 0 )
				cLine := RTrim(Subs(FieldGet(nYP_TEXTO),1,nTam))
				If ( nPos2 := At("\14\10", cLine) ) > 0
					cString += StrTran( cLine, "\14\10", Space(6) )
				Else
					cString += cLine
				EndIf
			Else
				cString += Subs(FieldGet(nYP_TEXTO),1,nPos-1) + CRLF
			EndIf
			DbSkip()
		End While
		uRet := cString

	ElseIf nOpc == 2

		// Excluir campo MEMO
		uRet := .F.
		While !Eof() .And. ( cChave == FieldGet(nYP_CHAVE) ) .And. ( cFilSYP == FieldGet(nYP_FILIAL) )
			RecLock(cRealAlias,.F.,.T.)
			DbDelete()
			MsUnLock()
			uRet := .T.
			DbSkip()
		End While

	Else

		// Incluir/Alterar campo MEMO
		If ( lUsaSx8 ) .and. ( nOpc == 1 )
			cChave := GetSX8Num(cRealAlias,cPrefixo+"_CHAVE")
		EndIf

	    if !lSoInclui  //default
   		   cSeq 	:= Space( nTamSeq )
   		else
   		   dbseek(cFilSYP+cChave+'ZZZ',.T.)
   		   dbSkip(-1) //Posiciono na última sequência
   		   if ( cChave == FieldGet(nYP_CHAVE) .And.  cFilSYP == FieldGet(nYP_FILIAL) )
   		       cSeq:=FieldGet(nYP_SEQ)
   		   else
	   		   cSeq 	:= Space( nTamSeq )
   		   endif
   		endif

		cString	:= Trim(cString)
		If nTam >= nLenSYP .or. nTam > (nLenSYP - 6)
			nTam := nLenSYP - 6
		EndIf

		While !Empty(cString)

	        nTexto := At(CRLF,cString)
	        If nTexto == nTam
				cLine := Subs(cString,1,nTam+1)
	        Else
				cLine := Subs(cString,1,nTam)
			EndIf
	        nTexto := At(CRLF,cLine)

			If nTexto > 0

				cLine := Subs(cLine,1,nTexto-1)+"\13\10"
				nTexto += 2

			Else

				If !Empty(cLine)

					nTexto := nTam+1
				    nLen1 := Len(cLine)
					nLen2 := Len(Trim(cLine))

					//verifica se tem espaco no final da linha para colocar no inicio do proximo registro
					If nLen1 <> nLen2
						cLine := Trim(cLine)
						nTexto -= (nLen1 - nLen2)
					EndIf

				Else

				    cLine := Subs( cLine, 1, nTam-6 ) + '\14\10'
				    nTexto += nTam + 1

				EndIf

			EndIf

			cString := Subs(cString,nTexto)

			cSeq := Soma1( cSeq , nTamSeq )

			lGrv := .T.
			GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )

		End While

		cSeq := IF( Empty( cSeq ) , Soma1( Space( nTamSeq ) , nTamSeq ) , cSeq )

	    IF ( lGrv )
	    	DbSelectArea(cAlias)
			RecLock( cAlias , .F. )
			Eval( FieldWBlock( cCpochave,Select(cAlias) ),cChave)
			MsUnLock()
			FkCommit()
			DbSelectArea(cRealAlias)
		    DbSeek( cFilSYP + cChave + Soma1( cSeq , nTamSeq ) , .T. )
		Else
		    DbSeek( cFilSYP + cChave , .T. )
		Endif

		While !Eof() .and. ( FieldGet(nYP_FILIAL) == cFilSYP ) .and. ( FieldGet(nYP_CHAVE) == cChave )
			RecLock( cRealAlias , .F. )
			DbDelete()
			MsUnlock()
			DbSkip()
	    End While

	    uRet := cChave
		IF ( ( lUsaSx8 ) .and. ( nOpc == 1 ) )
			ConfirmSX8()
		EndIF

	EndIF

End Sequence

RestArea(aAreaAtu)

Return( uRet )

Static Function GrvMemo( cFilSYP , cChave , cSeq , cLine , cCpoChave, cRealAlias )
Local nYP_CAMPO
Local cPrefixo := PrefixoCpo(cRealAlias)

DbSelectArea(cRealAlias)
RecLock( cRealAlias , !DbSeek( cFilSYP + cChave + cSeq ) )
FieldPut(FieldPos(cPrefixo+"_FILIAL"),cFilSYP)
FieldPut(FieldPos(cPrefixo+"_CHAVE"),cChave)
FieldPut(FieldPos(cPrefixo+"_SEQ"),cSeq)
FieldPut(FieldPos(cPrefixo+"_TEXTO"),cLine)
IF (nYP_CAMPO := FieldPos(cPrefixo+"_CAMPO")) > 0
	FieldPut(nYP_CAMPO,cCpochave)
EndIF
MsUnlock()
FkCommit()
Return( NIL )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³E_MsMM    ³ Autor ³ AVERAGE/MJBARROS      ³ Data ³ 22.07.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Inicializacao de campos memo para visualizacao              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ idem parametros da MsMM                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGAEIC/SIGACOM                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function E_MsMM(cChave,nTam,nLin,cString,nOpc,nTabSize,lWrap,cAlias,cCpochave)
Return If(Inclui,"",MsMM(cChave,nTam,If(GetStartMod1(),nLin,1),cString,nOpc,nTabSize,lWrap,cAlias,cCpochave))

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³PrefixoCpo³ Autor ³ Gilson					  ³ Data ³ 08.10.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Devolve prefixo do campo para o Alias Apontado				  ³±±
±±³			 ³ 																			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias																	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function PrefixoCpo(cAlias)
Local cRet
If cAlias == Nil
	cAlias := Alias()
EndIf
If Subs(cAlias,1,1) != "S" .and. Len(cAlias) == 3
	cRet := Subs(cAlias,1,3)
Else
	cRet := Subs(cAlias,2,2)
EndIf
Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SomaIt 	³ Autor ³  Marcos Simidu	     ³ Data ³ 19/05/97³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Soma um no item											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SomaIt(cItem)
Return(Soma1(cItem))

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³InverteSi1³ Autor ³ Alice Yaeko Yamamoto  ³ Data ³ 12/11/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Cria codigo invertido da Conta 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function InverteSi1(cCodigo)
Local j
Local cCodInv:=""
Local nFator

//ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ 0  - 9	³	 Exemplos de contas Invertidas			  ³
//³ 1  - 8	³	 1 		- 8zzzzzzzzzzzzzz 				  ³
//³ 2  - 7	³	 11		- 88zzzzzzzzzzzzz 				  ³
//³ 3  - 6	³	 1110208 - 8889791zzzzzzzz 				  ³
//³ 4  - 5	³														  ³
//³ 5  - 4	³														  ³
//³ 6  - 3	³														  ³
//³ 7  - 2	³														  ³
//³ 8  - 1	³														  ³
//³ 9  - 0	³														  ³
//³" " - z  ³                                           ³
//ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

For j := 1 To 20
	If Subs(cCodigo,j,1) = " "
		cCodInv += "z"
	Else
		nFator  := 9-Int(Val(Subs(cCodigo,j,1)))
		cCodInv += Str(nFator,1)
	EndIf
Next
Return cCodInv

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³A460NumIt ³ Autor ³ Rosane Luciane Chene  ³ Data ³ 23.10.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³VerIfica conforme o numero de serie , qual a quantidade	  ³±±
±±³			 ³de maxima de itens por nota fiscal								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ MATA460	e MATA100													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A460NumIt(cSerie, lEntrada)
Local  cAlias :=Alias()
Local  nItens :=0
Local  cParam :=""

DEFAULT lEntrada := .F.

nItens:=GETMV("MV_NUMITEN")
cParam := "MV_ITEM" + cSerie
nItens:=GetNewPar(cParam,nItens)

If lEntrada
	If ExistBlock("MTAITNFE")
		nItens := ExecBlock("MTAITNFE",.F.,.F.,{nItens,cSerie})
	EndIf
Else
	If ExistBlock("MTAITNFS")
		nItens := ExecBlock("MTAITNFS",.F.,.F.,{nItens,cSerie})
	EndIf
EndIf

DbSelectArea(cAlias)
Return( nItens )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³IsTriangul³ Autor ³ Ben-Hur M Castilho	  ³ Data ³ 15/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³VerIfica se utiliza operacao triangular.						  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function IsTriangular( lNewValue )

Static lTriangular := .F.

If ((PCount() == 1) .And. (ValType( lNewValue ) == "L"))
	lTriangular := lNewValue
EndIf

Return( lTriangular )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ fC010Venc³ Autor ³ Vinicius S. Barreira  ³ Data ³ 31/10/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a data de vencimento. 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fC010Venc() 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function fC010Venc()

Local dData := dDataBase

If DataValida(SE1->E1_VENCTO,.T.) <= dDataBase
	dData := SE1->E1_VENCTO
Else
	dData := DataValida(SE1->E1_VENCTO,.t.)
EndIf
Return dData

/*/{Protheus.doc} CalcEst
//TODO Descrição A Rotina padrao foi renomeada para xCalcEst(), para os casos
	que utilizam banco de dados disparem uma Stored Procedure MAT006.SQL.
	Se a procedure nao existir a rotina padrao xCalcEst() sera executada.							  ³±±
	Motivo basico da alteracao e a Otimizacao e Performance
.
@author Vicente Sementilli
@since 27.07.98
@version undefined
@param cCod, characters, Código do produto
@param cLocal, characters, Código do Local de Estoque
@param dData, date, Data do saldo Inicial
@param cFilAux, characters, *** em desuso ***
@param lConsTesTerc, logical, Considera Poder de Terceiros
@param lCusRep, logical, Considera Custo de Reposicao. Por procedure, sempre considera
@type function
/*/
Function CalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cxFilial	:= ""
Local cProcNam  := GetSPName("MAT006","14")
Local lD3Servico:= SuperGetMV('MV_D3SERVI', .F.,'N')=='S'
Local lMATA103	:= IsInCallStack("MATA103")
Local lD3Servico:= IIF(lWmsNew,.F.,SuperGetMV('MV_D3SERVI',.F.,'N')=='S')

Default dData        := dDataBase
Default lConsTesTerc := .F.

dData := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)

If !lMATA103 .AND. ExistProc( cProcNam, VerIDProc())
	If ( TcSrvType() <> "AS/400" )
		aResult := {}
		aResult := TCSPExec( xProcedures(cProcNam),	cCod,;							// 01. Codigo do Produto
													cLocal,;						// 02. Codigo do Armazem
													DTOS(dData),;					// 03. Data de Processamento
													''/*em deuso*/,;  				// 04. Colocado os tracos antes e depois do @@ para nao ocorrer erro no geracao de ch
													GetMvNNR('MV_LOCPROC','99'),;			// 05. Armazem de Processo
													cFilAnt,;						// 06. Codigo da Filial
													If(lD3Servico,'1','0'),;		// 07. Considera o parametro MV_D3SERVI
													If(IntDL(cCod),'1','0'),;		// 08. Verifica a integracao com WMS
													GetMvNNR('MV_CQ','98'),;	// 09. Armazem de CQ
													If(lWmsNew,'1','0'),;			// 10. Novo Wms
													If(lConsTesTerc,'1','0');		// 11. Considera Poder de Terceiros
							)

		If aResult == Nil
			Final(STR0091) //"RE-INSTALAR AS STORED PROCEDURES"
		EndIf

	Else // TcSrvType() == "AS/400"
		cxFilial := BuildStrFil("SD1,SD2,SD3,SF4,SB9,SF5")
		aResult  := {}
		aResult  := TCSPExec( xProcedures(cProcNam), 	cxFilial, ;
														cCod, ;
														cLocal,;
														DTOS(dData), ;
														If(cFilAux=nil,"@@",cFilAux),;
														GetMvNNR('MV_LOCPROC','99'), ;
														cFilAnt,;
														Substr(cUsuario,7,15), ;
														DTOS(dDataBase))
	EndIf
	Return (aResult)
Else
	Return xCalcEst(@cCod,@cLocal,@dData,@cFilAux,lConsTesTerc,lCusRep)
EndIf

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ xCalcEst ³ Autor ³ Wilson Junior         ³ Data ³ 28.03.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Saldo inicial por Produto/Local do arquivo SB9 - ³±±
±±³          ³ Saldos Iniciais.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.    ³±±
±±³          ³ ExpC1 = Codigo do Produto                                  ³±±
±±³          ³ ExpC2 = Local (AlmoxarIfado)                               ³±±
±±³          ³ ExpD1 = Data para obter o Saldo Inicial.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGACUS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function xCalcEst(cCod,cLocal,dData,cFilAux,lConsTesTerc,lCusRep)

#define F_SB9  1
#define F_SD1  2
#define F_SD2  3
#define F_SD3  4
#define F_SF4  5
#define F_SF5  6

Local nReg,nReg1,nOrd,nOrd1,dDtVai
Local lHasRec := .F.
Local aSaldo     := { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }
Local cLocProc   := GetMvNNR('MV_LOCPROC','99')
Local cArq       := Alias()
Local nCnt01     := 0

Local aFilial  := { xFilial( "SB9" ),;
                    xFilial( "SD1" ),;
                    xFilial( "SD2" ),;
                    xFilial( "SD3" ),;
                    xFilial( "SF4" ),;
                    xFilial( "SF5" ) }

Local lRemInt  := SuperGetMv("MV_REMINT",.F.,.F.)
Local nSizeFil := 2
Local lUsaD2DIG  := UsaD2DTDIG()
Local cFiltroSF5 :=	SF5->(DbFilter())

DEFAULT lConsTesTerc := .F.
DEFAULT lCusRep      := .F.
DEFAULT dData        := dDataBase
SF5->(DBClearFilter())

dData	 := If(Empty(dData),Ctod( "01/01/80","ddmmyy" ),dData)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de partida para compor o saldo inicial.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SB9" )

DbSeek(aFilial[ F_SB9 ]+cCod+cLocal)
lHasRec := .f.
While !Eof() .and. (aFilial[ F_SB9 ]+cCod+cLocal == B9_FILIAL + B9_COD+B9_Local)
	If B9_DATA >= dData .and. lHasRec
		Exit
	Else
		lHasRec := .t.
	EndIf

	DbSkip()
End
If lHasRec
	DbSkip(-1)
EndIf


If ((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
	(SB9->B9_DATA < dData))

	aSaldo[01] := SB9->B9_QINI
	aSaldo[02] := SB9->B9_VINI1
	aSaldo[03] := SB9->B9_VINI2
	aSaldo[04] := SB9->B9_VINI3
	aSaldo[05] := SB9->B9_VINI4
	aSaldo[06] := SB9->B9_VINI5
	aSaldo[07] := SB9->B9_QISEGUM
	aSaldo[08] := SB9->B9_CM1
	aSaldo[09] := SB9->B9_CM2
	aSaldo[10] := SB9->B9_CM3
	aSaldo[11] := SB9->B9_CM4
	aSaldo[12] := SB9->B9_CM5

	If lCusRep
		aSaldo[13] := SB9->B9_CMRP1
		aSaldo[14] := SB9->B9_CMRP2
		aSaldo[15] := SB9->B9_CMRP3
		aSaldo[16] := SB9->B9_CMRP4
		aSaldo[17] := SB9->B9_CMRP5
		aSaldo[18] := SB9->B9_VINIRP1
		aSaldo[19] := SB9->B9_VINIRP2
		aSaldo[20] := SB9->B9_VINIRP3
		aSaldo[21] := SB9->B9_VINIRP4
		aSaldo[22] := SB9->B9_VINIRP5
	EndIf
	dDtVai    := SB9->B9_DATA+1
Else
	dDtVai    := Ctod( "01/01/80","ddmmyy" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Correr SD1, SD2 e SD3 para  obter o saldo na Data desejada. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SF4" )
nReg1 := Recno()
nOrd1 := Indexord()

DbSelectArea( "SD1" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD1 ]+cCod+cLocal+Dtos(dDtVai),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD1 ]+cCod+cLocal) == (SD1->D1_FILIAL+SD1->D1_COD+SD1->D1_Local) .And.;
	(SD1->D1_DTDIGIT < dData))

	#ifdef SHELL
		If SD1->D1_CANCEL == "S"
			SD1->(DbSkip())
			Loop
		EndIf
	#endif

	If cPaisLoc != "BRA"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconsiderar notas de remito e notas geradas pelo EIC       ³
		//| com excecao da nota de FOB.									 |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(SD1->D1_REMITO) .Or. SD1->D1_TIPO_NF $ '6789AB'
			SD1->(DbSkip())
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconsiderar notas de entrada tipo 10 quando o cliente uti_ |
		//| lizar o conceito de remito interno com importacao (SIGAEIC)  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRemInt
		  	If !Empty(SD1->D1_CONHEC) .And. SD1->D1_TIPO_NF $ '5' .And. SD1->D1_TIPODOC $ '10'
				SD1->(DbSkip())
				Loop
			EndIf
		EndIf

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Somente Notas Fiscais Nao Lancadas No Modulo do Livro Fiscal ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SD1->D1_ORIGLAN == "LF")
		DbSelectArea( "SF4" )
		If (iif (FWModeAccess("SF4") == "E",(SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD1->D1_TES ), ;
				(SF4->F4_FILIAL+SF4->F4_CODIGO == substr(aFilial[ 4 ],1,len(SF4->F4_FILIAL)-len(FWFilial("SF4")))+FWFilial("SF4")+SD1->D1_TES)).Or. ;
			DbSeek( aFilial[ F_SF4 ]+SD1->D1_TES,.F. ))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
			//³ ou TES de poder de terceiros com parametro ligado      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
				aSaldo[1] += SD1->D1_QUANT
				aSaldo[2] += SD1->D1_CUSTO
				aSaldo[3] += SD1->D1_CUSTO2
				aSaldo[4] += SD1->D1_CUSTO3
				aSaldo[5] += SD1->D1_CUSTO4
				aSaldo[6] += SD1->D1_CUSTO5
				aSaldo[7] += SD1->D1_QTSEGUM
				If lCusRep
					aSaldo[18] += SD1->D1_CUSRP1
					aSaldo[19] += SD1->D1_CUSRP2
					aSaldo[20] += SD1->D1_CUSRP3
					aSaldo[21] += SD1->D1_CUSRP4
					aSaldo[22] += SD1->D1_CUSRP5
				EndIf
			EndIf
		EndIf
		DbSelectArea( "SD1" )
	EndIf
	DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SD2" )
nReg := Recno()
nOrd := IndexOrd()
// Verifica se usa o campo D2_DTDIGIT ou nao, de acordo com a funcao UsaD2DTDIG
DbSetOrder( IIf(lUsaD2DIG, 11, 6) )

DbSeek( aFilial[ F_SD2 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD2 ]+cCod+cLocal == SD2->D2_FILIAL+SD2->D2_COD+SD2->D2_Local) .And. ;
	IIf(lUsaD2DIG, (SD2->D2_DTDIGIT < dData), (SD2->D2_EMISSAO < dData)) )

	#ifdef SHELL
		If SD2->D2_CANCEL == "S"
			SD2->(DbSkip())
			Loop
		EndIf
	#endif

	If !Empty(SD2->D2_REMITO) .And. !(SD2->D2_TPDCENV $ "A1")
		SD2->(DbSkip())
		Loop
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Despreza Notas Fiscais Lancadas Pelo Modulo do Livro Fiscal  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SD2->D2_ORIGLAN == "LF")
		DbSelectArea("SF4")
		If ((SF4->F4_FILIAL+SF4->F4_CODIGO == aFilial[ F_SF4 ]+SD2->D2_TES ) .Or. ;
			DbSeek( aFilial[ F_SF4 ]+SD2->D2_TES,.F. ))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente TES Que Movimenta Estoque Deve Ser Considerada ³
			//³ ou TES de poder de terceiros com parametro ligado      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SF4->F4_ESTOQUE == "S") .Or. (lConsTesTerc .And. SF4->F4_PODER3 $ "RD")
				aSaldo[1] -= SD2->D2_QUANT
				aSaldo[2] -= SD2->D2_CUSTO1
				aSaldo[3] -= SD2->D2_CUSTO2
				aSaldo[4] -= SD2->D2_CUSTO3
				aSaldo[5] -= SD2->D2_CUSTO4
				aSaldo[6] -= SD2->D2_CUSTO5
				aSaldo[7] -= SD2->D2_QTSEGUM
				If lCusRep
					aSaldo[18] -= SD2->D2_CUSRP1
					aSaldo[19] -= SD2->D2_CUSRP2
					aSaldo[20] -= SD2->D2_CUSRP3
					aSaldo[21] -= SD2->D2_CUSRP4
					aSaldo[22] -= SD2->D2_CUSRP5
				EndIf
			EndIf
		EndIf
		DbSelectArea( "SD2" )
	EndIf
	DbSkip(1)
End

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSetOrder( nOrd ) ; DbGoTo( nReg )

DbSelectArea( "SF4" )
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )

DbSelectArea( "SF5" )
nReg1 := Recno()
nOrd1 := IndexOrd()

DbSelectArea( "SD3" )
nReg := Recno()
nOrd := IndexOrd()
DbSetOrder( 7 )

DbSeek( aFilial[ F_SD3 ]+cCod+cLocal+DtoS( dDtVai ),.T. )

While (!Eof() .And. ;
	(aFilial[ F_SD3 ]+cCod+cLocal == SD3->D3_FILIAL+SD3->D3_COD+SD3->D3_Local) .And. ;
	(SD3->D3_EMISSAO < dData))
	If !D3Valido()
		DbSkip()
		Loop
	EndIf
	DbSelectArea( "SF5" )
	If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
		(SD3->D3_TM == "499") .Or. ;
		(SD3->D3_TM == "999") .Or. ;
		DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))
		If SD3->D3_TM >"500"
			aSaldo[1] -= SD3->D3_QUANT
			aSaldo[2] -= SD3->D3_CUSTO1
			aSaldo[3] -= SD3->D3_CUSTO2
			aSaldo[4] -= SD3->D3_CUSTO3
			aSaldo[5] -= SD3->D3_CUSTO4
			aSaldo[6] -= SD3->D3_CUSTO5
			aSaldo[7] -= SD3->D3_QTSEGUM
			If lCusRep
				aSaldo[18] -= SD3->D3_CUSRP1
				aSaldo[19] -= SD3->D3_CUSRP2
				aSaldo[20] -= SD3->D3_CUSRP3
				aSaldo[21] -= SD3->D3_CUSRP4
				aSaldo[22] -= SD3->D3_CUSRP5
			EndIf
		Else
			aSaldo[1] += SD3->D3_QUANT
			aSaldo[2] += SD3->D3_CUSTO1
			aSaldo[3] += SD3->D3_CUSTO2
			aSaldo[4] += SD3->D3_CUSTO3
			aSaldo[5] += SD3->D3_CUSTO4
			aSaldo[6] += SD3->D3_CUSTO5
			aSaldo[7] += SD3->D3_QTSEGUM
			If lCusRep
				aSaldo[18] += SD3->D3_CUSRP1
				aSaldo[19] += SD3->D3_CUSRP2
				aSaldo[20] += SD3->D3_CUSRP3
				aSaldo[21] += SD3->D3_CUSRP4
				aSaldo[22] += SD3->D3_CUSRP5
			EndIf
		EndIf
	EndIf
	DbSelectArea( "SD3" ) ; DbSkip(1)
End

If AllTrim(cLocal) == AllTrim(cLocProc)

	DbSetOrder( 7 )

	DbSeek( aFilial[ F_SD3 ]+cCod,.T. )

	While (!Eof() .And. ;
		(aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD))

		If SD3->D3_EMISSAO >= dData
			SD3->(dbSkip())
			Loop
		EndIf

		While (!Eof() .And. ;
			(aFilial[ F_SD3 ]+cCod == SD3->D3_FILIAL+SD3->D3_COD) .And. ;
			(SD3->D3_EMISSAO < dData))

			If ((SD3->D3_EMISSAO <  dData)      .And. ;
				(SD3->D3_EMISSAO >= dDtVai)     .And. ;
				(SubS( SD3->D3_CF,2 ) == "E3")  .And. ;
				!(alltrim(SD3->D3_Local) == alltrim(cLocProc)))

				If !D3Valido()
					DbSkip()
					Loop
				EndIf

				DbSelectArea( "SF5" )
				If ((SF5->F5_FILIAL+SF5->F5_CODIGO == aFilial[ F_SF5 ]+SD3->D3_TM) .Or. ;
					(SD3->D3_TM == "499") .Or. ;
					(SD3->D3_TM == "999") .Or. ;
					DbSeek( aFilial[ F_SF5 ]+SD3->D3_TM,.F. ))

					If SD3->D3_CF = "RE3"

						aSaldo[1] += SD3->D3_QUANT
						aSaldo[2] += SD3->D3_CUSTO1
						aSaldo[3] += SD3->D3_CUSTO2
						aSaldo[4] += SD3->D3_CUSTO3
						aSaldo[5] += SD3->D3_CUSTO4
						aSaldo[6] += SD3->D3_CUSTO5
						aSaldo[7] += SD3->D3_QTSEGUM
						If lCusRep
							aSaldo[18] += SD3->D3_CUSRP1
							aSaldo[19] += SD3->D3_CUSRP2
							aSaldo[20] += SD3->D3_CUSRP3
							aSaldo[21] += SD3->D3_CUSRP4
							aSaldo[22] += SD3->D3_CUSRP5
						EndIf
					ElseIf SD3->D3_CF = "DE3"
						aSaldo[1] -= SD3->D3_QUANT
						aSaldo[2] -= SD3->D3_CUSTO1
						aSaldo[3] -= SD3->D3_CUSTO2
						aSaldo[4] -= SD3->D3_CUSTO3
						aSaldo[5] -= SD3->D3_CUSTO4
						aSaldo[6] -= SD3->D3_CUSTO5
						aSaldo[7] -= SD3->D3_QTSEGUM
						If lCusRep
							aSaldo[18] -= SD3->D3_CUSRP1
							aSaldo[19] -= SD3->D3_CUSRP2
							aSaldo[20] -= SD3->D3_CUSRP3
							aSaldo[21] -= SD3->D3_CUSRP4
							aSaldo[22] -= SD3->D3_CUSRP5
						EndIf
					EndIf
				EndIf
			EndIf

			DbSelectArea("SD3")
			DbSkip()
		End
	End
EndIf

DbSetOrder( nOrd ) ; DbGoTo( nReg )


DbSelectArea("SF5")
DbSetOrder( nOrd1 ) ; DbGoTo( nReg1 )
If !Empty (cFiltroSF5)
	dbSetFilter({||&cFiltroSF5},cFiltroSF5)
EndIf

If !Empty(cArq)
	DbSelectArea( cArq )
EndIf

Return( aSaldo )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³CalcEstFF ³ Autor ³ Ben-Hur M. Castilho   ³ Data ³ 03.03.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Saldo Inicial por Produto/Local do arquivo SB9 - ³±±
±±³			 ³ Saldos Iniciais. (Custo FIfO) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com o Saldo Inicial para o Produto/Local.	  ³±±
±±³			 ³ ExpC1 = Codigo do Produto								  ³±±
±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
±±³          ³ ExpC3 = Lote FIFO                                          ³±±
±±³          ³ ExpL1 = Forca uso do saldo inicial padrao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGACUS													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFiFO,lForcaSB9)

#ifdef F_SB9
	#undef F_SB9
#endif

#define F_SB9	1
#define F_SD8	2

Local aSaldo  := { 0,0,0,0,0,0,0 }
Local cArq    := Alias()
Local nOrdD8  := 0
Local nCnt01  := 0
Local dDtVai  := NIL

Local aFilial	 := { xFilial( "SB9" ), xFilial( "SD8" ) }
Local nMultiplic := 1
Local lSaldoIni  :=.T.
Local nSizeFil   := 2

Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
Default lConsTesTerc := .F.
Default lForcaSB9    := .F.

dbSelectArea("SCC")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a NAO utilizacao da tabela SCC referente ao fechamento Fifo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !IsFechFifo() .Or. lForcaSB9

	If Empty(cLoteFIFO)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de partida para compor o saldo inicial.        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea( "SB9" )

		DbSeek( aFilial[ F_SB9 ]+cCod+cLocal+DtoS( dData ),.T. ) ; DbSkip(-1)

	EndIf

	If Empty(cLoteFIFO) .And. ;
		((aFilial[ F_SB9 ]+cCod+cLocal == SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_Local) .And. ;
		(SB9->B9_DATA < dData))

		If Empty(SB9->B9_DATA)
			lSaldoIni := .F.
		Else
			aSaldo[1] := SB9->B9_QINI
			aSaldo[2] := SB9->B9_VINIfF1
			aSaldo[3] := SB9->B9_VINIfF2
			aSaldo[4] := SB9->B9_VINIfF3
			aSaldo[5] := SB9->B9_VINIfF4
			aSaldo[6] := SB9->B9_VINIfF5
			aSaldo[7] := SB9->B9_QISEGUM
			dDtVai	  := SB9->B9_DATA+1
		EndIf
	Else
		lSaldoIni := .F.
		dDtVai	 := Ctod( "01/01/80","ddmmyy" )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Correr SD8 para	obter o saldo na Data desejada.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SD8" )
	nRecSD8:= Recno()
	nOrdD8 := IndexOrd()
	DbSetOrder( 4 )
	DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
	Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra movimentos com data anterior a saldo inicial³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lSaldoIni .And. SD8->D8_DATA < dDtVai .Or. ;
			(!Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO))
			DbSkip()
			Loop
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra movimentos com data posterior a data solicitada³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SD8->D8_DATA < dData .And. (SD8->D8_TIPONF # "E" .Or. (SD8->D8_TIPONF == "E" .And. !lSaldoIni))
			If SD8->D8_TM > "500"
				nMultiplic:= -1
			Else
				nMultiplic:= 1
			EndIf
			aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
			aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
			aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
			aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
			aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
			aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
			aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
		EndIf
		DbSkip()
	End
	DbSetOrder( nOrdD8 )
	DbGoTo(nRecSD8)
	DbSelectArea( cArq )
Else

	DbSelectArea( cArq )
	Return xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

EndIf

Return( aSaldo )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³xCalcEstFF ³ Autor ³ Marcos V. Ferreira   ³ Data ³ 22.11.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o Saldo Inicial por Produto/Local do arquivo SCC - ³±±
±±³			 ³ Saldos Iniciais. (Custo FIfO) 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := CalcEst(ExpC1,ExpC2,ExpD1) 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto								  ³±±
±±³			 ³ ExpC2 = Local (AlmoxarIfado)								  ³±±
±±³			 ³ ExpD1 = Data para obter o Saldo Inicial.					  ³±±
±±³          ³ ExpC3 = Filial Auxiliar                                    ³±±
±±³          ³ ExpL1 = Considera Tes Terceiros                            ³±±
±±³          ³ ExpC4 = Lote FIFO                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGACUS													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function xCalcEstFF( cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo)

#ifdef F_SCC
	#undef F_SCC
#endif

#define F_SCC	1
#define F_SD8	2

Local lHasRec
Local aSaldo  := { 0,0,0,0,0,0,0 }
Local cArq    := Alias()
Local nOrdD8  := 0
Local nCnt01  := 0
Local dDtVai  := Ctod( "01/01/80","ddmmyy" )
Local dDtIni  := Nil

Local aFilial	 := { xFilial( "SCC" ), xFilial( "SD8" ) }
Local nMultiplic := 1
Local lSemLtFifo := Empty(cLoteFifo)
Local nSizeFil   := FWSizeFilial()

Default cLoteFIFO    := CriaVar('D8_SEQ', .F.)
Default lConsTesTerc := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de partida para compor o saldo inicial.        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SCC" )
If lSemLtFifo
	dbSetOrder( 1 ) //-- CC_PRODUTO+CC_LOCAL+CC_DATA
Else
	dbSetOrder( 2 ) //-- CC_PRODUTO+CC_LOCAL+CC_SEQ+CC_DATA
EndIf

DbSeek( aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DtoS( dData ),.T. ) ; DbSkip(-1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca Saldo Inicial                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lHasRec:=.F. // Utiliza como sinalizador de leitura do SCC

dDtIni := SCC->CC_DATA

While !Bof() .And. DTOS(SCC->CC_DATA) <= DTOS(dData) .And. ;
	  (aFilial[ F_SCC ]+cCod+cLocal+IIf(lSemLtFifo,"",cLoteFifo)+DTOS(dDtIni) == ;
	  SCC->CC_FILIAL+SCC->CC_PRODUTO+SCC->CC_LOCAL+IIf(lSemLtFifo,"",SCC->CC_SEQ)+DTOS(SCC->CC_DATA))
	lHasRec:=.T.
	aSaldo[1] += SCC->CC_QFIM
	aSaldo[2] += SCC->CC_VFIMFF1
	aSaldo[3] += SCC->CC_VFIMFF2
	aSaldo[4] += SCC->CC_VFIMFF3
	aSaldo[5] += SCC->CC_VFIMFF4
	aSaldo[6] += SCC->CC_VFIMFF5
	aSaldo[7] += SCC->CC_QFIM2UM
	dDtVai    := SCC->CC_DATA+1
	dbSkip(-1)
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se nao leu nenhum registro na tabela SCC forcar a composicao |
//| do saldo inicial atraves da metodologia anterior             |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lHasRec
	aSaldo:=CalcEstFF(cCod,cLocal,dData,cFilAux,lConsTesTerc,cLoteFifo,.T.)
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Correr SD8 para	obter o saldo na Data desejada.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SD8" )
	nRecSD8:= Recno()
	nOrdD8 := IndexOrd()
	DbSetOrder( 4 )
	DbSeek( aFilial[ F_SD8 ]+cCod+cLocal)
	Do While (!Eof() .And.	(aFilial[ F_SD8 ]+cCod+cLocal) == (SD8->D8_FILIAL+SD8->D8_PRODUTO+SD8->D8_LOCAL))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra movimentos com data anterior a saldo inicial ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SD8->D8_DATA < dDtVai .Or. SD8->D8_TIPONF == "E"
			DbSkip()
			Loop
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra movimentos que nao estao no lote informado   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(cLoteFIFO) .And. !(SD8->(D8_SEQ)==cLoteFIFO)
			DbSkip()
			Loop
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra movimentos com data posterior a data solicitada³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SD8->D8_DATA < dData
			If SD8->D8_TM > "500"
				nMultiplic:= -1
			Else
				nMultiplic:= 1
			EndIf
			aSaldo[1] += (SD8->D8_QUANT  * nMultiplic)
			aSaldo[2] += (SD8->D8_CUSTO1 * nMultiplic)
			aSaldo[3] += (SD8->D8_CUSTO2 * nMultiplic)
			aSaldo[4] += (SD8->D8_CUSTO3 * nMultiplic)
			aSaldo[5] += (SD8->D8_CUSTO4 * nMultiplic)
			aSaldo[6] += (SD8->D8_CUSTO5 * nMultiplic)
			aSaldo[7] += (SD8->D8_QT2UM  * nMultiplic)
		EndIf
		DbSkip()
	End
	DbSetOrder( nOrdD8 )
	DbGoTo(nRecSD8)
EndIf

DbSelectArea( cArq )
Return( aSaldo )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³BlqInvent ³ Autor ³ Marcelo Pimentel      ³ Data ³ 27/01/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o produto esta sendo inventariado.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 									              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BlqInvent(cCod,cLocal,dData,cLocaliz,nRecno)

Local lBloq   := .F.
Local aArea   := GetArea()
Local aAreaSB2:= SB2->(GetArea())
Local aAreaSBE:= SBE->(GetArea())
Local aAreaSC9:= SC9->(GetArea())
Local aAreaSDC:= SDC->(GetArea())
Local nw      := 0
Local aSDC    := {}
Local cChave  := ""


Local lAcd    := SuperGetMV("MV_INTACD",.F.,"0") == "1"


DEFAULT dData   := dDataBase
DEFAULT cLocal  := ""
DEFAULT cLocaliz:= ""
DEFAULT nRecno  := ""

DbSelectArea("SB2")
DbSetOrder(1)
If MsSeek(xFilial("SB2")+cCod+cLocal)
	If !Empty(B2_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',(B2_DTINV <= dData .And. dData <= B2_DINVFIM),.T.)
		lBloq := .T.
	EndIf
EndIf

//--Efetua validacao integrado com ACD quando informa o endereco
If lAcd .And. Localiza(cCod) .And. !Empty(cLocaliz)
	DbSelectArea("SBE")
	DbSetOrder(1)
	If DbSeek(xFilial("SBE")+cLocal+cLocaliz)
		If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV >= dData,.T.)
			lBloq := .T.
		EndIf
	EndIf
EndIf

//--Efetua validacao integrado com ACD quando "NAO" informa o endereco(FATURAMENTO)
If lAcd .And. Localiza(cCod) .And. !Empty(nRecno)
dbSelectArea("SC9")
dbSetOrder(1)
MSGoto(nRecno)
	cChave:=(xFilial('SC9')+SC9->C9_PRODUTO+SC9->C9_LOCAL+"SC6"+SC9->C9_PEDIDO+SC9->C9_ITEM)
	DbSelectArea("SDC")
	dbSetOrder(1)
	If MSSeek(cChave)
		While cChave == SDC->DC_FILIAL+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_ORIGEM+SDC->DC_PEDIDO+SDC->DC_ITEM .And. !EoF()
			AADD(aSDC,SDC->DC_LOCALIZ)
			dbSkip()
		EndDo
		For nw:=1 to Len(aSDC)
			DbSelectArea("SBE")
			DbSetOrder(1)
			If DbSeek(xFilial("SBE")+SDC->DC_LOCAL+aSDC[nw])
				If !Empty(BE_DTINV) .And. If(GetNewPar("MV_VLDTINV",'1')=='1',BE_DTINV <= dData,.T.)
					lBloq := .T.
					Help(" ",1,"BLQINVENT",,STR0106+aSDC[nw]+STR0107,1,5)
				EndIf
			EndIf
		Next nw
	EndIf
EndIf

RestArea(aAreaSB2)
RestArea(aAreaSBE)
RestArea(aAreaSC9)
RestArea(aAreaSDC)

RestArea(aArea)
Return (lBloq)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ ASC2SLD	³ Autor ³ Edson Maricate	    ³ Data ³ 02.02.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Efetua o calculo do Saldo Real da Ordem de Producao.		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpN1 = ASC2SLD(ExpC1)   								  ³±±
±±³       	 ³ ExpN1 = Retorno do Saldo da OP                       	  ³±±
±±³       	 ³ ExpC1 = Alias do arquivo da OP                       	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ ASC2SLD()												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION ASC2SLD(cAliasSQL)
LOCAL nDecs := TamSX3("C2_QUANT")[2]
LOCAL nSalop := NoRound(0, nDecs) // Forçar valor zero com casa decimais do SX3
LOCAL lPerdInf := SuperGetMV("MV_PERDINF",.F.,.F.)
DEFAULT cAliasSQL := "SC2"
If (cAliasSQL)->C2_DATRF == CTOD("  /  /   ")
	nSalop := Max(0,NoRound((cAliasSQL)->C2_QUANT - (cAliasSQL)->C2_QUJE - If(lPerdInf,0,(cAliasSQL)->C2_PERDA), nDecs))
EndIf
Return nSalop

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ InVerte  ³ Autor ³ Wilson                ³ Data ³ 17.02.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inverte qualquer campo.                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1 = Inverte(ExpC2,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 - Campo invertido (sempre caracter)                  ³±±
±±³          ³ ExpC2 - Campo a ser convertido                             ³±±
±±³          ³ ExpN1 - Tamanho do campo                                   ³±±
±±³          ³ ExpN2 - Numero de casas decimais                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Inverte(uCpo,nPos,nNumDec)
Local cCpo	:= uCpo
Local cRet	:= ""
Local cByte	:= ""
Local nAsc	:= 0
Local nI		:= 0
Local aChar	:= {}
Local nDiv	:= 0

nNumDec := IIF(nNumDec == Nil,0,nNumDec)

Aadd(aChar,	{" ", "Z"})	// Asc(" ")=0  ->  Asc("Z")=90
Aadd(aChar,	{"0", "Y"})
Aadd(aChar,	{"1", "X"})
Aadd(aChar,	{"2", "W"})
Aadd(aChar,	{"3", "V"})
Aadd(aChar,	{"4", "U"})
Aadd(aChar,	{"5", "T"})
Aadd(aChar,	{"6", "S"})
Aadd(aChar,	{"7", "R"})
Aadd(aChar,	{"8", "Q"})
Aadd(aChar,	{"9", "P"})
Aadd(aChar,	{"A", "O"})
Aadd(aChar,	{"B", "N"})
Aadd(aChar,	{"C", "M"})
Aadd(aChar,	{"D", "L"})
Aadd(aChar,	{"E", "K"})
Aadd(aChar,	{"F", "J"})
Aadd(aChar,	{"G", "I"})
Aadd(aChar,	{"H", "H"})
Aadd(aChar,	{"I", "G"})
Aadd(aChar,	{"J", "F"})
Aadd(aChar,	{"K", "E"})
Aadd(aChar,	{"L", "D"})
Aadd(aChar,	{"M", "C"})
Aadd(aChar,	{"N", "B"})
Aadd(aChar,	{"O", "A"})
Aadd(aChar,	{"P", "9"})
Aadd(aChar,	{"Q", "8"})
Aadd(aChar,	{"R", "7"})
Aadd(aChar,	{"S", "6"})
Aadd(aChar,	{"T", "5"})
Aadd(aChar,	{"U", "4"})
Aadd(aChar,	{"V", "3"})
Aadd(aChar,	{"W", "2"})
Aadd(aChar,	{"X", "1"})
Aadd(aChar,	{"Y", "0"})
Aadd(aChar,	{"Z", "!"})	// Asc("Z")=90  ->  Asc("!")=33

// Se for campo data, primeiro transforma em dtos
If ValType(uCpo) == "D"
   cCpo := Dtos(uCpo)

ElseIf ValType(uCpo) == "N"
	nPos := IIF(nPos == Nil,Len(uCpo),nPos)
   cCpo := StrZero(uCpo,nPos,nNumDec)
EndIf

nPos := IIF(nPos == Nil,Len(cCpo),nPos)

For nI:= 1 to Len(cCpo)
   cByte := Upper(Subs(cCpo,nI,1))
   If (Asc(cByte) >= 48 .And. Asc(cByte) <= 57) .Or. ;	// 0 a 9
   		(Asc(cByte) >= 65 .And. Asc(cByte) <= 90) .Or. ;	// A a Z
   		Empty(cByte)	// " "
	   nAsc	:= Ascan(aChar,{|x| x[1] == cByte})
   	If nAsc > 0
   		cRet := cRet + aChar[nAsc,2]	// Funcao Inverte e chamada pelo rdmake de conversao
	   EndIf
	Else
		// Caracteres <> letras e numeros: mantem o caracter
		cRet := cRet + cByte
	EndIf
Next
If Len(cRet) > nPos
   cRet := Right(cRet,nPos)
EndIf
Return(cRet)

/*
Obs.: Esta funcao perdeu a validade em 21/02/2000,
por nao ser compativel com o ambiente Informix/Linux.
As instalacoes com executaveis do Siga Quality
a partir desta data, devem ser realizadas apos a
execucao do conversor, para que os campos invertidos
sejam regravados com a nova funcao, a partir do campo origem.

Function Inverte(uCpo,nPos)
Local cCpo := uCpo, cRet := "", nByte , nDiv
If ValType(uCpo) == "D"
	cCpo := Dtos(uCpo)
ElseIf ValType(uCpo) == "N"
	nDiv := 1
	nByte := uCpo
	While nByte > 1
		nDiv++
		nByte := Round((nByte / 10),5)
	End
	cCpo := StrZero(uCpo,nDiv,0)
EndIf
nPos := Iif(nPos == Nil,Len(cCpo),nPos)
For ni:= 1 to Len(cCpo)
	nByte := Asc(Subs(cCpo,ni,1))
	If  nByte > 0
		cRet += Chr(255-nByte)
	EndIf
Next
If Len(cRet) > nPos
	cRet := Right(cRet,nPos)
EndIf
Return cRet
*/

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ SaldoI4	³ Autor ³ Alessandro B. Freire  ³ Data ³ 26.03.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Calcula o saldo atual de uma determinada conta at‚ um deter³±±
±±³			 ³ minado periodo utilizando o SI4 ao inves do SI1 			  ³±±
±±³			 ³ Obs.: Deve-se estar posicionado para utilizar esta funcao  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ CalcSaldo(ExpN1)														  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Numero do Periodo, Moeda											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SaldoI4(nPer)

Local nSaldo
Local cAlias:= Alias()
Local nOldSx3	:= Sx3->(recno())
Local nOldOrd	:= Sx3->(indexord())
Local nC

DbSelectArea("SX3")
DbSetOrder(2)

DbSeek( "I4_SALANT" )
nDecimais := X3_DECIMAL

DbSetOrder(nOldOrd)
DbGoTo(nOldSx3)

DbSelectArea("SI4")
DbSetOrder(1)

nSaldo := I4_SALANT

For nC=1 TO nPer

	cSuf	:= Strzero(nC,2)
	nSaldo:= nSaldo-I4_DEBM&cSuf+I4_CRDM&cSuf

Next nC

DbSelectArea(cAlias)
Return Round(nSaldo,nDecimais)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao	 ³E_RetField³ Autor ³ AVERAGE/MJBARROS 	  ³ Data ³ 19.03.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Retorna a descricao de campos chave de cadastro. Funcao que ³±±
±±³			 ³complementa a RetField do Siga a fim de economizar espaco e ³±±
±±³			 ³caber no campo X3_Relacao											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ .................... 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ................................... 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ SIGAEIC-Somente para versao Windows - Importacao			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function E_Field(cChave,cCampoDesc,cOrigem,lChave,nOrder,cCodFilial)

Local nPos := At("_",cCampoDesc)
Local cArea:= If(nPos>3,Left(cCampoDesc,3),"S"+Left(cCampoDesc,2))
Local nRec := (cArea)->(RecNo())
Local nOrd := (cArea)->(IndexOrd())
Local bDesc:= FieldWBlock(cCampoDesc,Select(cArea))
Local bVar, cAreaAux
Local cRet := ""
Local cChvLoja:= ""
Default cCodFilial := (cArea)->(xFilial()) //MCF - 13/07/2015 //LBL - 17/09/2013

Begin Sequence

nPos:=AT("_",cChave)
cAreaAux:=If(nPos>3,Left(cChave,3),"S"+Left(cChave,2))

nOrder:=Iif(nOrder==Nil,1,nOrder)
lChave:=Iif(lChave==Nil,.F.,lChave)
cOrigem:=Iif(cOrigem==Nil,"G",cOrigem)

If bDesc = NIL
	MsgStop("Campo "+cCampoDesc+" nao encontrado para o arquivo "+cArea,"Atenção")
	Break
EndIf

If (nModulo == 17 .Or. nModulo == 29) .And. EicLoja() .And. AllTrim(cAreaAux) == "SA5"

    If cChave == "A5_FORNECE"
       cChvLoja:= "A5_LOJA"
    ElseIf cChave == "A5_FABR"
       cChvLoja:= "A5_FALOJA"
    EndIf

   If(TYPE("INCLUI") <> "U")//FDR - 26/07/13
      If TYPE("M->"+cChave) == "U"
	     cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+SA5->(&cChave+&cChvLoja),cCampoDesc)," ")
	  Else
	     cRet:= If(!INCLUI,Posicione("SA2",1,xFilial("SA2")+M->(&cChave+&cChvLoja),cCampoDesc)," ")
	  EndIf
   EndIf


	Break
EndIf

If cOrigem = "G" // Gatilho/Enchoice  ou Browse se For U
	If TYPE("M->"+cChave) != "U"
		bVar := MemVarBlock(cChave)
		cChave:=Eval(bVar)
	Else
		cChave:= Eval(FieldWBlock(cChave,Select(cAreaAux)))
	EndIf
Else
	// Browse
	cChave:=Eval(FieldWBlock(cChave,Select(cAreaAux)))
EndIf

If Empty(cChave)
	Break
EndIf

If nModulo == 17
	If Empty(cCodFilial) .And. Empty((cArea)->(xFilial()))
		cCodFilial := (cArea)->(xFilial())
	EndIf
Else
   cCodFilial := (cArea)->(xFilial())
EndIf

(cArea)->(DbSetOrder(nOrder))
(cArea)->(DbSeek(cCodFilial+cChave))
cCampoDesc:=Eval(bDesc)

If nRec > 0
	(cArea)->(DbGoTo(nRec))
	(cArea)->(DbSetOrder(nOrd))
EndIf

cRet := If(!lChave,cCampoDesc,cChave+" "+cCampoDesc)
End Sequence

Return cRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ EspOrder 	³ Autor ³ Ana Claudia		  ³ Data ³ 23/06/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Substitui a funcao DbSetOrder() devido a fusao dos Sistemas³±±
±±³			 ³EspecIficos e Padrao, evitando problemas no acesso ao Sindex³±±
±±³			 ³ - Esta funcao deve ser usada apenas nos programas proprios.³±±
±±³			 ³ Para o padrao permanece os mesmos indices 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ EspOrder(ExpC1,ExpN2)												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias a ser colocada a ordem							  ³±±
±±³			 ³ ExpN2 = Ordem da Shell												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function EspOrder(cAlias,nOrdem)
Local nIndice := 1, nAT
Local cText

If Len( __aCache ) == 0
	cText := ' *****  W a r n i n g  ***** ' + CRLF
	cText += ' Function ESPORDER' + CRLF
	cText += ' This function is accepted only for compatibility with old versions.' + CRLF
	cText += ' Please Change to Nickname in index.' + CRLF
	ConOut( cText )
EndIf

cAlias := If(cAlias==NIL,Alias(),cAlias)
nOrdem := If(nOrdem==NIL,1,nOrdem)

If ( nAt:= ASCAN(__aCache, { |x| x[1] == cAlias+StrZero(nOrdem,2,0) } ) ) > 0
   dbSetOrder(__aCache[nAT,2])
   Return .t.
EndIf

nAT:=1
If SIX->(DbSeek(cAlias))
	While ! SIX->(Eof()) .and. SIX->INDICE == cAlias
		If SIX->PROPRI == "T"   // T serve de exemplo pq e maior que S
			// usado no SIX->PROPRI
			If nOrdem == nIndice
				If Empty(Val(SIX->ORDEM))
					(cAlias)->( DbSetOrder(Asc(SIX->ORDEM)-55))
					nAT := Asc(SIX->ORDEM)-55
				Else
					(cAlias)->( DbSetOrder(Val(SIX->ORDEM)) )
					nAT := Val(SIX->ORDEM)
				EndIf
				Exit
			EndIf
			nIndice ++
		EndIf
		SIX->(DbSkip())

	End
EndIf
AADD(__aCache,{cAlias+StrZero(nOrdem,2,0),nAT})
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ BuildStrFil ³ Autor ³ Wilson Jr. 		  ³ Data ³ 08.07.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a xFilial dos arquivos que serao usados na chamada ³±±
±±³			 ³ da stored procedure													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ BuildStrFil(cString) 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 																			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BuildStrFil(cString)
Local cRet,cStr,ni

If cString == Nil
	cString := Alias()
EndIf
cString := Upper(cString)
cRet := ""
cStr := ""

For ni:= 1 to Len(cString)
	If Subs(cString,ni,1) == ","
		cRet += FWModeAccess(cStr,3)
		cStr := ""
	Else
		cStr += Subs(cString,ni,1)
	EndIf
Next
If !Empty(cStr)
	cRet += FWModeAccess(cStr,3)
EndIf

Return cRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ xProcedures ³ Autor ³ Vicente Sementilli ³ Data ³ 27.07.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Para cada Empresa existira uma Stored Procedure. Portanto  ³±±
±±³			 ³ esta rotina recebe o nome da Stored Procedure e concatena  ³±±
±±³			 ³ a empresa corrente ao nome (<nome>+_+<empresa>))			  ³±±
±±³			 ³ Ex. SP_01																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := xProcedures(ExpC1)										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = String com o nome concatenado com a Empresa.		  ³±±
±±³			 ³ ExpC1 = String com o nome da Procedure 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function xProcedures (cProcedure)

Local cUnion := "_"

cProcedure := iif(cProcedure = nil, 'NENHUMA', Upper(cProcedure+cUnion+cEmpAnt) )

Return (cProcedure)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o	  ³RetTitle  ³ Autor ³ Pilar Sanchez Albalade³ Data ³ 02/06/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Retorna o titulo do campo cadastrado no SX3.					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ RetTitle																	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		  ³ SIGACON																	   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function RetTitle(cCampo,nTamanho,lRestSX3)
Local cAlias	 := Alias()
Local nSx3Order  := SX3->(IndexOrd())
Local cTitulo	 := " "
Local aArea		:=	SX3->(GetArea())
DEFAULT lRestSX3	:=	.F.

DbSelectArea("SX3")
DbSetOrder(2)

If ( MSSeek(cCampo) )
	cTitulo := X3Titulo()+Space(50)
EndIf
nTamanho := Iif(nTamanho == Nil,Len(X3Titulo()),nTamanho)
cTitulo := Substr(cTitulo,1,nTamanho)
If lRestSX3
	RestArea(aArea)
Else
	DbSetOrder(nSX3Order)
Endif
If !Empty(cAlias)
	DbSelectArea(cAlias)
Endif
cTitulo := OemToAnsi(cTitulo)

Return cTitulo

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o			³ValorContab Autor ³ Pilar S. Albaladejo		 ³ Data ³ 23/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Imprime saldos contabeis com sinal de acordo com parametro ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ ValorContab(nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal, 	³±±
±±³			  ³ lEstrang,cTipo,cConta) 												³±±
±±³			  ³ Onde:																		³±±
±±³			  ³ nSaldo	= Valor a ser impresso										³±±
±±³			  ³ nLin 	= Linha onde sera impresso 								³±±
±±³			  ³ nCol 	= Coluna onde sera impresso								³±±
±±³			  ³ nTamanho= Tamanho maximo disponivel para impressao				³±±
±±³			  ³ nDecimais = Numero de decimais a serem impressas				³±±
±±³			  ³ lSinal	= Valor sera impresso com sinal ou nao (Os sinais	³±±
±±³			  ³			  poderao ser D/C ou - ou ()								³±±
±±³			  ³ lEstrang= Considera ou nao picture de lingua estrangeira	³±±
±±³			  ³ cTipo	= Indica se o tipo de dado sera D/C (quando nao 	³±±
±±³			  ³			  existe registro para identIfica-lo=final de arqui³±±
±±³			  ³			  vo e impressao dos totais -> devera ser usado 	³±±
±±³			  ³			  somente com lSinal = .F. 																					 ³±±
±±³			  ³ cConta	= Indica o deve posicionar registro no SI1			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso				³ SIGACON																																												 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValorContab( nSaldo,nLin,nCol,nTamanho,nDecimais,lSinal,lEstrang,cTipo,cConta)

Local cOldAlias := ALIAS()
Local nReg
Local nOrder := SI1->(IndexOrd())
Local nCol1
Local cPict

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se os tamanhos foram passados ou encontrados		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTamanho == Nil
	nTamanho 		 := 14
	nDecimais		 := 2
EndIf

nSaldo			 := Iif(nSaldo == NIl, 0, nSaldo)
lEstrang 					:= Iif(lEstrang == Nil, .F., lEstrang)
cTipo 			 := Iif(cTipo==Nil, Space(1), cTipo)

DbSelectArea("SI1")
DbSetOrder(1)
nReg := Recno()

If !Empty(cConta)
	DbSeek(cFilial+cConta)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tipo D -> Default (D/C)												  ³
//³ Tipo S -> Imprime saldo com sinal									  ³
//³ Tipo P -> Imprime saldo entre parenteses (qdo. negativo)	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTipoSinal := GetMV("MV_TPVALOR")       // Assume valor default

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna a picture. Caso nao exista espaco, retira os pontos  ³
//³ separadores de dezenas, centenas e milhares 					  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cPicture := TmContab(nSaldo,nTamanho,nDecimais)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³* Alguns valores, apesar de  terem sinal devem ser impressos  ³
//³ sem sinal (lSinal). Ex: valores de colunas Debito e Credito  ³
//³* Se estiver com a opcao de lingua estrangeira (lEstrang) a   ³
//³ picture sera invertida para exibir valores: 999,999,999.99   ³
//³* O tipo de sinal "D" - default nao leva em consideracao a    ³
//³ a natureza da conta. Dessa forma valores negativos serao	  ³
//³ impressos sem sinal, e ao seu lado "D" (Devedor) e valores   ³
//³ positivos terao um "C" (Credito) impresso ao seu lado.       ³
//³* O tipo de Sinal "P" - Parenteses, imprimira valores de saldo³
//³  invertidos da condicao normal da conta entre parenteses.	  ³
//³* O tipo de Sinal "S" - Sinal, imprimira valores de saldo in- ³
//³  vertidos da condicao normal da conta com sinal - 			  ³
//³OBS: Se a conta for ANORMAL (I1_ESTOUR == "S"), os sinais se- ³
//³rao invertidos.															  ³
//³EXEMPLOS  -  EXEMPLOS  -  EXEMPLOS	-	EXEMPLOS  - EXEMPLOS   ³
//³Cond Normal 			Saldo 			 Default 		  Sinal				Parenteses					  ³
//³	  D			  -1000	  1000 D 		1000		1000				 ³
//³	D				 1000 	1000 C		-1000 	(1000)			  ³
//³	C				-1000 	1000 D		-1000 	(1000)			  ³
//³	C				 1000 	1000 C		 1000 	 1000 			  ³
//³CONTA "ANORMAL" ou "REDUTORA"                                 ³
//³Cond Normal 	Saldo 	Default		Sinal 	Parenteses		  ³
//³  D				-1000 		  1000 D 	  -1000	  (1000) 			 ³
//³  D				 1000 	1000 C		 1000 	 1000 			  ³
//³  C				-1000 	1000 D		 1000 	 1000 			  ³
//³  C				 1000 	1000 C		-1000 	(1000)			  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Neste caso (Default), nao importa a natureza da conta! Saldos³
//³ devedores serao impressos com "D" e credores com "C".        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// Neste caso, nao importa a natureza da conta!!
If cTipoSinal == "D"                                    //      DC (Default)
	If !lEstrang
		cPict := "@E " + cPicture
	Else
		cPict		:= cPicture
	EndIf
	@ nLin, nCol pSay Abs(nSaldo) Picture cPict
	nCol1 := nCol + Len(cPicture) + 1
	If lSinal
		If nSaldo < 0
			@ nLin, nCol1 pSay "D"
		ElseIf nSaldo > 0
			@ nLin, nCol1 pSay "C"
		EndIf
	EndIf
Else
	If SI1->I1_ESTOUR != "S"
		If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
			If (cTipoSinal) == "S"                  //      Sinal
				If lSinal
					nSaldo := nSaldo * (-1)
				Else
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E " + cPicture
				EndIf
				@ nLin, nCol PSAY nSaldo Picture cPicture
			ElseIf (cTipoSinal) == "P"              //      Parenteses
				If lSinal
					nSaldo := nSaldo * (-1) 		  // a Picture so exibe parenteses para numeros negativos
				Else
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E( " + cPicture
				Else
					cPicture := "@( " + cPicture
				EndIf
				@ nLin, nCol pSay nSaldo Picture cPicture
			EndIf
		ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
			If (cTipoSinal) == "S"                  //      Sinal
				If !lSinal
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E " + cPicture
				EndIf
				@ nLin, nCol PSAY nSaldo Picture cPicture
			ElseIf (cTipoSinal) == "P"              //      Parenteses
				If !lSinal
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E( " + cPicture
				Else
					cPicture := "@( " + cPicture
				EndIf
				@ nLin, nCol pSay nSaldo Picture cPicture
			EndIf
		EndIf
	ElseIf SI1->I1_ESTOUR == "S"                    // CONTA REDUTORA
		If cTipo == "D" .Or. SI1->I1_NORMAL == "D"                      // Conta Devedora
			If (cTipoSinal) == "S"                  //      Sinal
				If !lSinal
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E " + cPicture
				EndIf
				@ nLin, nCol PSAY nSaldo Picture cPicture
			ElseIf (cTipoSinal) == "P"              //      Parenteses
				If !lSinal
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E( " + cPicture
				Else
					cPicture := "@( " + cPicture
				EndIf
				@ nLin, nCol pSay nSaldo Picture cPicture
			EndIf
		ElseIf cTipo == "C" .Or. SI1->I1_NORMAL == "C"          // Conta Credora
			If (cTipoSinal) == "S"                  //      Sinal
				If lSinal
					nSaldo := nSaldo * (-1)
				Else
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E " + cPicture
				EndIf
				@ nLin, nCol PSAY nSaldo Picture cPicture
			ElseIf (cTipoSinal) == "P"              //      Parenteses
				If lSinal
					nSaldo := nSaldo * (-1)
				Else
					nSaldo := Abs(nSaldo)
				EndIf
				If !lEstrang
					cPicture := "@E( " + cPicture
				Else
					cPicture := "@( " + cPicture
				EndIf
				@ nLin, nCol pSay nSaldo Picture cPicture
			EndIf
		EndIf
	EndIf
EndIf

DbSelectArea("SI1")
DbGoTo(nReg)
DbSetOrder(nOrder)

DbSelectArea( cOldAlias )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o	  ³TmContab  ³ Autor ³ Pilar S. Albaladejo	³ Data ³ 23/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o ³ Retorna a picture a ser impressa e corta pontos se nao ti- ³±±
±±³			  ³ ver espaco 																³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ TmContab(cCampo,nTamanho,nDecimais)								³±±
±±³			  ³ Onde:																		³±±
±±³			  ³ cCampo	= Campo a ser impresso										³±±
±±³			  ³ nTamanho= Tamanho maximo disponivel para impressao			³±±
±±³			  ³ nDecimais = Numero de decimais a serem impressas				³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		  ³ SIGACON 																	³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TMContab(cCampo,nTamanho,nDecimais)

Local cCpo

nDecimais:= Iif(nDecimais==Nil,GetMv("MV_CENT"),nDecimais)

cDecimais:= Iif(nDecimais==0,"","."+Replicate("9",nDecimais))
cPicture := Iif(GetMv("MV_MILHAR"),"999,999,999,999,999",;
"999999999999999")+cDecimais
cCpo	:= Transform(cCampo,cPicture)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ VerIfica se ha tamanho suficiente para imprimir. Se nao 	  ³
//³ existir tamanho suficiente, serao cortados pontos e virgulas ³
//³ para caber.																  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
While  (Len(AllTrim(cCpo)) > nTamanho ) .And. ( AT(",",cPicture) > 0 )
	cPicture := Substr(cPicture,1,AT(",",cPicture)-1)+;
	Substr(cPicture,AT(",",cPicture)+1,20)
	cCpo	:= (Transform(cCampo,cPicture))
End

cPicture 		 :=		Right(cPicture,nTamanho)
cPicture 		 :=		Iif(Substr(cPicture,1,1)=',',"9"+Substr(cPicture,2),cPicture)
If Len(LTrim(cCpo)) > nTamanho
	cPicture 		 :=		"®"+Substr(cPicture,2,20)
EndIf

Return cPicture

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³fDesc 	³ Autor ³Mauro(1a. Versao)	    ³ Data ³14/10/1998³±±
±±³          ³      	³ Autor ³Marinaldo(2a.Versao)   ³ Data ³03/04/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Funcao para Trazer a Descricao/Conteudo de Campos			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³<Vide Parametros Formais >								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Gen‚rico 												  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDesc( cAlias , cChave , cCampoRet , nBytes , cFil , nOrder , lPosSx3 )

Local cAliasfDesc	:= ""
Local cFieldFil		:= ""
Local cContextFil	:= ""
Local lChkBytes		:= ( ValType( nBytes ) == "N" )
Local lChkOrder		:= ( ValType( nOrder ) == "N" )
Local lChkSX5		:= ( SubStr( cAlias , 1 , 1 ) == "X" )
Local lIsChar		:= .F.
Local lFound		:= .F.
Local nSvOrder		:= 1
Local nSx3Rec		:= 0
Local uRet			:= NIL

DEFAULT lPosSx3		:= .T.

IF ( lChkSX5 )
	cAliasfDesc := "SX5"
Else
	cAliasfDesc := cAlias
EndIF

cFieldFil	:= ( PrefixoCpo( cAliasfDesc ) + "_FILIAL" )
IF ( lPosSx3 )
	nSx3Rec		:= SX3->( Recno() )
EndIF
cContextFil	:= GetSx3Cache( cFieldFil , "X3_CONTEXT" )
IF ( lPosSx3 )
	SX3->( MsGoto( nSx3Rec ) )
EndIF
IF ( ( cContextFil <> NIL ) .and. !( cContextFil $ "Vv" ) )
	cFil := xFilial( cAliasfDesc , cFil )
Else
	cFil := ""
EndIF

IF ( lChkOrder )
	nSvOrder := ( cAliasfDesc )->( IndexOrd() )
	( cAliasfDesc )->( dbSetOrder( nOrder ) )
EndIF

lFound	:= ( cAliasfDesc )->( MsSeek( cFil + cChave , .F. ) )
uRet 	:= ( cAliasfDesc )->( &( cCampoRet ) )
lIsChar	:= ( ValType( uRet ) == "C" )
IF ( ( lChkBytes ) .and. ( lIsChar ) )
	uRet := SubStr( uRet , 1 , nBytes )
ElseIF ( !( lFound ) .and. ( lIsChar ) )
			/*
			         10        20
			 12345678901234567890
			*/
	uRet := "                    "
EndIF

IF ( ( lChkOrder ) .and. !( nSvOrder == nOrder ) )
	( cAliasfDesc )->( dbSetOrder( nSvOrder ) )
EndIF

Return( uRet )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³CriaCtaSup³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 23/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gera a conta pai da conta atual									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function CriaCtaSup(cCodigo)

Local cCod
Local cAlias	 := Alias()
Local nOrder	 := IndexOrd()
Local nReg					:= Recno()
Local nCont     := 0

cCodigo						:= AllTrim(cCodigo)
DbSelectArea("SI1")
DbSetOrder(1)

For nCont := 1 to Len(cCodigo)
	cCod	  := Substr(cCodigo,1,Len(cCodigo)-nCont)
	cCod	:= cCod + Space(20-Len(cCod))
	If DbSeek(xFilial()+cCod,.f.)
		Exit
	EndIf
Next nCont

DbSelectArea(cAlias)
DbSetOrder(nOrder)
DbGoTo(nReg)
Return cCod

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GravaData³ Autor ³ Wagner Xavier 		  ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Determinado forma de grava‡„o para campo data.				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ GravaData(ExpD1,ExpL1,ExpN1)										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpD1 := Data a ser convertida									  ³±±
±±³			 ³ ExpL1 := Tipo(Se .T. com Barra, se .F., sem Barra			  ³±±
±±³			 ³ ExpN1 := Formato (1,2,3)											  ³±±
±±³			 ³  Formato 1 := ddmmaa 												  ³±±
±±³			 ³ 			2 := mmddaa 												  ³±±
±±³			 ³ 			3 := aaddmm 												  ³±±
±±³			 ³ 			4 := aammdd 												  ³±±
±±³			 ³ 			5 := ddmmaaaa												  ³±±
±±³			 ³ 			6 := mmddaaaa												  ³±±
±±³			 ³ 			7 := aaaaddmm												  ³±±
±±³			 ³ 			8 := aaaammdd												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Fina150																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function GravaData( dData, lBarra, nFormato )

Local xData 	:= dData

dData   := Iif( dData==Nil,dDataBase,dData )
lBarra  := Iif( lBarra==Nil,.T.,lBarra )
nFormato:= Iif( nFormato==Nil,1,nFormato )
cSepar  := Iif( lBarra,"/","" )

If !lBarra
	Do Case
		Case nFormato == 1
			xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
		Case nFormato == 2
			xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+SubStr(StrZero(Year(dData),4),3,2)
		Case nFormato == 3
			xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
		Case nFormato == 4
			xData := SubStr(StrZero(Year(dData),4),3,2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
		Case nFormato == 5
			xData := StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Year(dData),4)
		Case nFormato == 6
			xData := StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Year(dData),4)
		Case nFormato == 7
			xData := StrZero(Year(dData),4)+cSepar+StrZero(Day(dData),2)+cSepar+StrZero(Month(dData),2)
		OtherWise
			xData := StrZero(Year(dData),4)+cSepar+StrZero(Month(dData),2)+cSepar+StrZero(Day(dData),2)
	EndCase
End
Return xData

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ChecErr260³ Autor ³ Wagner Xavier 		  ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina analizadora do erro											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³Sigafin Advanced.														  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ChecErr260(e,cForm)
If e:gencode > 0
	Help( " ",1,"ERR_FORM",,e:Description+" : "+Substr(cForm,1,20),3,1 )
	lRet:=.F.
EndIf
Break

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³Incrementa³ Autor ³ Wagner Xavier 		  ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Incrementa 1 a um determinado Numero 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³Incrementa(Numero) 													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Incrementa(cNum)
If PCOUNT()==0
	cNum:=StrZero(nSeq,6)
EndIf
Return 1+Val(cNum)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³TesImpInf ³ Autor ³ Bruno Sobieski		³ Data ³ 17.11.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna um array com os dados dos impostos relacionados com³±±
±±³			 ³ o tes que ‚ pasado como parametro. Usado para Impostos nas |±±
±±³			 ³ Localizacoes no Exterior.								  ³±±
±±³			 ³ aImpFlag[n][1]-> Codigo do Imposto						  ³±±
±±³			 ³ 		  [n][2]-> Campo no SD1 ou SD2 onde ‚ gravado o valor |±±
±±³			 ³ 					  imposto.								  ³±±
±±³			 ³ 		  [n][3]-> Se o valor do imposto incide na Nota 	  ³±±
±±³			 ³ 		  [n][4]-> Se o valor do imposto incide na Duplicata  ³±±
±±³			 ³ 		  [n][5]-> Se o valor do imposto deve ser Creditado   ³±±
±±³			 ³ 		  [n][6]-> Campo no SF1 ou SF2 onde ‚ gravado o valor |±±
±±³			 ³ 					  imposto.								  ³±±
±±³			 ³ 		  [n][7]-> Campo no SD1 ou SD2 onde ‚ gravada a base  |±±
±±³			 ³ 					  do imposto.							  ³±±
±±³			 ³ 		  [n][8]-> Campo no SF1 ou SF2 onde ‚ gravada a base  |±±
±±³			 ³ 					  do imposto.							  ³±±
±±³			 ³ 		  [n][9]-> Aliquota do imposto                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Parametro³ cTes -> Codigo de Entrada-Saida							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico Localizacoes.									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function TesImpInf(cTes)
Local aImpFlag :={}
Local aArea:=GetArea()
SFB->(DbSetOrder(1))
DbSelectArea("SFC")
DbSetOrder(1)
DbSeek(xFilial("SFC")+cTes)
While SFC->(!eof()) .and. xFilial("SFC")== FC_FILIAL .and. cTes== FC_TES
	If SFB->(DbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
		If (cTes<="500" )
			Aadd(aImpFlag,{SFB->FB_CODIGO,"D1_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F1_VALIMP"+SFB->FB_CPOLVRO,"D1_BASIMP"+SFB->FB_CPOLVRO,"F1_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D1_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
			If cPaisLoc == "ARG"
				Aadd(aImpFlag[Len(aImpFlag)],SFC->FC_LIQUIDO)
			EndIf
		Else
			Aadd(aImpFlag,{SFB->FB_CODIGO,"D2_VALIMP"+SFB->FB_CPOLVRO,SFC->FC_INCNOTA,SFC->FC_INCDUPL,SFC->FC_CREDITA,"F2_VALIMP"+SFB->FB_CPOLVRO,"D2_BASIMP"+SFB->FB_CPOLVRO,"F2_BASIMP"+SFB->FB_CPOLVRO,SFB->FB_ALIQ,"D2_ALQIMP"+SFB->FB_CPOLVRO,SFC->FC_PROV,SFC->FC_INCIMP})
			If cPaisLoc == "PTG"
				Aadd(aImpFlag[Len(aImpFlag)],SFC->FC_ABATCOM)
			EndIf
			If cPaisLoc == "ARG"
				Aadd(aImpFlag[Len(aImpFlag)],SFC->FC_LIQUIDO)
			EndIf
		EndIf
	EndIf
	SFC->(DbSkip())
End
RestArea(aArea)
Return(aImpFlag)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o		  ³AutoGrLog ³ Autor ³ Sandro 					³ Data ³ 12/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava o Log com a descricao do HELP.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ AutoGrLog [ cExpr ] )												³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpC1 - Texto a ser gravado no arquivo.						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AutoGRLog(cLogErro)
DEFAULT __cFileLog := CriaTrab(,.f.)+".LOG"

If ( Type("lMSErroAuto") == "L" )
	lMSErroAuto := .T.
EndIf

If ( Type( 'lAutoErrNoFile' ) == 'L' ) .And. ( lAutoErrNoFile )
    Aadd( __aErrAuto, cLogErro )
	Return
EndIf

If ! File(__cFileLog)
	If (nHandle2 := MSFCreate(__cFileLog,0)) == -1
		Return
	EndIf
Else
	If (nHandle2 := FOpen(__cFileLog,2)) == -1
		Return
	EndIf
EndIf
FSeek(nHandle2,0,2)
FWrite(nHandle2,cLogErro+chr(13)+chr(10))
FClose(nHandle2)
Return

Function GetAutoGRLog ( )
Local aTemp := AClone( __aErrAuto )
__aErrAuto := {}
Return( aTemp )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³NomeAutoLog ³ Autor ³ Sandro 		  		  ³ Data ³ 21/07/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna no nome do arq. de erro automatico  			   	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ NomeAutoLog()        											     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
__cFileLog e'uma variavel estatica
*/
Function NomeAutoLog()
Return __cFileLog

//-------------------------------------------------------------------
/*/{Protheus.doc} VarAutoLog
Devolve valor da variavel __aErrAuto, quando parametro
lAutoErrNoFile = .T.
@author  Thiago.zoppi
@since   10/05/2019
/*/
//-------------------------------------------------------------------
Function VarAutoLog()
Return __aErrAuto

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ FormBatch³ Autor ³ Juan Jose Pereira	  ³ Data ³ 04/12/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta tela generica para processo batch						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FormBatch( cTitle, aSays, aButtons, lOk, bValid )			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ cTitle = Titulo da janela											  ³±±
±±³			 ³ aSays  = Array com Says 											  ³±±
±±³			 ³ aButtons = Array com bottoes										  ³±±
±±³			 ³ aButtons[i,1] = Tipo de botao 									  ³±±
±±³			 ³ aButtons[i,2] = Tipo de enabled									  ³±±
±±³			 ³ aButtons[i,3] = bAction 											  ³±±
±±³			 ³ bValid = Bloco de validacao do Form 							  ³±±
±±³			 ³ nAltura= Altura do Form em Pixel (Default 250)				  ³±±
±±³			 ³ nLargura = Largura do Form em Pixel (Default 520)			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
#DEFINE LARGURA_DO_SBUTTON 32

Function FormBatch( cTitle, aSays, aButtons, bValid, nAltura, nLargura )

Local nButtons:= Len(aButtons),;
nSays:= Len(aSays),;
oSay,;
i,nTop, nType, lEnabled, oFormPai, oFont,;
nLarguraBox, nAlturaBox, nLarguraSay, cTextSay, oBtn, cCaption

DEFAULT aSays:={}, aButtons:={}
DEFAULT nAltura:= 250, nLargura:= 520

// Numero maximo de linhas //
If( nSays>7 )
	nSays:=7
EndIf

// Numero maximo de botoes //
If( nButtons>5 )
	nButtons:= 5
EndIf

oFormPai:= Atail(aFormBatch)
If( oFormPai==NIL )
	oFormPai:= oMainWnd
EndIf

DEFINE FONT oFont NAME "Arial" SIZE 0, -11

DEFINE MSDIALOG oDlg TITLE cTitle FROM 0,0 TO nAltura,nLargura OF oFormPai PIXEL

AADD(aFormBatch,oDlg)

nAlturaBox:= (nAltura-60)/2
nLarguraBox:= (nLargura-20)/2
@ 10,10 TO nAlturaBox,nLarguraBox OF oDlg PIXEL

//======================================================//
// monta says (bof)												 //
//======================================================//
nTop:=20

nLarguraSay:= nLarguraBox-30
for i:=1 to nSays
	cTextSay:= "{||'"+aSays[i]+"'}"
	oSay := TSay():New( nTop, 20, MontaBlock(cTextSay),oDlg,, oFont, .F., .F., .F., .T.,,, nLarguraSay, 10, .F., .F., .F., .F., .F. )
	nTop+= 10
next
//======================================================//
// monta says (eof)												 //
//======================================================//

//======================================================//
// monta bottoes(bof) 											 //
//======================================================//
nPosIni:= ((nLargura-20)/2) - (nButtons* LARGURA_DO_SBUTTON )
nAlturaButton:= nAlturaBox+10

for i:=1 to nButtons
	nType:= aButtons[i,1]
	If nType == 5
		cCaption := STR0105 //"Param."
	Else
		cCaption := ""
	EndIf
	lEnabled:= aButtons[i,2]

	DEFAULT lEnabled:= .T.

	If lEnabled
		oBtn := SButton():New( nAlturaButton, nPosIni, nType,aButtons[i,3],oDlg,.T.,,)
	Else
		oBtn := SButton():New( nAlturaButton, nPosIni, nType,,oDlg,.F.,,)
	EndIf
	If !Empty(cCaption)
		oBtn:cCaption := cCaption
	EndIf

	nPosIni+= LARGURA_DO_SBUTTON
next
//======================================================//
// monta bottoes(bof) 											 //
//======================================================//
oDlg:Activate( ,,,.T.,bValid,,,, )

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³FechaBatch³ Autor ³ Juan Jose Pereira	  ³ Data ³ 04/12/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fecha Ultima tela de batch 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ FechaBatch()															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FechaBatch()

Local oDlg:= Atail( aFormBatch )

oDlg:End()

ASize( aFormBatch,Len(aFormBatch)-1 )

Return nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³GetFormBatch³ Autor ³ Juan Jose Pereira   ³ Data ³ 04/12/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna um Form de Batch aberto									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³oDlg:= GetFormBatch(nDialog), se nDialog==0 retorna o ultimo³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetFormBatch(nDialog)

Local oRet:= NIL

If( nDialog==0 )
	oRet:= Atail(aFormBatch)
Else
	If( nDialog>0 .and. nDialog<=Len(aFormBatch) )
		oRet:= aFormBatch[nDialog]
	EndIf
EndIf
Return oRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsExectAuto ³ Autor ³Alex Sandro Valario  ³ Data ³ 03/02/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Execute rotina de  manutencao automatica	     			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ bRotina = Bloco de codigo com a chamada da rotina          ³±±
±±³			 ³ uPar1 ... Uparn = paramentos de cada rotina                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Exemplo
MSExecAuto({|x| mata010(x)},acab)
MSExecAuto({|x,y| mata140(x,y)},aCab,aItens)
*/

Function MSExecAuto(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10,uPar11,uPar12,uPar13,uPar14,uPar15)
LOCAL   ElMsHelpAuto
LOCAL	EaTela
LOCAL	EaGets
LOCAL	EaHeader
LOCAL	EaCols
LOCAL	EaRotAuto
LOCAL	EInclui
LOCAL	EAltera
LOCAL	En
LOCAL	E__cInternet
LOCAL   E__READVAR
Local ElMsFinalAuto

If ( Type('lMsFinalAuto') == 'U' )
	Private lMsFinalAuto := .T.
EndIf

ElMsFinalAuto := lMsFinalAuto
lMsFinalAuto  := .T.

If Type("lMsHelpAuto") == "U"
   Private lMsHelpAuto   := .t.
else
    ElMsHelpAuto :=lMsHelpAuto
EndIf
If Type("aTELA") <> "U"
	EaTela := aClone(aTELA)
EndIf
If Type("aGETS") <> "U"
	EaGets := aClone(aGETS)
EndIf
If Type("aHeader") <> "U"
	EaHeader := aClone(aHeader)
EndIf
If Type("aCols")  <> "U"
	EaCols := aClone(aCols)
EndIf
If Type("aRotAuto") <> "U"
	EaRotAuto := aClone(aRotAuto)
EndIf
If Type("Inclui") <> "U"
	EInclui := Inclui
EndIf
If Type("Altera") <> "U"
	EAltera := Altera
EndIf
If Type("n") <> "U"
	En := n
EndIf
If Type("__cInterNet") <> "U"
	E__cInternet := __cInterNet
EndIf

If Type("__READVAR") <> "U"
	E__READVAR := __READVAR
EndIf


__cInterNet := "AUTOMATICO"

eval(bRotina,uPar1,uPar2,uPar3,uPar4,uPar5,uPar6,uPar7,uPar8,uPar9,uPar10,uPar11,uPar12,uPar13,uPar14,uPar15)

lMsHelpAuto := ElMsHelpAuto
lMsFinalAuto:= ElMsFinalAuto
aTELA       := EaTela
aGETS       := EaGets
aHeader     := EaHeader
aCols  		:= EaCols
aRotAuto    := EaRotAuto
Inclui		:= EInclui
Altera		:= EAltera
n			:= En
__cInterNet := E__cInternet
__READVAR   := E__READVAR
Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsRotAuto ³ Autor ³ Alex Sandro Valario   ³ Data ³ 18/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Rotina de manutencao automatica									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ nOpcAuto = Numero de opcao da manutencao (3=inclusao) 	  ³±±
±±³			 ³ xRotAuto = array contEndo linhas para inclusao				  ³±±
±±³			 ³ sAlias	= Alias														  ³±±
±±³			 ³ uFunCpo  = Campos a serem editados 								  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsRotAuto(nOpcAuto,xRotAuto,sAlias,uFunCpo)
Local nCnt0,nCnt1, nCnt2, bBlock, aFuncoes,nOrderSX3,nPos
Local AutoReadVar, lObrigat ,cConteudo,uVar,cErro
Local lInit := .f.
Local cAlias

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Parametro utilizado para validar campos obrigatorios      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lVldObrig := SuperGetMv("MV_VLDOBRI",.F.,.F.)

Private N := 0
Private aTELA[0][0],aGETS[0]
Private aHeader:={},aCols:={}
Private aRotAuto

nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
If type("INCLUI")# "L"
   _SetOwnerPrvt("inclui",nOpcAuto==3)
EndIf
If type("ALTERA")# "L"
   _SetOwnerPrvt("altera",nOpcAuto==4)
EndIf


If Type("lMSErroAuto") == "U"
	Private lMSErroAuto := .F.
EndIf
If Type("lMsHelpAuto") == "U"
	Private lMsHelpAuto := .t.
EndIf
cAlias := sAlias

aRotAuto := (cAlias)->(MSArrayXDB(xRotAuto,.T.,nOpcAuto,,uFunCpo))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ se funcao retornar vetor com 0 signIfica que gerou arquivo de log ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !( Len(aRotAuto) > 0 )
	Return .t.
EndIf

If  aRotAuto # NIL
	nOrderSX3:= SX3->(IndexOrd())
	SX3->(DbSetOrder(2))
	For nCnt1 := 1 To Len( aRotAuto )
		If ( aRotAuto[nCnt1,1] = "AUT" )
			Loop
		EndIf
		AutoReadVar  := "M->" + Upper( aRotAuto[nCnt1,1 ] )
		&AutoReadVar := aRotAuto[nCnt1,2 ]
		If aRotAuto[nCnt1,3 ] == NIL
			SX3->(DbSeek( aRotAuto[nCnt1,1 ] ))
			If SX3->(Found()) .And. !Empty(SX3->X3_VALID )
				aRotAuto[nCnt1,3 ] := Upper(AllTrim( SX3->X3_VALID ))
			EndIf
		EndIf
		If ( Empty(aRotAuto[nCnt1,3 ]) )
			aRotAuto[nCnt1,3 ] := ".t."
		EndIf
	Next

	For nCnt1 := 1 To Len( aRotAuto )
      If ( aRotAuto[nCnt1,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
			Loop
		EndIf
		AutoReadVar := "M->" + Upper( aRotAuto[ nCnt1,1 ] )
		If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. Empty(aRotAuto[ nCnt1,2])
			lInit := .f.
			If ExistIni(Subs(AutoReadVar,4))
				lInit := .t.
				&AutoReadVar := InitPad(SX3->X3_RELACAO)
				If ValType(&AutoReadVar) = "C"
					&AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
				EndIf
				If &AutoReadVar == NIL .or. Empty(aRotAuto[ nCnt1,2])
					lInit := .f.
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Manter a variavel de memoria caso uma validacao as atualize e nao tenha   ³
			//³sido mensionada no arquivo texto, somente no caso de inclusao             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(aRotAuto[ nCnt1,2]) .and. !Empty(&AutoReadVar) .and. nOpcAuto == 3
				lInit := .T.
			EndIf
			If !lInit
				&AutoReadVar := aRotAuto[ nCnt1,2 ]
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for alteracao e alguma validacao atualizar a variavel e a mesma³
		//³nao for um campo que foi passado no array, respeitar a alteracao  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nOpcAuto == 4 .and. !aRotAuto[ nCnt1,4 ] .and. (&AutoReadVar != aRotAuto[ nCnt1,2])
			aRotAuto[ nCnt1,2 ] := &AutoReadVar
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso alguma validacao atualize a variavel manter o que foi passado³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( &AutoReadVar != aRotAuto[ nCnt1,2] .and. !Empty(aRotAuto[ nCnt1,2]) )
			&AutoReadVar := aRotAuto[ nCnt1,2 ]
		EndIf
		__READVAR := Upper(AllTrim(AutoReadVar))
		If !( aRotAuto[ nCnt1,3 ] == NIL )
			SX3->(DbSetOrder(2))
			SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
			lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
			If (lObrigat .or. ! Empty(&AutoReadVar))
				bBlock := &( "{ || " + AllTrim( aRotAuto[nCnt1,3 ] ) + " }" )
				If SX3->X3_VISUAL # "V"
					If ! Eval( bBlock ) .Or.  IIf(lVldObrig, lObrigat .And. Empty(aRotAuto[ nCnt1,2 ]),.F.)
						AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
						SX3->(DbSetOrder(2))
						For nCnt2 := 1 To Len(aRotAuto)
							uVar := aRotAuto[nCnt2,2]
							If 	 (ValType(uVar) == "C")
								cConteudo := uVar
							ElseIf (ValType(uVar) == "N")
								cConteudo := Str(uVar)
							ElseIf (ValType(uVar) == "D")
								cConteudo := DtoC(uVar)
							ElseIf (ValType(uVar) == "L")
								cConteudo := If(uVar,"True","False")
							ElseIf (ValType(uVar) == "M")
								cConteudo := "Memo"
							ElseIf (ValType(uVar) == "U")
								cConteudo := "Nil"
							EndIf
							If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
								cErro := " < -- Invalido"
							Else
								cErro := ""
							EndIf
							SX3->(DbSeek(Trim(aRotAuto[nCnt2,1])))
							AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
						Next
						AutoGRLog(Repl("-",80))
						SX3->(DbSetOrder(nOrderSX3))
						lMsHelpAuto := .F.
						Return .t.
					EndIf
					SX3->(DbSetOrder(2))
 					SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
					If SX3->(X3_TRIGGER) == "S"
						RunTrigger(1)
					EndIf
				EndIf
			EndIf
			If ( lMSErroAuto )
				AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
				For nCnt2 := 1 To Len(aRotAuto)
					uVar := aRotAuto[nCnt2,2]
					If     (ValType(uVar) == "C")
						 cConteudo := uVar
					ElseIf (ValType(uVar) == "N")
						 cConteudo := Str(uVar)
					ElseIf (ValType(uVar) == "D")
						 cConteudo := DtoC(uVar)
					ElseIf (ValType(uVar) == "L")
						 cConteudo := If(uVar,"True","False")
					ElseIf (ValType(uVar) == "M")
						 cConteudo := "Memo"
					ElseIf (ValType(uVar) == "U")
						 cConteudo := "Nil"
					EndIf
					If (Padr(aRotAuto[nCnt2,1],12) == Padr(Subs(AutoReadVar,4),12))
						cErro := " < -- Invalido"
					Else
						cErro := ""
				EndIf
					AutoGRLog(Padr(aRotAuto[nCnt2,1],12)+":="+cConteudo+cErro)
				Next
				AutoGRLog(Repl("-",80))
				SX3->(DbSetOrder(nOrderSX3))
				lMsHelpAuto := .F.
				Return .t.
			EndIf
		EndIf
	Next
	nPos := Ascan(aRotina,{|x| x[4]== nOpcAuto})
	If ( nPos # 0 )
		dbSelectArea(cAlias)
		bBlock := &( "{ |x,y,z,k| " + aRotina[ nPos,2 ] + "(x,y,z,k) }" )  // { |x,y,z| A240Inclui(x,y,z) }
      Eval( bBlock, cAlias, (cAlias)->(Recno()),nOpcAuto)
		lMsHelpAuto := .F.
		SX3->(DbSetOrder(nOrderSX3))
		Return .t.
	EndIf
	SX3->(DbSetOrder(nOrderSX3))
EndIf
lMsHelpAuto := .F.
Return .f.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³AxIncluiAuto³ Autor ³ Alex Sandro Valario ³ Data ³ 19/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Incluisao automatica 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ cAlias     = Nome do alias                                 ³±±
±±³          ³ cTudoOk    = Nome da Funcao TudoOk                         ³±±
±±³          ³ nOpcaoAuto = Numero da aRotina                             ³±±
±±³          ³ nLinha     = Linha que esta o registro correto             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AxIncluiAuto(cAlias,cTudoOk,cTransact,nOpcaoAuto,nlinha)
Local i
Local lAppEnd
nOpcaoAuto := If (nOpcaoAuto == Nil,3,nOpcaoAuto)

If !( nOpcaoAuto == 3 )
	(cAlias)->(DbGoTo(nLinha))
EndIf

bCampo := {|nCPO| Field(nCPO) }

If cTudoOk != NIL
	If ! &cTudoOk
		AutoGRLog("Tabela "+cAlias+" "+Dtoc(MsDate())+' '+Time() )
		AutoGRLog("Processo invalido")
		AutoGRLog(Replicate("-",80))
		Return 3
	EndIf
EndIf

Begin Transaction
lAppEnd := If (nOpcaoAuto == 3,.t.,.f.)
RecLock(cAlias,lAppEnd)
For i := 1 TO FCount()
	If "_FILIAL"$Field(i)
		FieldPut(i,xFilial(cAlias))
	Else
		FieldPut(i,M->&(Eval(bCampo,i)))
	EndIf
Next i
If cTransact != Nil
	cTransact += Iif("("$cTransact,"","()")
	lX := &cTransact
EndIf
End Transaction
Return 1

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MSArrayXDB  ³ Autor ³ Alex Sandro Valario ³ Data ³ 14/10/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna Array espelhando na Tabela SX3 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aVetor1  = Array contEndo informacoes do arquivo Texto      ³±±
±±³          ³lVirtual = Se estiver .T. retornara Array espelhado no SX3  ³±±
±±³          ³nOpcAuto = Numero da operacao a ser executada               ³±±
±±³          ³lItens   = .T. indica que as validacoes sera feira para     ³±±
±±³          ³           itens e se nao encontrar o registro acrescemta no³±±
±±³          ³           aVetor1 este parametro eh para casos de alteracao³±±
±±³          ³cFuncArray = Contera funcao de montagem do Array para os cam³±±±
±±³          ³             pos que forem validados                        ³±±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsArrayXDB(aVetor1,lVirtual,nOpcAuto,lItens,cFuncArray)
Local nX,nAchoFilial:=0
Local ac:={}
Local nOrderSX3
Local nPosTemp
Local cAlias := upper(Alias())
Local uConteudo := NIL
Local cValid := ""
Local nConta, nPosicao
Local aConteudo := {}
Local cMontaSeek := "", cPosiciona:= xFilial(Alias())
Local aArea := {}, aChave := {}
Local cOrdemSIX, cOriSIX, cString, cPalavra := ""
Local lIndex := .f. //Verifica se tem que montar procura por campos informados
Local cVerifica := "", aCpos := {}
Local lachou := .T.
lItens := If (lItens == Nil,.F.,lItens)

nOpcAuto := if(nOpcAuto==NIL,3,nOpcAuto)
If type("INCLUI")# "L"
   _SetOwnerPrvt("inclui",nOpcAuto==3)
EndIf
If type("ALTERA")# "L"
   _SetOwnerPrvt("altera",nOpcAuto==4)
EndIf

For nX := 1 To Len(aVetor1)
	If ( aVetor1[nX,3] <> NIL .and. subs(aVetor1[nX,3],1,1) == "#" )
		lIndex := .T.
		Exit
	EndIf
Next
nOrderSX3:= SX3->(IndexOrd())
SX3->(DbSetOrder(1))
SX3->(DbSeek(cAlias))

If ( Upper(Alltrim(aVetor1[Len(aVetor1),1])) != "INDEX" )
	aadd(aVetor1,{"INDEX",1})
EndIf

// Aceita passagem de filial para manutencao de registros
If (nAchoFilial:=Ascan(aVetor1,{|x| "_FILIAL" $ Upper(AllTrim(x[1]))})) > 0
	cMontaSeek:=aVetor1[nAchoFilial,2]
	If ValType(cMontaSeek) # "C"
		cMontaSeek:=xFilial(cAlias)
	EndIf
Else
	cMontaSeek:=xFilial(cAlias)
EndIf

cOrdemSIX  := AllTrim(Str(aVetor1[Len(aVetor1),2]))
cOriSIX    := cOrdemSIX
cOrdemSIX  := RetAsc(cOrdemSIX,1,.T.)
aDel(aVetor1,Len(aVetor1))
aSize(aVetor1,Len(aVetor1)-1)
aArea := GetArea()
dbSelectArea("SIX") //Localiza no Sindex
If dbSeek(cAlias+cOrdemSIX)
	cString := AllTrim(CHAVE)+"+"
								 //À> para conseguir adicionar o ultimo campo
	For nX := 1 to   Len(cString)
		If ( subs(cString,nX,1) != "+" )
			cPalavra := cPalavra + subs(cString,nX,1)
		Elseif (Subs(cPalavra,Len(PrefixoCpo(cAlias)) + 1) == "_FILIAL")	//Prefixo correto de qualquer tabela, e não somentes as Iniciadas em S.
			cPalavra := ""
		Else
		   If Left(cPalavra,5)=="DTOS("
		      cPalavra:= Subs(cPalavra,6)
			   cPalavra:= StrTran(cPalavra,")","")
		   EndIf
			nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(cPalavra)})
			If nPosicao > 0
				If lIndex .and. aVetor1[nPosicao,3] <> nil .and. subs(aVetor1[nPosicao,3],1,1) == "#"
					aadd(aChave,cPalavra)
					cPalavra := ""
					If Len(aVetor1[nPosicao,3]) > 1
						If Empty(cVerifica)
							cVerifica := "AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
						Else
							cVerifica := cVerifica +" .AND. AllTrim("+subs(aVetor1[nPosicao,3],2) +") == '"+AllTrim(aVetor1[nPosicao,2])+"'"
						EndIF
						aVetor1[nPosicao,3] := Nil
						cPosiciona := cPosiciona + aVetor1[nPosicao,2]
					Else
						aVetor1[nPosicao,3] := Nil
					EndIf
				Elseif !lIndex
					aadd(aChave,cPalavra)
					cPalavra := ""
				Else
					exit
				EndIf
			Else
				exit
			EndIf
		EndIf
	End
Else
	AutoGRLog(Dtoc(MsDate())+' '+Time() )
	AutoGRLog("Nao encontrado o indice "+cAlias+" do alias "+cOrdemSIX)
	AutoGRLog(Repl("-",80))
EndIf
RestArea(aArea)

lVirtual := If (lVirtual == Nil,.T.,lVirtual)
nOpcAuto := If (nOpcAuto == Nil,3,nOpcAuto)

//ÚÄÄAÄTÄEÄNÄCÄAÄOÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³A variavel cVerifica deve estar vazia somente se for alteracao  ³
//³de cabecalho e itens na mesma tabela. Ex.: SC1 (Solic. de Venda ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cVerifica)
	cVerifica := ".T."
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for exclusao ou alteracao primeiro posicionar o registro   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nOpcAuto == 4 ) .or. ( nOpcAuto == 5 )
	For nConta := 1 To Len(aChave)
		nPosicao := Ascan(aVetor1,{|x| AllTrim(x[1]) == AllTrim(achave[nconta])})
		If ( nPosicao > 0 )
			cMontaSeek := cMontaSeek + If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2])
			aadd(aConteudo,If(ValType(aVetor1[nPosicao,2])=="D",Dtos(aVetor1[nPosicao,2]),aVetor1[nPosicao,2]))
		EndIf
	Next
	If ( ValType(cOriSIX) == "C" )
		nIndAnt := IndexOrd()
		dbsetOrder(val(cOriSIX))
	EndIf
	If !(DbSeek(cMontaSeek))
		lachou := .F.
		If !lItens .or. !&cVerifica
			AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
			For nConta := 1 To Len(aConteudo)
				AutoGRLog(aChave[nConta]+" := "+aConteudo[nConta])
			Next
			AutoGRLog("Pesquisa nao encontrada com dados acima")
			AutoGRLog(Repl("-",80))
			Return aC := {}
		EndIf
		//A variavel cPosiciona esta os dados para procura somente dos
		//campos principais (que passaram validacao no array)
		If lItens .and. lIndex
			DbSeek(cPosiciona)
		EndIf
	EndIf
	If ( ValType(cOriSIX) == "C" )
		dbsetOrder(nIndAnt)
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se deverah validar os campos, somente nos que foram passado ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( cFuncArray <> Nil )
	aCpos := If (valType(cFuncArray) == "A",aClone(cFuncArray),&cFuncArray)
EndIf
For nX := 1 To Len(aVetor1)
	If ( Upper(subs(aVetor1[nX,1],1,3)) == "AUT" )
		If Len(aVetor1[nX]) >= 4
			aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3],aVetor1[nX,4]})
		Else
			aadd(aC,{aVetor1[nX,1],aVetor1[nX,2],aVetor1[nX,3]})
		EndIf
	EndIf
Next
While ( ! Sx3->(eof()) .and. Sx3->X3_ARQUIVO == cAlias )
	If ( lVirtual ) .and. (SX3->X3_CONTEXT == "V") .and. nOpcAuto <> 4
		Sx3->(DbSkip())
		Loop
	EndIf
	If 	 ( SX3->X3_TIPO == "C" )
		uConteudo := Space(Sx3->X3_TAMANHO)
	ElseIf ( SX3->X3_TIPO == "D" )
		uConteudo := CToD("")
	ElseIf ( SX3->X3_TIPO == "N" )
		uConteudo := 0
   Elseif ( SX3->X3_TIPO == "L" )
  	   uConteudo := .F.
	Else
		uConteudo := ""
	EndIf
	nPosTemp := Ascan(aVetor1,{|x| AllTrim(Upper(x[1])) == AllTrim(SX3->X3_CAMPO)})
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³se for inclusao validar todos                            ³
	//³se for alteracao validar somente o que pode ser alterado ³
	//³se for exclusao nao validar nenhum                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (nOpcAuto == 3)
		If Empty(aCpos)
			cValid := Upper(AllTrim( SX3->X3_VALID ))
		Else
			cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
		EndIf
	Elseif nOpcAuto == 4
		If ( nPosTemp # 0 )
			If Empty(aCpos)
				cValid := If(!("x" $ SX3->(Substr(FirstBitOff(If(MPDicInDB(), SX3->X3_USADO, Bin2Str(x3_usado))),101,1))),Upper(AllTrim( SX3->X3_VALID )),"")
			Else
				cValid := If ( Ascan(aCpos,{|x|x == Alltrim(SX3->X3_CAMPO)}) > 0,Upper(AllTrim( SX3->X3_VALID )),"")
			EndIf
		Else
		   	cValid := ""
		EndIf
	else
		cValid := ""
	EndIf

	If ( nPosTemp # 0 )
		uConteudo := aVetor1[nPosTemp,2]
		If (aVetor1[nPosTemp,3] # NIL  )
			cValid	  := aVetor1[nPosTemp,3]
		EndIf
	Elseif (nOpcAuto == 4) .and. (!lItens .or. lachou) // se for cabecalho ou se tiver sucesso na pesquida
		If fieldpos(AllTrim(SX3->X3_CAMPO)) > 0
			uConteudo := FieldGet(fieldpos(AllTrim(SX3->X3_CAMPO)))
		EndIf
	EndIf
	If ( Empty(cValid) )
		cValid := ".t."
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se uConteudo for do tipo caracter entao colocar a variavel do tamanho do campo do SX3³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Valtype(uConteudo) == "C"
		IF SX3->X3_TIPO != "M"
			uConteudo := PadR(uConteudo,Sx3->X3_TAMANHO)
		EndIf
	EndIf
	If nPosTemp # 0
		aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.T.})
	Else
		aadd(aC,{SX3->X3_CAMPO,uConteudo,cValid,.F.})
	EndIf

	Sx3->(DbSkip())
End
SX3->(DbSetOrder(nOrderSX3))
Return aC

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsVldGAuto³ Autor ³ Alex Sandro Valario   ³ Data ³14/10/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Valida os gets Automaticos											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ 																			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsVldGAuto(aValidGet)
Local nX
Local bBlock
Local lObrigat
Local lObriAuto
Local nOrderSX3

Private Inclui := If (Type("Inclui") # "L",.t.,Inclui)
Private Altera := If (Type("Altera") # "L",.f.,Altera)
If Type("lMSErroAuto") == "U"
	Private lMSErroAuto := .F.
EndIf
If Type("lMsHelpAuto") == "U"
	Private lMsHelpAuto := .t.
EndIf
If ( Empty(aValidGet))
	aValidGet := aClone(aAutoCab)
	For  nX := 1 To Len(aValidGet)
		aadd(aValidGet[nx],.f.)
	Next
EndIf

nOrderSX3:= SX3->(IndexOrd())
SX3->(DbSetOrder(2))
For nX := 1 to Len(aValidGet)
	If ( aValidGet[nX,1] = "AUT" ) //Variavel serah utilizada dentro dos programas
		Loop
	EndIf
	AutoReadVar  := "M->" +Upper(AllTrim(aValidGet[nX,1]))
//	If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
	If Type("&AutoReadVar")== "U" .or. Empty(&AutoReadVar) .or. ! Empty(aValidGet[nX,2])
		lInit := .f.
		If ExistIni(Subs(AutoReadVar,4))
			lInit := .t.
			&AutoReadVar := InitPad(SX3->X3_RELACAO)
			If ValType(&AutoReadVar) = "C"
				&AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
			EndIf
			If &AutoReadVar == NIL .or. !Empty(aValidGet[nX,2]) // aqui foi alterado
				lInit := .f.
			EndIf
		EndIf
		If !lInit
			&AutoReadVar := aValidGet[nX,2]
		EndIf
	EndIf
	If ( Empty(aValidGet[nX,2]) )
		aValidGet[nX,2] := &AutoReadVar
	EndIf
	If ( Empty(aValidGet[nx,3]) )
		aValidGet[nX,3] := " .t. "
	EndIf
	__READVAR := Upper(AllTrim(AutoReadVar))
	SX3->(DbSetOrder(2))
	IF SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
		lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
		lObriAuto:= aValidGet[nX,4]
		If (lObrigat .or. ! Empty(&AutoReadVar) .or. lObriAuto )
			bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
			If SX3->X3_VISUAL # "V"
				If ! Eval( bBlock )
					MsLogCab(aValidGet,AutoReadVar)
					lMsHelpAuto := .F.
					SX3->(DbSetOrder(nOrderSX3))
					Return .f.
				EndIf
				SX3->(DbSetOrder(2))
				SX3->(DbSeek(Upper(AllTrim(Subs(AutoReadVar,4)))))
				If SX3->(X3_TRIGGER) == "S"
					RunTrigger(1)
				EndIf
				If lMsErroAuto
					MsLogCab(aValidGet,AutoReadVar)
					lMsHelpAuto := .F.
					SX3->(DbSetOrder(nOrderSX3))
					Return .f.
				EndIf
			EndIf
		EndIf
	Else
		bBlock := &( "{ || " + AllTrim( aValidGet[nX,3 ] ) + " }" )
		If ! Eval( bBlock )
			MsLogCab(aValidGet,AutoReadVar)
			lMsHelpAuto := .F.
			SX3->(DbSetOrder(nOrderSX3))
			Return .f.
		EndIf
	EndIf
Next
SX3->(DbSetOrder(nOrderSX3))
Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsVldAcAuto³ Autor³ Alex Sandro Valario   ³ Data ³14/10/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³aValidGet = aCols                                           ³±±
±±³          ³cLinhaOk  = Dispara a funcao de Linha Ok                    ³±±
±±³          ³cTudoOk   = Dispara a funcao de Tudo Ok                     ³±±
±±³          ³cTmpAlias = Se estiver trabalhando com GetDb passar o alias ³±±
±±³          ³            do arquivo temporario                           ³±±
±±³          ³OpcAuto   = n da rotina a ser disparada, baseada no aRotina ³±±
±±³          ³cChaPes   = Se for alteracao com cabecalho e itens,passar a ³±±
±±³          ³            chave de pesquisa do acols. Ex: "??_ITEM"       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Valida os gets Automaticos (aCols)								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ 																			  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsVldAcAuto(aValidGet,cLinhaOk,cTudoOk,cTmpAlias,OpcAuto,cChaPes)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³  A variavel cTmpAlias so sera usada quando se estiver        ³
//³  trabalhando com a funcao MSGETDB                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Local nX,nY
Local bBlock
Local nPos
Local lObrigat
Local nOrderSX3
Local nP_aHeader, nP_aCols,nP_aAutoIt
Private Inclui := .t.
Private Altera := .f.
Private n
//esta variavel simula a cCampo da GetDados
Private cCampo
OpcAuto := If (OpcAuto == Nil,3,OpcAuto)
Private o
If Type("lMSErroAuto") == "U"
	Private lMSErroAuto := .F.
EndIf
If Type("lMsHelpAuto") == "U"
	Private lMsHelpAuto := .t.
EndIf
nOrderSX3:= SX3->(IndexOrd())
SX3->(DbSetOrder(2))
If GetMV('MV_VEICULO')=='S'
   MsCodVei()  // utilizado para codigos auxiliares
EndIf
If !( cTmpAlias == NIL )
	(cTmpAlias)->(dbGoTop())
EndIf
For nX := 1 to Len(aCols)
	If ( OpcAuto == 4 .and. ValType(cChaPes) == "C")
		If !( aAutoItens[nX,1,1] == nil )
			nP_aHeader := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
			nP_aAutoI  := ascan(aAutoItens[nX],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
			If ( aAutoItens[nX,nP_aAutoI,2]!=aCols[nX,nP_aHeader] )
				Loop
			EndIf
		Else
			Loop
		EndIf
	EndIf
	n:= nX
	If !( cTmpAlias == NIL )
		If ( OpcAuto != 4 )
			RecLock(cTmpAlias,.t.)
		Elseif (OpcAuto == 4 )
			RecLock(cTmpAlias,.F.)
		EndIf
	EndIf

	For nY := 1 to Len(aCols[nX])- 1
		// criar todas variaveis de memoria
		AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))
		&AutoReadVar := aCols[nX,nY]
		If !( cTmpAlias == NIL )
			(cTmpAlias)->(FieldPut(nY,aCols[nX,nY]))
		EndIf
	Next
	For nY := 1 to Len(aCols[nX])- 1
		nPos := Ascan(aAutoItens[nX],{|x| Alltrim(Upper(x[1])) == Alltrim(Upper(aHeader[nY,2]))})
      If nPos == 0
         Loop
      EndIf
		If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL ) .and. ! Empty(aAutoItens[nX,nPos,2])
			If ( ValType(aAutoItens[nX,nPos,2])=="C")
				aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
			Else
				aCols[nX,nY] := aAutoItens[nX,nPos,2]
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quando a tabela temporaria for atualizada em alguma validacao       ³
		//³atualizarah tambem o acols                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !( cTmpAlias == NIL )
			If Empty(aCols[nX,nY]) .and. !Empty((cTmpAlias)->(FieldGet(ny)))
				aCols[nX,nY] := (cTmpAlias)->(FieldGet(ny))
			EndIf
		EndIf

		AutoReadVar  := "M->"+Upper(AllTrim(aHeader[nY,2]))

		If &AutoReadVar== NIL .or. Empty(&AutoReadVar) .or. ! Empty(aCols[nX,nY])
			lInit := .f.
			If ExistIni(Subs(AutoReadVar,4))
				lInit := .t.
				&AutoReadVar := InitPad(SX3->X3_RELACAO)
				If ValType(&AutoReadVar) = "C"
					&AutoReadVar := PADR(&AutoReadVar,SX3->X3_TAMANHO)
				EndIf
				If &AutoReadVar == NIL	.or. !Empty(aCols[nX,nY])
					lInit := .f.
				EndIf
			EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Manter a variavel de memoria caso uma validacao as atualize e NAO tenha   ³
//³sido mensionada no arquivo texto                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
				lInit := .T.
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se o inicializador nao estiver ativo volta o valor do aCOLS para a variavel de³
			//³memoria, mas caso esteja ativo e nao tenha sido mencionado no arquivo texto   ³
			//³entao atualiza o aCOLS                                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lInit
				&AutoReadVar := aCols[nX,nY]
			ElseIf !aAutoItens[nX,nPos,4] .and. Empty(aCols[nX,nY]) .and. !Empty(&AutoReadVar)
				aCols[nX,nY] := &AutoReadVar
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso alguma validacao atualize a variavel manter o que foi passado³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( &AutoReadVar != aCols[nX,nY] .and. !Empty(aCols[nX,nY]) )
			&AutoReadVar := aCols[nX,nY]
		EndIf
		If 	 ( ValType(aCols[nX,nY]) =="C")
			&AutoReadVar := Padr(aCols[nX,nY],aHeader[nY,4] )
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Variaveis de sistema       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If OpcAuto <> 3
			cCampo    :=  aCols[nX,nY]
		Else
			cCampo    := CriaVar(aHeader[nY,2])
  		EndIf
		__READVAR := Upper(AllTrim(AutoReadVar))

		If !( cTmpAlias == NIL )
			(cTmpAlias)->(FieldPut(nY,&AutoReadVar))
		EndIf

		SX3->(DbSetOrder(2))
		SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
		lObrigat := x3uso(SX3->X3_USADO) .and. ((SubStr(BIN2STR(SX3->X3_OBRIGAT),1,1) == "x") .or. VerByte(SX3->x3_reserv,7))
		If (lObrigat .or. ! Empty(&AutoReadVar))
			bBlock := &( "{ || " + AllTrim( aHeader[ny,6 ] ) + " }" )
			If SX3->X3_VISUAL # "V"
				If ! Eval( bBlock )
					MsLogCab(aValidGet,AutoReadVar)
					MSLogItens(aHeader,aCols,AutoReadVar,n)
					lMsHelpAuto := .F.
					SX3->(DbSetOrder(nOrderSX3))
					Return .f.
				EndIf
				SX3->(DbSetOrder(2))
				SX3->(DbSeek(Upper(AllTrim(aHeader[nY,2]))))
				If SX3->(X3_TRIGGER) == "S"
					RunTrigger(2,nX)
				EndIf
				If lMsErroAuto
					MsLogCab(aValidGet,AutoReadVar)
					MSLogItens(aHeader,aCols,AutoReadVar,n)
					lMsHelpAuto := .F.
					SX3->(DbSetOrder(nOrderSX3))
					Return .f.
				EndIf
			EndIf
		EndIf
	Next
	If !( cTmpAlias == NIL )
		(cTmpAlias)->(MSUnLock())
	EndIf


	If !( cTmpAlias == Nil )
		(cTmpAlias)->(dbCommit())
	EndIf

	If cLinhaOk != NIL
		If ! &cLinhaOk
			MsLogCab(aValidGet,"Inconsistencia na Linha de Itens")
			MSLogItens(aHeader,aCols,"Inconsistencia na Linha de Itens",nX)
			lMsHelpAuto := .F.
			SX3->(DbSetOrder(nOrderSX3))
			Return .f.
		EndIf
	EndIf
Next
If cTudoOk != NIL
	If ! &cTudoOk
		MsLogCab(aValidGet,"Inconsistencia nos Itens")
		MSLogItens(aHeader,aCols,"Inconsistencia nos Itens ",n)
		lMsHelpAuto := .F.
		SX3->(DbSetOrder(nOrderSX3))
		Return .f.
	EndIf
EndIf
SX3->(DbSetOrder(nOrderSX3))
Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsAuto2aCols³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Atualiza aCols conforme aAutoItens						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nOpcao    = N§ da rotina a ser executada                    ³±±
±±³          ³TempAlias = Se for GetDb passar o Alias (temporario)        ³±±
±±³          ³cChaPes   = Se for alteracao com cabecalho e itens,passar a ³±±
±±³          ³            chave de pesquisa do acols. Ex: "??_ITEM"       ³±±
±±³          ³ExpL5: Indica se o aheader deve ser atualizado              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Rotina Automatica 										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsAuto2aCols(nOpcao,TempAlias,cChaPes,lChkIni,lAtuHead)
Local nX         := 0
Local nY         := 0
Local nR         := 0
Local nC         := 0
Local nPos       := 0
Local nRecPos    := 0
Local nPosicao   := 0
Local nPosDeleta := 0
Local nLenHead	 := 0
Local nH         := 0
Local aPosicao   := {}
Local aTempVetor := {}
Local nPosAliWT	:= Ascan(aHeader,{|x| UPPER(x[1]) == "ALIAS WT"})
Local nPosRecWT	:= Ascan(aHeader,{|x| UPPER(x[1]) == "RECNO WT"})

DEFAULT lChkIni  := .F.
DEFAULT lAtuHead := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Validacoes dos Parametros                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpcao    := If (nOpcao == NIL,3,nOpcao)
TempAlias := If (TempAlias == NIL,"",TempAlias)
cChaPes   := If (cChaPes == nil,"",cChaPes)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Determina tamanho do aHeader verificando se utiliza campos de WalkThru³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Ascan(aHeader,{|x| UPPER(x[1]) == "ALIAS WT"}) > 0
	nLenHead:= Len(aHeader)-2
Else
	nLenHead:= Len(aHeader)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Para os casos que estiverem usando o MSGETDB                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( Empty(aCols) )
	If ( nOpcao == 3 )
		aCols := Array(1,Len(aHeader))
		For nH := 1 To Len(aHeader)
			If ( aHeader[nH,8] == "C" )
				acols[1,nH] := Space(aHeader[nH,4])
			ElseIf ( aHeader[nH,8] == "N" )
				acols[1,nH] := 0
			ElseIf ( aHeader[nH,8] == "D" )
				acols[1,nH] := dDataBase
			ElseIf  aHeader[nH,8] == "M"
				acols[1,nH] := ""
			Else
				acols[1,nH] := .F.
			EndIf
		Next
		aadd(acols[1],.f.) //nH ja tera o numero total do aHeader + 1
	Else
		ntotLin := (TempAlias)->(RecCount())
		nTotCol := (TempAlias)->(fCount())
		aCols := Array(ntotLin,nTotCol)
		For nR := 1 To ntotLin
			RecLock(TempAlias,.F.)
			For nC := 1 To nTotCol
				nPosicao := Ascan(aAutoItens[1],{|x| AllTrim(x[1]) == AllTrim((TempAlias)->(FieldName(nC)))})
				If nPosicao > 0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Atualiza tabela temporaria da GetDB, somente se aAutoItens estiver com algum valor³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty(aAutoItens[nR,nPosicao,2])
						(TempAlias)->(FieldPut(nC,aAutoItens[nR,nPosicao,2]))
					EndIf
				aCols[nR,nC] := (TempAlias)->(FieldGet(nC))
				EndIf
			Next
			(TempAlias)->(MSUnLock())
			(TempAlias)->(DbSkip())
		Next
	EndIf
Else
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se for alteracao no caso de cabecalho e itens no mesmo arquivo³
//³somente atualizar o acols e sair da funcao                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nOpcao == 4 )
		For nR := 1 To Len(aHeader)
			If ( Empty(aHeader[nR,6]) )
				aHeader[nR,6] := ".t."
			EndIf
			nPos := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(aHeader[nR,2]))})
			If ( nPos > 0 )
				aAdd(aPosicao,nPos)
			EndIf
		Next
		nPos     := ascan(aAutoItens[1],{|x| Upper(Alltrim(x[1])) == Upper(Alltrim(cChaPes))})
		nPosicao := ascan(aHeader,{|x| Upper(Alltrim(x[2])) == Upper(Alltrim(cChaPes))})
		For nR := 1 To Len(aAutoItens)
			nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
         If ( nPos_aCols > 0 .and. AllTrim(aAutoItens[nR,nPos,2]) == AllTrim(aCols[nPos_aCols,nPosicao]))
				For nC := 1 To Len(aCols[nPos_aCols])-1
					If lChkIni
						If aAutoItens[nR,aPosicao[nC],4]
							aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
						EndIf
					Else
					   If nR <= len(aAutoItens) .and. nC <= len(aPosicao) //Sandro
						aCols[nPos_aCols,nC] := aAutoItens[nR,aPosicao[nC],2]
						EndIf
					EndIf
				Next
			Else
				aSize(aCols,Len(aCols)+1)
				aCols[len(aCols)] := {}
				For nC := 1 To nLenHead
					aAdd(aCols[len(aCols)],aAutoItens[nR,aPosicao[nC],2])
				Next
				If nPosAliWT > 0
					aAdd(aCols[len(aCols)],aHeader[nPosAliWT,9])
				EndIf
				If nPosRecWT > 0
					aAdd(aCols[len(aCols)],0)
				EndIf
				aAdd(aCols[len(aCols)],.f.)
				nPos_aCols := aScan(aCols,{|x| Upper(Alltrim(x[nPosicao])) == Upper(Alltrim(aAutoItens[nr,nPos,2]))})
			EndIf
			nPosDeleta := ascan(aAutoItens[nR],{|x| Upper(Alltrim(x[1])) == "AUTDELETA"})
			If ( nPosDeleta > 0 )
				aCols[nPos_aCols,nC] := (Upper(aAutoItens[nR,nPosDeleta,2]) == "S")
			EndIf
		Next
      aTempVetor := Array(Len(aCols),Len(aAutoItens[1]),Len(aAutoItens[1,1]))
		For nX := 1 To Len(aAutoItens)
			For nC := 1 To Len(aCols)
				If ( AllTrim(Upper(aCols[nC,nPosicao])) == AllTrim(Upper(aAutoItens[nX,nPos,2])))
					aCopy(aAutoItens[nX],aTempVetor[nC],1,Len(aAutoItens[nX]))
				EndIf
			Next
		Next
		aAutoItens := aClone(aTempVetor)
		Return
	EndIf
EndIf
// Atualizando os Valids do aHeader conforme array automatico esta vindo como parametros
For nX := 1 To Len(aHeader)
	nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nX,2]))})
	If !Empty(nPos) .And. aAutoItens[1,nPos,3] # NIL .And. lAtuHead
		aHeader[nX,6] := aAutoItens[1,nPos,3]
	EndIf
	If ( Empty(aHeader[nX,6]) )
		aHeader[nX,6] := ".t."
	EndIf
Next
If ( nOpcao == 3 )
	For nX := 1 To Len(aAutoItens)
		If ( nX > 1 )
			aadd(aCols,aClone(aCols[nX -1]))
			For nY := 1 to Len(aCols[nX])-1
				If 	 aHeader[nY,8] == "C"
					aCOLS[nX][nY] := SPACE(aHeader[nY,4])
				ElseIf aHeader[nY,8] == "N"
					aCOLS[nX][nY] := 0
				ElseIf aHeader[nY,8] =="D"
					aCOLS[nX][nY] := dDataBase
				ElseIf aHeader[nY,8] == "M"
					aCOLS[nX][nY] := ""
				Else
					aCOLS[nX][nY] := .F.
				EndIf
			Next
		EndIf
		For nY := 1 To (Len(aCols[1]) - 1)
			nPos := Ascan(aAutoItens[1],{|x| AllTrim(Upper(x[1])) == AllTrim(Upper(aHeader[nY,2]))})
			If ( ! Empty(nPos) ) .and. ( aAutoItens[nX,nPos,2] # NIL  )
				If ( ValType(aAutoItens[nX,nPos,2])=="C")
					aCols[nX,nY] := Padr(aAutoItens[nX,nPos,2],aHeader[nY,4] )
				Else
					aCols[nX,nY] := aAutoItens[nX,nPos,2]
				EndIf
			EndIf
		Next
	Next
EndIf
Return




/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsLogCab	  ³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava no log do Cab													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Rotina Automatica 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MsLogCab(aValidGet,AutoReadVar)
Local nX
Local cConteudo
Local uVar
Local uVar2
Local nT := 0
AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )

For nX := 1 To Len(aValidGet)
	uVar := aValidGet[nX,1]
	uVar2:= aValidGet[nX,2]
	If 	 (ValType(uVar2) == "C")
		cConteudo := uVar2
	ElseIf (ValType(uVar2) == "N")
		cConteudo := Str(uVar2)
	ElseIf (ValType(uVar2) == "D")
		cConteudo := DtoC(uVar2)
	ElseIf (ValType(uVar2) == "L")
		cConteudo := If(uVar2,"True","False")
	ElseIf (ValType(uVar2) == "M")
		cConteudo := "Memo"
	ElseIf (ValType(uVar2) == "U")
		cConteudo := "Nil"
	EndIf
	If (Padr(Upper(aValidGet[nX,1]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
		cErro := " < -- Invalido"
		nT := nT + 1
	Else
		cErro := ""
	EndIf
	SX3->(DbSeek(Trim(aValidGet[nX,1])))
	AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aValidGet[nX,1],12)+":="+cConteudo+cErro)
Next
If Empty(nT)
	AutoGRLog("Erro --> "+AutoReadVar)
EndIf
AutoGRLog(Repl("-",80))
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³MsLogItens  ³ Autor ³ Alex Sandro Valario ³ Data ³21/10/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava no log de Itens												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Rotina Automatica 													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSLogItens(aHeader,aCols,AutoReadVar,n)
Local cConteudo
Local uVar
Local nT := 0
Local nY := 0
AutoGRLog("Tabela "+Alias()+" "+Dtoc(MsDate())+' '+Time() )
AutoGRLog("Erro no Item "+str(n,3))
AutoGRLog(Repl("-",80))
For nY := 1 To Len(aCols[n]) -1
	uVar := aCols[n,nY]
	If 	 (aHeader[nY,8] == "C")
		cConteudo := uVar
	ElseIf (aHeader[nY,8] == "N")
		cConteudo := Str(uVar)
	ElseIf (aHeader[nY,8] == "D")
		cConteudo := DtoC(uVar)
	ElseIf (aHeader[nY,8] == "L")
		cConteudo := If(uVar,"True","False")
	ElseIf (aHeader[nY,8] == "M")
		cConteudo := "Memo"
	ElseIf (aHeader[nY,8] == "U")
		cConteudo := "Nil"
	EndIf
	If (Padr(Upper(aHeader[nY,2]),12) == Padr(Subs(Upper(AutoReadVar),4),12))
		cErro := " < -- Invalido"
		nT ++
	Else
		cErro := ""
	EndIf
	SX3->(DbSeek(Trim(aHeader[nY,2])))
	AutoGRLog(Padr(X3TITULO(),20)+'- '+Padr(aHeader[nY,2],12)+":="+cConteudo+cErro)
Next
If Empty(nT)
	AutoGRLog("Erro -->  "+AutoReadVar)
EndIf
AutoGRLog(Repl("-",80))
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MostraErroºAutor  ³Valdir/Sandro       º Data ³  12/07/00   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Mostra erros do processo automatico ********.log na Tela    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MostraErro(cPath,cNome)
Local oDlg
Local cMemo
Local cFile    :=""
Local cMask    := STR0043 //"Arquivos Texto (*.TXT) |*.txt|"
Local oFont
Local cStartPath := GetSrvProfString("Startpath","")

cPath := If(cPath = Nil, "", cPath)
cNome := If(cNome = Nil, __cFileLog, cNome)
DEFAULT __cFileLog := Criatrab(,.f.)+".LOG"
cMemo :=MemoRead(__cFileLog)

If Empty(cPath)
	DEFINE FONT oFont NAME "Courier New" SIZE 5,0   //6,15

	DEFINE MSDIALOG oDlg TITLE __cFileLog From 3,0 to 340,417 PIXEL

	@ 5,5 GET oMemo  VAR cMemo MEMO SIZE 200,145 OF oDlg PIXEL
	oMemo:bRClicked := {||AllwaysTrue()}
	oMemo:oFont:=oFont

	DEFINE SBUTTON  FROM 153,175 TYPE 1 ACTION oDlg:End() ENABLE OF oDlg PIXEL //Apaga
	DEFINE SBUTTON  FROM 153,145 TYPE 13 ACTION (cFile:=cGetFile(cMask,OemToAnsi(STR0044)),If(cFile="",.t.,MemoWrite(cFile,cMemo)),oDlg:End()) ENABLE OF oDlg PIXEL //Salva e Apaga //"Salvar Como..."
	DEFINE SBUTTON  FROM 153,115 TYPE 6 ACTION (PrintAErr(__cFileLog,cMemo),oDlg:End()) ENABLE OF oDlg PIXEL //Imprime e Apaga

	ACTIVATE MSDIALOG oDlg CENTER
Else
	ConOut(STR0046 + cNome)  //"Processo nao concluido. Verificar arquivo "
	Copy File (cStartPath + "\" + __cFileLog) To (cPath + "\" + cNome)
EndIf
Ferase(__cFileLog)
__cFileLog := Nil
Return(cMemo)

Static Function PrintAErr(cFileErro,cConteudo)//Imprime o autoerro.log
Local nLin := 0
Local nX   := 0
Default cConteudo := ""

	CursorWait()
	If IsTelnet() .Or. IsBlind()
		While !IsPrinter()
		    If !MsgRetryCancel(OemToAnsi(STR0045),OemToAnsi(STR0001)) //"Impressora n„o est  pronta."###"Aten‡„o"
			 	 Return .T.
			 Endif
		Enddo
		RptStatus({|lEnd| __CopyFile(cFileErro,"Lpt1")} )
	Else
		Private aReturn:= {STR0059, 1,STR0060, 1, 2, 1, "",1 }

		SetPrint(,cFileErro,nil ,STR0061,cFileErro,'','',.F.,"",.F.,"M")
		If nLastKey <> 27
	   		SetDefault(aReturn,"")
	   		nLinha:= MLCount(cConteudo,132)
	        For nX:= 1 To nLinha
				nLin++
				If nLin > 80
					nLin := 1
					@ 00,00 PSAY AvalImp(132)
				Endif
				@ nLin,000 PSAY Memoline(cConteudo,132,nX)
	        Next nX
			Set device to Screen
			MS_FLUSH()
		EndIf
	EndIf
Return .T.




/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³TemBxCanc ³ Autor ³ Andreia Santos        ³ Data ³ 09/12/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³VerIfica se a baixa do titulo foi cancelada                 ³±±
±±³          ³Caso n„o seja passada a Chave, o SE5 deve estar posicionado ³±±
±±³          ³para a montagem da Chave.                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³TemBxCanc()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Financeiro                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TemBxCanc(cChave,lBxFut, cFil, oTemBxCanc)
LOCAL aArea    := GetArea()
LOCAL aAreaSE5 := SE5->(GetArea())
LOCAL lRet 	   := .F.
LOCAL cQuery   := ""
LOCAL cAlias   := ""

DEFAULT lBxFut := .F.
DEFAULT cFil := xFilial("SE5")
DEFAULT oTemBxCanc := NIL

dbSelectArea("SE5")
cChave := If(cChave==Nil,E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ,cChave)
If !Empty(cChave)
	// Se o SE5 nao estiver posicionado, posiciona para encontrar os estornos
	// do titulo correto, tanto em SQL como em CDX
	If !(IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL))
		If SE5->&(IndexKey()) != xFilial("SE5")+cChave .And. !Empty(IndexKey(7))
			dbSetOrder( 7 )
			dbSeek(cFil+cChave)
		Endif
	EndIf
Endif

If !EMPTY(oTemBxCanc)
	If EMPTY(oTemBxCanc:cBaseQuery)
		cQuery := "SELECT E5_FILORIG FROM " + RetSqlName("SE5") + " WHERE "
		cQuery += "E5_FILIAL = ? "
		cQuery += "AND E5_PREFIXO = ? "
		cQuery += "AND E5_NUMERO = ? "
		cQuery += "AND E5_PARCELA = ? "
		cQuery += "AND E5_TIPO = ? "
		cQuery += "AND E5_CLIFOR = ? "
		cQuery += "AND E5_LOJA = ? "
		cQuery += "AND E5_RECPAG = ? "
		cQuery += "AND E5_SEQ = ? "
		cQuery += "AND (E5_TIPODOC = ? OR E5_SITUACA IN (?) ) "
		cQuery += "AND E5_DTCANBX <= ? "

		// Cláusulas que dependam de uma condição devem ser inseridas por último
		If !lBxFut
			cQuery += "AND E5_DATA <= ? "
		EndIf

		cQuery += "AND D_E_L_E_T_ = ''"

		cQuery := ChangeQuery(cQuery)
		oTemBxCanc:SetQuery( cQuery )
	EndIf

	// Aqui o valor da cláusula 1 é quem depende de uma condição e não a cláusula em si.
	If IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL)
		oTemBxCanc:SetString(1,SE2->E2_FILIAL)
	Else
		oTemBxCanc:SetString(1,cFil)
	Endif
	oTemBxCanc:SetString(2,SE5->E5_PREFIXO)
	oTemBxCanc:SetString(3,SE5->E5_NUMERO)
	oTemBxCanc:SetString(4,SE5->E5_PARCELA)
	oTemBxCanc:SetString(5,SE5->E5_TIPO)
	oTemBxCanc:SetString(6,SE5->E5_CLIFOR)
	oTemBxCanc:SetString(7,SE5->E5_LOJA)
	oTemBxCanc:SetString(8,If(SE5->E5_RECPAG == 'P','R','P'))	// Validação para títulos de carteiras diferentes porem com a mesma chave
	oTemBxCanc:SetString(9,SE5->E5_SEQ)
	oTemBxCanc:SetString(10,"ES")
	oTemBxCanc:SetIn(11,{"C","E","X"})
	oTemBxCanc:SetDate(12,dDataBase)

	If !lBxFut	// Cláusulas dependentes de uma condição
		oTemBxCanc:SetDate(13,dDataBase)
	EndIf

	cQuery:=oTemBxCanc:GetFixQuery()
	lRet := !Empty(MpSysExecScalar(cQuery,"E5_FILORIG"))
Else
	If SE5->(!Eof())
		If Select("__NewSe5") == 0
			ChkFile("SE5",.F.,"__NewSe5")
		Endif
		dbSelectArea("__NewSe5")

		cQuery := "SELECT E5_FILIAL FROM "+RetSqlName("Se5")+" WHERE "
		If IsInCallStack("FVeDatIr") .and. IsInCallStack("FINA091") .and. !Empty(SE5->E5_FILIAL)
			cQuery += "E5_FILIAL='"+SE2->E2_FILIAL+"' AND "
		Else
			cQuery += "E5_FILIAL='" + cFil + "' AND "
		Endif
		cQuery += "E5_PREFIXO='"+SE5->E5_PREFIXO+"' AND "
		cQuery += "E5_NUMERO='"+SE5->E5_NUMERO+"' AND "
		cQuery += "E5_PARCELA='"+SE5->E5_PARCELA+"' AND "
		cQuery += "E5_TIPO='"+SE5->E5_TIPO+"' AND "
		cQuery += "E5_CLIFOR='"+SE5->E5_CLIFOR+"' AND "
		cQuery += "E5_LOJA='"+SE5->E5_LOJA+"' AND "
		cQuery += "E5_SEQ='"+SE5->E5_SEQ+"' AND "
		cQuery += "(E5_TIPODOC='ES' OR E5_SITUACA='C' OR E5_SITUACA='E' OR E5_SITUACA='X') AND "
		If !lBxFut
			cQuery += "E5_DATA <= '"+DTOS(dDataBase)+"' AND "
		EndIf
		cQuery += "E5_DTCANBX <= '"+DTOS(dDataBase)+"' AND "
		cQuery += "D_E_L_E_T_<>'*'"
		cQuery := ChangeQuery(cQuery)

		cAlias := "__BXCAN"
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		If ! ( NetErr() )
			If (cAlias)->(!EOF())
				lRet := .T.
			EndIf

			If ( Select( cAlias ) > 0 )
				(cAlias)->( dbCloseArea() )
			EndIf
		EndIf

		DBSelectArea("__NewSe5")
	EndIf
EndIf

RestArea(aAreaSE5)
RestArea(aArea)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FirstDay ³ Autor ³ Cesar C S Prado		  ³ Data ³ 09/02/94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Devolve o 1o. dia de um mes.										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FirstDay(dData)
Local cData := Dtos(dData)
cData := "01/"+SubStr(cData,5,2)+"/"+Substr(cData,1,4)
Return ( Ctod(cData,"ddmmyy") )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³A207Um 	³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 14.01.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravar no arquivo SAH o conteudo da tabela 62 do SX5		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A207Um()
Local cAlias	:= Alias()

If FindFunction('A207UM'+cPaisLoc)
	&('A207UM'+cPaisLoc+'()')
Else
	DbSelectArea("SAH")

	If !dbSeek(xFilial("SAH"))
		DbSelectArea("SX5")
		DbSeek(xFilial()+"62")

		While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"62"
			Reclock("SAH",.T.)
			Replace AH_FILIAL With xFilial()
			Replace AH_UNIMED With Substr(SX5->X5_CHAVE,1,Len(AH_UNIMED))
			Replace AH_UMRES  With Substr(X5Descri(),1,Len(AH_UMRES))
			Replace AH_DESCPO With Substr(X5Descri(),1,Len(AH_DESCPO))
			Replace AH_DESCIN With Substr(X5Descri(),1,Len(AH_DESCIN))
			Replace AH_DESCES With Substr(X5Descri(),1,Len(AH_DESCES))
			MsUnlock()
			DbSelectArea("SX5")
			DbSkip()
		End
	EndIf
Endif

DbSelectArea(cAlias)
Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³A508Grupo ³ Autor ³ Alex Sandro Valario   ³ Data ³ 12.05.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravar no arquivo SBM o conteudo da tabela 03 do SX5		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A508Grupo()
Local cAlias	:= Alias()
DbSelectArea("SBM")
If FWModeAccess("SBM",3) == "C" // SBM Compartilhada
	If LastRec() == 0
		DbSelectArea("SX5")
		DbSeek(xFilial()+"03")
		While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
			Reclock("SBM",.T.)
			Replace BM_FILIAL With xFilial()
			Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
			Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
			MsUnlock()
			DbSelectArea("SX5")
			DbSkip()
		End
	EndIf
Else // SBM Exclusiva
	If !dbSeek(xFilial("SBM"))
		DbSelectArea("SX5")
		DbSeek(xFilial()+"03")
		While !Eof() .And. X5_FILIAL+X5_TABELA == xFilial()+"03"
			Reclock("SBM",.T.)
			Replace BM_FILIAL With xFilial()
			Replace BM_GRUPO With Substr(SX5->X5_CHAVE,1,Len(BM_GRUPO))
			Replace BM_DESC  With Substr(X5Descri(),1,Len(BM_DESC))
			MsUnlock()
			DbSelectArea("SX5")
			DbSkip()
		End
	EndIf
EndIf

DbSelectArea(cAlias)
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³AvalQtdPre³ Autor ³Rodrigo de A. Sartorio ³ Data ³21/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao generica para avaliar se considera ou nao quantidade³±±
±±³			 ³ prevista de acordo com o parametro MV_QTDPREV			     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ AvalQtdPre(ExpC1,ExpN1,ExpL1,ExpC2)  					        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias a ser pesquisado							        ³±±
±±³			 ³ ExpN1 = Tipo da quantidade a ser pesquisada		       	  ³±±
±±³			 ³ 		  1 = Saldo Empenhado								        ³±±
±±³			 ³ 		  2 = Saldo Previsto para Entrada		    		     ³±±
±±³			 ³ 		  3 = 1+2											           ³±±
±±³			 ³ ExpL1 = Pesquisa da Segunda Unidade de Medida              ³±±
±±³			 ³ ExpC2 = Alias da query a ser utilizada                     ³±±
±±³			 ³ ExpL2 = Considera qtd prev independente do parametro       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ GENERICO MATERIAIS									              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AvalQtdPre(cAlias,nTipo,lSegUM,cQuery,lEmpPrev)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variavel utilizada para verIficar se considera qtd prevista ou nao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nRetorno:=0

DEFAULT cQuery := cAlias
DEFAULT lEmpPrev:= .F.

lSegUM := If(lSegUM==NIL, .F., lSegUM)
If (lConsPrev == NIL)
	lConsPrev := If(GetMV("MV_QTDPREV")== "S",.T.,.F.)
EndIf
If lConsPrev .Or. lEmpPrev
	If nTipo == 1
		If cAlias == "SB2"
			nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2,(cQuery)->B2_QEMPPRE)
		ElseIf cAlias == "SB8"
			nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
		ElseIf cAlias == "SBF"
			nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
		EndIf
	ElseIf nTipo == 2
		If cAlias == "SB2"
			nRetorno := If(lSegUM, ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_SALPPRE)
		EndIf
	ElseIf nTipo == 3
		If cAlias == "SB2"
			nRetorno := If(lSegUM,(cQuery)->B2_QEPRE2+ConvUM((cQuery)->B2_COD,(cQuery)->B2_SALPPRE,0,2),(cQuery)->B2_QEMPPRE+(cQuery)->B2_SALPPRE)
		ElseIf cAlias == "SB8"
			nRetorno := If(lSegUM,(cQuery)->B8_QEPRE2,(cQuery)->B8_QEMPPRE)
		ElseIf cAlias == "SBF"
			nRetorno := If(lSegUM,(cQuery)->BF_QEPRE2,(cQuery)->BF_QEMPPRE)
		EndIf
	EndIf
EndIf
Return nRetorno

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ GetArea()³ Autor ³ Fernando G/Sergio	  ³ Data ³ 07/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Guarda a area de trabalho              						  ³±±
±±³			 ³ 															              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := GetArea()										           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1: Alias da tabela que pode estar em insert.Quando este³±±
±±³			 ³       parametro é informado o sistema nao reposiciona o    ³±±
±±³			 ³ 		 recno quando a restarea for executada				     ³±±
±±³			 ³ NAO SERVE PARA SALVAR A AREA PASSADA COMO PARAMETRO !!!    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ ExpA1 													              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function GetArea(cSqlAlias)
If cSqlAlias<>Nil .And. cSqlAlias==Alias()
	Return( { Alias(), IndexOrd(), Nil } )
Else
	Return( { Alias() , IndexOrd() , RecNo() })
EndIf

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³RestArea()³ Autor ³ Fernando G/Sergio	  ³ Data ³ 07/10/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Restaura a area de trabalho										  ³±±
±±³			 ³ 																			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ RestArea( ExpA1 ) 													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ LOJAXFUN 																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ ExpA1 -> Vetor contEndo a area ( retornado pela GetArea() )³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/

Function RestArea( aArea )
If !Empty(aArea[ 1 ] )
    If Select(aArea[ 1 ]) > 0
	   DbSelectArea( aArea[ 1 ] )
	   If aArea[ 2 ] <> IndexOrd()
		   DbSetOrder( aArea[ 2 ] )
       EndIf
	   If ( aArea[ 3 ] <> Nil .And. aArea[ 3 ] <> RecNo() ) // Melhoria de Performace para o Top Connect
		  DbGoTo( aArea[ 3 ] )
	   EndIf
	Endif
EndIf
Return( nil )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³LjMsgRun	³ Autor ³ Fernando Godoy		  ³ Data ³ 11/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Executa um Bloco de c¢digo e aguarda o retorno.				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Sigaloja																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
function LjMsgRun( cCaption, cTitle, bAction, cCor )

Local oDlg, nWidth
Local oFont

DEFAULT cCaption 	:= STR0021  //"Aguarde por favor..."
DEFAULT bAction		:= { || Inkey( 1 ) }

//Verifica se é execução sem Interface
If IsBlind()
	Eval( bAction )
Else
	DEFINE FONT oFont NAME "Arial" SIZE 6,14 BOLD

	If cTitle == NIL
		DEFINE DIALOG oDlg ;
		FROM 0,0 TO 3, Len( cCaption ) + 8 ;
		STYLE nOr( DS_MODALFRAME, WS_POPUP )
		oDlg:SetFont(oFont)
		nWidth := oDlg:nRight - oDlg:nLeft
		@ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
	Else
		DEFINE DIALOG oDlg ;
		FROM 0,0 TO 4, Max( Len( cCaption ), Len( cTitle ) ) + 8 ;
		TITLE cTitle ;
		STYLE DS_MODALFRAME
		oDlg:SetFont(oFont)
		nWidth := oDlg:nRight - oDlg:nLeft
		@ 2,0 Say xPadc(cCaption,nWidth) 	 of oDlg PIXEL
	EndIf

	oDlg:bStart := { || Eval( bAction, oDlg ), oDlg:End()}
	oDlg:cMsg	:= cCaption

	ACTIVATE DIALOG oDlg CENTER
	//	ON PAINT oDlg:Say( 1, 0, xPadC( oDlg:cMsg, nWidth ),CLR_RED )

	oFont:End()
EndIf

return nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³Numeral	³ Autor ³ Fernando Godoy		  ³ Data ³ 11/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna a forma numeral de um n£mero inteiro. 				  ³±±
±±³			 ³N£emros de 1 a 100.													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Sigaloja																	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Numeral(nNumero)
Local cRetorno := ""
Local aNum_1	:= {}
Local aNum_2	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega o Array com os nuemros b sicos ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Aadd( aNum_1, Oemtoansi(STR0023))  // Primeiro
Aadd( aNum_1, Oemtoansi(STR0024))  // Segundo
Aadd( aNum_1, Oemtoansi(STR0025))  // Terceiro
Aadd( aNum_1, Oemtoansi(STR0026))  // Quarto
Aadd( aNum_1, Oemtoansi(STR0027))  // Quinto
Aadd( aNum_1, Oemtoansi(STR0028))  // Sexto
Aadd( aNum_1, Oemtoansi(STR0029))  // S‚timo
Aadd( aNum_1, Oemtoansi(STR0030))  // Oit vo
Aadd( aNum_1, Oemtoansi(STR0031))  // Nono

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega Array com os n£meros iniciais de cada dezena ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Aadd( aNum_2, Oemtoansi(STR0032))  // D‚cimo
Aadd( aNum_2, Oemtoansi(STR0033))  // Vig‚simo
Aadd( aNum_2, Oemtoansi(STR0034))  // Trig‚simo
Aadd( aNum_2, Oemtoansi(STR0035))  // Quatrag‚simo
Aadd( aNum_2, Oemtoansi(STR0036))  // Quinquag‚simo
Aadd( aNum_2, Oemtoansi(STR0037))  // Sextoagesimo
Aadd( aNum_2, Oemtoansi(STR0038))  // Septoagesimo
Aadd( aNum_2, Oemtoansi(STR0039))  // Octoagesimo
Aadd( aNum_2, Oemtoansi(STR0040))  // Nonoagesimo
Aadd( aNum_2, Oemtoansi(STR0041))  // Cent‚simo
If nNumero <= 10
	If nNumero == 10
		cRetorno := aNum_2[1]
	Else
		cRetorno := aNum_1[nNumero]
	EndIf
ElseIf nNumero <= 20
	If nNumero == 20
		cRetorno := aNum_2[2]
	Else
		cRetorno := aNum_2[1] + Space(1) + ( aNum_1[nNumero - 10] )
	EndIf
ElseIf nNumero <= 30
	If nNumero == 30
		cRetorno := aNum_2[3]
	Else
		cRetorno := aNum_2[2] + Space(1) + ( aNum_1[nNumero - 20] )
	EndIf
ElseIf nNumero <= 40
	If nNumero == 40
		cRetorno := aNum_2[4]
	Else
		cRetorno := aNum_2[3] + Space(1) + ( aNum_1[nNumero - 30] )
	EndIf
ElseIf nNumero <= 50
	If nNumero == 50
		cRetorno := aNum_2[5]
	Else
		cRetorno := aNum_2[4] + Space(1) + ( aNum_1[nNumero - 40] )
	EndIf
ElseIf nNumero <= 60
	If nNumero == 60
		cRetorno := aNum_2[6]
	Else
		cRetorno := aNum_2[5] + Space(1) + ( aNum_1[nNumero - 50] )
	EndIf
ElseIf nNumero <= 70
	If nNumero == 70
		cRetorno := aNum_2[7]
	Else
		cRetorno := aNum_2[6] + Space(1) + ( aNum_1[nNumero - 60] )
	EndIf
ElseIf nNumero <= 80
	If nNumero == 80
		cRetorno := aNum_2[8]
	Else
		cRetorno := aNum_2[7] + Space(1) + ( aNum_1[nNumero - 70] )
	EndIf
ElseIf nNumero <= 90
	If nNumero == 90
		cRetorno := aNum_2[9]
	Else
		cRetorno := aNum_2[8] + Space(1) + ( aNum_1[nNumero - 80] )
	EndIf
Else
	cRetorno := aNum_2[10]
EndIf

Return cRetorno


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ Condicao ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 11.02.92  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para avaliar condicao de pagamento                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := Condicao(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array contEndo os valores e os vencimentos de cada  ³±±
±±³			 ³ 		  parcela.                                             ³±±
±±³			 ³ ExpN1 = Valor total a ser parcelado.                        ³±±
±±³			 ³ ExpC1 = Codigo da condicao de pagamento a ser considerada.  ³±±
±±³			 ³ ExpN2 = Valor do IPI destacado para condicao que obrigue o  ³±±
±±³			 ³ 		  IPI a entrar na 1a parcela.                          ³±±
±±³			 ³ ExpD1 = Data inicial para considerar desdobramento 		   ³±±
±±³			 ³ ExpN3 = Valor do ICMS Solidario                             ³±±
±±³			 ³ ExpA2 = Array contEndo a sigla e valor dos impostos calcula-³±±
±±³			 ³ 		  dos para os paises Internacionais (MercoSul...)	   ³±±
±±³			 ³ ExpA3 = Array contendo dados semelhantes ao que teria no    ³±±
±±³			 ³ 		  SE4 												   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³	MOTIVO DA ALTERACAO                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Rogerio F.G. ³18/11/97³B.HUR ³Alt Cond Pagto Tipo 9                    ³±±
±±³ Rogerio F.G. ³24/11/97³B.HUR ³Ajuste Valor Cond Pagto tipo 8           ³±±
±±³ Lucas        ³29.06.98³16770A³Adaptacao para os impostos MercoSul...   ³±±
±±³ Aline C.Vale ³13.09.99³xxxxxx³Consistencia do ultimo dia da cond. 3    ³±±
±±³ Aline C.Vale ³20.09.99³18368A³Acerto na Cond.Pgto.Tipo 7               ³±±
±±³ Aline C.Vale ³25.10.99³24332A³Tratar Junta IPI na Cond.Pgto.Tipo 8     ³±±
±±³ Sandro       ³02.03.00³xxxxxx|funcionamento sem a existencia da codicao³±±
±±³              ³        ³      |cadastrada no SE4                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION Condicao(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,nInicio3,aDias3)

Local aDados   := {}
Local aVenc    := {}
Local aVencTmp := {}

Local cAliasSEC:= "SEC"

Local nX       := 0
Local nY       := 0
Local nValRat  := 0
Local nIpiRat  := 0
Local nSolRat  := 0
Local nPosScan := 0
Local nVlrAcum1:= 0
Local nVlrAcum2:= 0
Local nVlrParc := 0
Local nParcRat := 0
Local nParcIpi := 0
Local nParcSol := 0

Local lCondVenda := .F.

Local cQuery := ""
Local nCntFor:= 0

Default nValIpi   := 0
Default nValSolid := 0

If __lAgltDup == NIL
	__lAgltDup := (SuperGetMv("MV_AGLDUPB",.F.,"2") == "1")    //"1"-AGLUTINA "2"-NAO AGLUTINA
EndIf

If __lDataRef == NIL
	__lDataRef := (SuperGetMv("MV_DATDUPB",.F.,"1") == "1")    //"1"-ULTIMA DATA "2"-DATA INICIAL
EndIf

If __lTPCondPg == NIL
	__lTPCondPg := ExistTemplate("GMCondPagto")
EndIf
If __nTamRat == NIL
	__nTamRat := TamSX3("EC_RATEIO")[2]
EndIf

SE4->(dbSetOrder(1))
If SE4->(MsSeek(xFilial("SE4")+cCond))
	//
	// Template de GEM - Gestao de Empreendimentos Imobiliarios
	//
	// Verifica se a condicao de pagamento tem vinculado com uma condicao de venda
	//
	If __lTPCondPg
		lCondVenda := ExecTemplate("GMCondPagto",.F.,.F.,{cCond,} )
	EndIf

	If SE4->E4_TIPO == "B"

		SEC->(DbSetOrder(1))

		aStruSEC := SEC->( dbStruct() )

		cAliasSEC := GetNextAlias()

		cQuery := "SELECT * FROM " + RetSqlName( "SEC" ) + " SEC "
		cQuery += "WHERE "
		cQuery += "EC_FILIAL='"    + xFilial( "SEC" )    + "' AND "
		cQuery += "EC_CODIGO='"    + SE4->E4_CODIGO      + "' AND "
		cQuery += "D_E_L_E_T_=' ' "

		cQuery += "ORDER BY "      + SqlOrder( SEC->( IndexKey() ) )

		cQuery := ChangeQuery( cQuery )

		SEC->( dbCommit() )

		dbUseArea( .T.,"TOPCONN", TcGenQry( ,,cQuery ), cAliasSEC, .F., .T. )

		For nCntFor := 1 To Len(aStruSEC)
			If ( aStruSEC[nCntFor,2] <> "C" ) .And. ( aStruSEC[nCntFor,2] <> "M" )
				TcSetField(cAliasSEC,aStruSEC[nCntFor,1],aStruSEC[nCntFor,2],aStruSEC[nCntFor,3],aStruSEC[nCntFor,4])
			EndIf
		Next nCntFor

		While ( cAliasSEC )->(!Eof()) .And. ( cAliasSEC )->EC_FILIAL == xFilial("SEC") .And.;
									( cAliasSEC )->EC_CODIGO == SE4->E4_CODIGO
			nValRat  := NoRound(nValTot   * ( ( cAliasSEC )->EC_RATEIO / 100 ),__nTamRat)
			nIpiRat  := NoRound(nValIpi   * ( ( cAliasSEC )->EC_RATEIO / 100 ),__nTamRat)
			nSolRat  := NoRound(nValSolid * ( ( cAliasSEC )->EC_RATEIO / 100 ),__nTamRat)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Acumula para calcular diferenca de rateio            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nParcRat += nValRat
			nParcIpi += nIpiRat
			nParcSol += nSolRat

   			Aadd(aDados, { nValRat,nIpiRat,nSolRat, {  ( cAliasSEC )->EC_CODIGO,;
						    						   	( cAliasSEC )->EC_COND,;
						    							( cAliasSEC )->EC_TIPO,;
						    							( cAliasSEC )->EC_DDD,;
   														( cAliasSEC )->EC_IPI,;
							   							( cAliasSEC )->EC_SOLID } })
			( cAliasSEC )->(dbSkip())
		Enddo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha a area de trabalho da query                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		( cAliasSEC )->( dbCloseArea() )
		dbSelectArea( "SEC" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ajusta a diferenca                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDados[Len(aDados)][1] += nValTot   - nParcRat
		aDados[Len(aDados)][2] += nValIpi   - nParcIpi
		aDados[Len(aDados)][3] += nValSolid - nParcSol


	Else
		Aadd(aDados, { nValTot,nValIpi,nValSolid,{ SE4->E4_CODIGO,;
    					SE4->E4_COND,;
    					SE4->E4_TIPO,;
    					SE4->E4_DDD,;
    					SE4->E4_IPI,;
    					SE4->E4_SOLID}})
	Endif
	For nX := 1 to Len(aDados)
	    aVencTmp := AvalCond(aDados[nX][1],SE4->E4_CODIGO,aDados[nX][2],dData0,aDados[nX][3],aImpVar,aE4,nAcrescimo,aDados[nX][4],nInicio3,aDias3)
		If Len(aVencTmp) > 0
	    	For nY := 1 to Len(aVencTmp)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se o parametro aglutina por data            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPosScan := If(__lAgltDup .AND. ! lCondVenda , Ascan(aVenc,{|x| x[1] == aVencTmp[nY][1]}), 0 )
				If nPosScan > 0
					aVenc[nPosScan][2] += aVencTmp[nY][2]
				ElseIf aVencTmp[nY][2] > 0 .Or. ( cPaisLoc $ 'COL|VEN' .And. aVencTmp[nY][2] >= 0 )
					Aadd(aVenc,{aVencTmp[nY][1],aVencTmp[nY][2]})
				Endif
	    	Next nY
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o parametro da data inicial              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    		If __lDataRef
				dData0 := aVencTmp[Len(aVencTmp),1]
			Endif
		Endif

	Next nX
Endif

Return(aVenc)


Function DiaExtenso(dExRef,cExTipo)
Local aExSemana := {STR0012,STR0013,STR0014,STR0015,STR0016,STR0017,STR0018}
Return( If ( Dow(dExRef) == 0, "", If (cExTipo == "N", aExSemana [Dow(dExRef)], aExSemana [Dow(dExRef)]) ))

Function Ano_Mes(lAno)
If lAno
	Return STR0019
Else
	Return STR0020
EndIf


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ CONAOK	³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 01.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Mensagem e confirmacao do processamento						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ CONA0K(void)															  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ConaOk()
Return (MsgYesNo(OemToAnsi(STR0042),OemToAnsi(STR0001)))

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ ReadMotBx³ Autor ³ Andreia dos Santos	  ³ Data ³ 02/12/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Leitura do arquivo SIGAADV.MOT para carregar array aMotBx c/³±±
±±³			 ³o Motivo da baixa, se movimenta banco e se gera comissao	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ReadMotBx																  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³ Array aMotBx															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Generico 																  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ReadMotBx(lEspecie)
Local nHdlMot	:= 0
Local nBytes	:= 0
Local nTamArq	:= 0
Local nTamLin	:= 0
Local xBuffer
Local aMotRead	:= {}
Local cFile		:= "SIGAADV.MOT"

Default lEspecie	:= .F.

If __aMotRead == Nil .Or. Empty(__aMotRead)
	__aMotRead := {}
	__lEspecie := .F.

	If ExistBlock("FILEMOT")
		cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
	EndIf

	If !FILE(cFile)
		nHdlMot := fCreate(cFile)
		If nHdlMot == -1
			HELP(" ",1,"MOT_ERROR")
			Final("Erro F_"+str(ferror(),2)+" em SIGAADV.MOT")
		EndIf

		If __Language == "ENGLISH"
			fWrite(nHdlMot,"NORNORMAL    ASSSN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DACEXCHANGE  ANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEVDEVOLUTIONANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEBDEBIT CC  PSNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"VENVENDOR    PNNNN"+chr(13)+chr(10))
		ElseIf __Language == "SPANISH"
			fWrite(nHdlMot,"NORNORMAL    ASSSN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DACPERMUTA   ANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEVDEVOLUCIONANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEBDEBITO CC PSNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"VENTIT.BANCO PNNNN"+chr(13)+chr(10))
		Else
			fWrite(nHdlMot,"NORNORMAL    ASSSN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DACDACAO     ANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEVDEVOLUCAO ANNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"DEBDEBITO CC PSNNN"+chr(13)+chr(10))
			fWrite(nHdlMot,"VENVENDOR    PNNNN"+chr(13)+chr(10))
		EndIf
		fClose(nHdlMot)
		lEspecie := .T.
	EndIf

	nHdlMot := FOPEN(cFile,64)

	If nHdlMot < 0
		HELP(" ",1,"SIGAADV.MOT")
		Final("SIGAADV.MOT")
	EndIf

	nTamArq := FSEEK(nHdlMot,0,2)	// VerIfica tamanho do arquivo
	FSEEK(nHdlMot,0,0)				// Volta para inicio do arquivo

	If !lEspecie
		//Verifica se o arquivo está com o tamanho antigo (19 bytes por linha). Caso contrário, o arquivo está com o tamanho novo (20 bytes por linha)
		xBuffer  := Space( nTamArq )
		FREAD( nHdlMot, @xBuffer, nTamArq )
		nTamLin	 := At(chr(10),xBuffer)
		If !(nTamLin > 0)
			nTamLin := Len(xBuffer) //Tamanho padrão da linha do arquivo
		EndIf
		lEspecie := nTamLin <> 19
		FSEEK(nHdlMot,0,0)	// Volta para inicio do arquivo
	EndIf

	While nBytes < nTamArq

		If lEspecie
			xBuffer := Space( 20 )
			FREAD( nHdlMot, @xBuffer, 20 )

			AADD(aMotRead,Upper(SubStr(xBuffer,1,03)+"  ³"+SubStr(xBuffer,04,10)+"³ "+SubStr(xBuffer,15,01);
			+Space(4)+"³ "+SubStr(xBuffer,16,01);
			+Space(5)+"³ "+Substr(xBuffer,14,1);
			+Space(4)+"³ "+Substr(xBuffer,17,1);
			+Space(4)+"³ "+Substr(xBuffer,18,1)))

			nBytes += 20
		Else
			xBuffer := Space( 19 )
			FREAD( nHdlMot, @xBuffer, 19 )

			AADD(aMotRead,Upper(SubStr(xBuffer,1,03)+"  ³"+SubStr(xBuffer,04,10)+"³ "+SubStr(xBuffer,15,01);
			+ Space(4) + "³ " + SubStr(xBuffer,16,01);
			+ Space(5) + "³ " + Substr(xBuffer,14,1);
			+ Space(4) + "³ " + Substr(xBuffer,17,1)))

			nBytes += 19
		EndIf
	EndDo

	__aMotRead := aClone(aMotRead)
	__lEspecie := lEspecie

	Fclose(nHdlMot)
Else
	aMotRead := aClone(__aMotRead)
	If !lEspecie
		lEspecie := __lEspecie
	EndIf
EndIf

Return aMotRead

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AgentLock ³ Autor ³ F bio F. Pessoa       ³ Data ³ 06/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Loca um arquivo para Leitura e grava‡ao do AutComm.<caixa> ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AgentLock(nHandle, cImpressora, lWinFrame, cDirAgent)
Local lRet      := !(((cImpressora == "BEMATECH") .Or. (cImpressora == "VERIfONE SC552")) .And. lWinFrame)
Local cLockFile := "AGENTE.LOC"

While !lRet

	nHandle := FOpen(cDirAgent + cLockFile, 16)
	lRet    := !(nHandle < 0)
	SysRefresh()           // Similar ao ProcessMessage do Delphi

End

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³AgentUnLock³ Autor ³ F bio F. Pessoa       ³ Data ³ 06/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Loca um arquivo para Leitura e grava‡ao do AutComm.<caixa>  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AgentUnlock(nHandle)

FClose(nHandle)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³MSCodVei  ³Autor  ³Sandro              ³ Data ³ 18/09/2000  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Faz consistencias do cod. auxiliar quando veiculos          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MSCodVei()
Local nPosAux:= 0, nPosProd:= 0, nX , nY
Local aItemH:={},aItemA:= {}
Local cProduto, cCodAux
nPosAux := ascan(aHeader,{|x| Upper(Subs(x[2],3,7)) == '_CODGRP'})
If nPosAux > 0
   For nX := len(aHeader) to 1 step -1
      If (Upper(Subs(aHeader[nX,2],3,8)) == '_PRODUTO') .OR. ;
         (Upper(Subs(aHeader[nX,2],3,8)) == '_COD    ')
         nPosProd := nX
         exit
      EndIf
   Next
   If nPosProd > 0
      aItemH := aClone(aHeader[nPosProd])
      aItemA := aClone(aHeader[nPosAux])
      aHeader[nPosAux] := aClone(aItemH)
      aHeader[nPosProd]:= aClone(aItemA)
      For nY := 1 to len(aCols)
         cProduto := aCols[nY,nPosProd]
         cCodAux  := aCols[nY,nPosAux]
         aCols[nY,nPosAux] := cProduto
         acols[nY,nPosProd]:= cCodAux
      Next
   EndIf
EndIF
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MatGraph  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao generica para montagem de dialog com grafico        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³        01³ ExpC1 = Titulo da Janela                                   ³±±
±±³        02³ ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes³±±
±±³        03³ ExpL2 = Flag indicando se mostra menu para mudar caracteris³±±
±±³          ³ ticas do grafico como tipo e numero de dimensoes (2 ou 3)  ³±±
±±³        04³ ExpL3 = Indica se muda a cor em cada barra ou faixa de vlr ³±±
±±³        05³ ExpN1 = Indica o tipo inicial do grafico                   ³±±
±±³        06³ ExpN2 = Indica a cor inicial dos valores apresentados      ³±±
±±³        07³ ExpA1 = Array com os dados a serem apresentados. Dimensoes:³±±
±±³          ³ [1] Nome a ser colocado no eixo x (Caracter)               ³±±
±±³          ³ [2] Valor do eixo y (Numerico)                             ³±±
±±³        08³ ExpC2 = Alias do arquivo de trabalho que contem os dados   ³±±
±±³        09³ ExpA2 = Array com os campos que devem ter o conteudo lido  ³±±
±±³          ³ [1] Nome do campo que tem os dados do eixo x (Caracter)    ³±±
±±³          ³ [2] Nome do campo que tem os valores do eixo y (Caracter)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatGraph(cTitle,lGraph3D,lMenuGraph,lMudaCor,nTipoGraph,nCorDefault,aDados,cAliasTrb,aCamposTrb)
LOCAL oDlgGraph,oGraph
Local aSize     := MsAdvSize( .T. )
Local aPosObj   := {}
Local aObjects  := {}
Local lSoBarra  := .F.

DEFAULT lGraph3D   :=.F.
DEFAULT lMenuGraph :=.T.
DEFAULT lMudaCor   :=.F.
DEFAULT nTipoGraph :=2
DEFAULT nCorDefault:=6
DEFAULT cAliasTrb  :=""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Efetua os calculos de Auto Size                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aObjects := {}
AAdd( aObjects, { 100, 100, .T., .T. } )

aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ]-5, 3, 3 }
aPosObj := MsObjSize( aInfo, aObjects, , .T. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Multiplica por 2 para compatibilizar as dimensoes deste objeto         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aPosObj[1,1] *= 2
aPosObj[1,2] *= 2
aPosObj[1,3] *= 2
aPosObj[1,4] *= 2

DEFINE MSDIALOG oDlgGraph TITLE cTitle FROM aSize[7],0 TO aSize[6],aSize[5] PIXEL OF oMainWnd
	oGraph:= GRF_CreateNew(oDlgGraph)
	MontGraph(@oDlgGraph,@oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,@lSoBarra)
	GRF_WinSet(	oGraph,aPosObj[1,1],;	// nTop
		aPosObj[1,2],;              	// nLeft
		aPosObj[1,3],;              	// nBottom
		aPosObj[1,4],0,0,0)         	// nRight
	@ aSize[4]-6,010 SAY STR0057 SIZE 250,6 OF oDlgGraph PIXEL	// "Pressionando o botao da direita do mouse pode-se arrastar o grafico horizontalmente"
ACTIVATE MSDIALOG oDlgGraph	CENTERED ON INIT MatGTools(@oDlgGraph,@oGraph,lMenuGraph,lSoBarra)
RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MatGTools ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao generica para montagem de EnchoiceBar dos graficos  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³        01³ ExpO1 = Objeto da Dialog                                   ³±±
±±³        02³ ExpO2 = Objeto do Grafico                                  ³±±
±±³        03³ ExpL1 = Flag indicando se mostra menu para mudar caracteris³±±
±±³        04³ ExpL2 = Indica se o grafico so podera ser de barra         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MatGTools(oDlgGraph,oGraph,lMenuGraph,lSoBarra)
Local oBar
DEFINE BUTTONBAR oBar SIZE 25,25 3D OF oDlgGraph
DEFINE BUTTON RESOURCE "FINAL" OF oBar GROUP ACTION oDlgGraph:End() TOOLTIP OemToAnsi(STR0051) PROMPT ""//"Abandona"

If lMenuGraph
	If !lSoBarra
		DEFINE BUTTON RESOURCE "LINE"  OF oBar GROUP ;
		ACTION 	GRF_ChartType(oGraph,1),;
		GRF_FixedGap(oGraph,36) ;
		TOOLTIP STR0052; //"Gr fico de Linha"
		PROMPT ""
	EndIf
	DEFINE BUTTON RESOURCE "BAR" OF oBar ;
		ACTION 	GRF_ChartType(oGraph,2),;
		GRF_FixedGap(oGraph,20) ;
		TOOLTIP STR0053;  //"Gr fico de Barras"
		PROMPT ""
	If !lSoBarra
		DEFINE BUTTON RESOURCE "AREA"        OF oBar ;
		ACTION 	GRF_ChartType(oGraph,6),;
		GRF_FixedGap(oGraph,36) ;
		TOOLTIP STR0054; //"Gr fico de Area"
		PROMPT ""
	EndIf
	DEFINE BUTTON RESOURCE "GRAF2D"      OF oBar GROUP ;
		ACTION 	GRF_Chart3D(oGraph,.f.) ;
		TOOLTIP STR0055; //"Gr ficos Bidimensionais"
		PROMPT ""
	DEFINE BUTTON RESOURCE "GRAF3D"      OF oBar ;
		ACTION 	GRF_Chart3D(oGraph,.t.) ;
		TOOLTIP STR0056;  //"Gr ficos Tridimensionais"
		PROMPT ""
EndIf
RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MontGraph ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 16.05.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao que monta o obejto do grafico                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³        01³ ExpO1 = Objeto da Dialog                                   ³±±
±±³        02³ ExpO2 = Objeto do Grafico                                  ³±±
±±³        03³ ExpA1 = Array com os dados a serem apresentados. Dimensoes:³±±
±±³          ³ [1] Nome a ser colocado no eixo x (Caracter)               ³±±
±±³          ³ [2] Valor do eixo y (Numerico)                             ³±±
±±³        04³ ExpC1 = Alias do arquivo de trabalho que contem os dados   ³±±
±±³        05³ ExpA2 = Array com os campos que devem ter o conteudo lido  ³±±
±±³          ³ [1] Nome do campo que tem os dados do eixo x (Caracter)    ³±±
±±³          ³ [2] Nome do campo que tem os valores do eixo y (Caracter)  ³±±
±±³        06³ ExpN1 = Indica o tipo do grafico                           ³±±
±±³        07³ ExpN2 = Indica a cor inicial dos valores apresentados      ³±±
±±³        08³ ExpL1 = Flag indicando se inicializa grafico em 3 dimensoes³±±
±±³        09³ ExpL2 = Indica se muda a cor em cada barra ou faixa de vlr ³±±
±±³        10³ ExpL3 = Indica se o grafico so podera ser de barra         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MontGraph(oDlgGraph,oGraph,aDados,cAliasTrb,aCamposTrb,nTipoGraph,nCorDefault,lGraph3D,lMudaCor,lSoBarra)
Local aArea:=GetArea()
Local aAreaTrb:={}

Local nLoop   := 0
Local lEndData:=.F.

DEFAULT lSoBarra := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Zera os dados do grafico                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
GRF_InitData( oGraph )
GRF_Chart3D(oGraph, lGraph3D )
GRF_FixedGap(oGraph,36)

If ValType(aDados) == "A" .And. Len(aDados) > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Seta o modelo de grafico lendo as informacoes de um array              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len( aDados ) < 2 .And. nTipoGraph <> 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao e possivel utilizar area ou linha com 1 coluna                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Help( " ", 1, "ATC010BAR" )
		lSoBarra:=.T.
		GRF_ChartType(oGraph, 2 )
	Else
		GRF_ChartType(oGraph, nTipoGraph )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Percorre o array de colunas                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nLoop := 1 To Len( aDados )
		nValor := aDados[ nLoop, 2 ]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a coluna do grafico                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		GRF_SetData(oGraph,0,2,nValor,aDados[nLoop,1],nCorDefault)
		lEndData:=.T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Muda a Cor Caso Necessario                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMudaCor
			nCorDefault++
			If nCorDefault > 18
				nCorDefault:=0
			EndIf
		EndIf
	Next nLoop
	If lEndData
	   GRF_EndData(oGraph,0)
	Endif
ElseIf Valtype(cAliasTrb) == "C" .And. Select(cAliasTrb) > 0
	GRF_ChartType(oGraph, nTipoGraph )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Percorre o arquivo de colunas                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAliasTrb)
	aAreaTrb:=GetArea()
	dbGotop()
	While !Eof()
		nValor := FieldGet(FieldPos(aCamposTrb[2]))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria a coluna do grafico                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		GRF_SetData(oGraph,0,2,nValor,FieldGet(FieldPos(aCamposTrb[1])),nCorDefault)
		lEndData:=.T.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Muda a Cor Caso Necessario                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMudaCor
			nCorDefault++
			If nCorDefault > 18
				nCorDefault:=0
			EndIf
		EndIf
		dbSkip()
	End
	RestArea(aAreaTrb)
	If lEndData
	   GRF_EndData(oGraph,0)
	Endif

EndIf
RestArea(aArea)
RETURN NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaCont³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Conta Contabil no Lcto Contabil                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Conta contabil                                     ³±±
±±³          ³ ExpC2 = Tipo do Lancamento                                 ³±±
±±³          ³ ExpO1 = Objeto Descricao da conta debito                   ³±±
±±³          ³ ExpO2 = Objeto Descricao da conta credito                  ³±±
±±³          ³ ExpL1 = Indicador se esta validacao partira da Getdados    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaConta(cConta,cTipo,oDescDeb,oDescCrd,lGetDados,lHelp)

Local aSaveArea		:= GetArea()
Local lRet			:= .T.
Local nPosCta
Local lAchou 		:= .F.
Local lSintetica 	:= .F.
Local nRecCT1
Local cFilCT1		:= xFilial('CT1')
Local lCache 		:= Ctb_IsCache(1)

Local bConta 		:= {|x| 	x[2,1] == cConta .and. ;
								x[2,2] == cTipo .and.;
								x[2,4] == cEmpAnt .and.;
								x[2,5] == cFilCT1 .and.;
								x[2,3] == lHelp }
DEFAULT	lHelp		:= .T.

If CtbInUse()
    //procura no cache das contas ja pesquisada
	If lCache .And. ! Empty(__aCTBConta) .And. ( nPosCta := Ascan( __aCTBConta, bConta) ) > 0
		lRet 		:= __aCTBConta[nPosCta, 1]
		lAchou 		:= __aCTBConta[nPosCta, 3, 1]
		lSintetica 	:= __aCTBConta[nPosCta, 3, 2]
		nRecCT1		:= __aCTBConta[nPosCta, 3, 3]
		lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !lRet .And. !lAchou .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidaConta",,STR0109 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Conta inválida ou não preenchida."###"Linha: "
			Else
				Help("  ", 1, "NOCONTAC")
			EndIf
		EndIf

		If !lRet .And. lAchou .And. lSintetica .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidaConta",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintetica."###"Linha: "
			Else
				Help(" ",1,"NOCLASSE")
			EndIf
		EndIf

		If !lGetDados .And. lRet

			CT1->(dbGoto(nRecCT1))  //posiciona por causa da descricao.

			If cTipo == "1"
				CtbExibe(cConta,"1",@oDescDeb,,lRet)
			ElseIf cTipo == "2"
				CtbExibe(cConta,"2",,@oDescCrd,lRet)
			EndIf
		EndIf

	Else

		lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

		dbSelectArea("CT1")
		dbSetOrder(1)

		If !Empty(cConta)
			dbSelectArea("CT1")
			dbSetOrder(1)
			If !dbSeek(xFilial()+cConta)
				If lHelp
					If IsInCallStack("CTBA500")
						Help( " ", 1, "ValidaConta",,STR0109 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Conta inválida ou não preenchida."###"Linha: "
					Else
						Help("  ", 1, "NOCONTAC")
					EndIf
				EndIf
				lRet := .F.
			Else
				lAchou := .T.
			EndIf
			If lRet
				If CT1->CT1_CLASSE != "2"				// Analitica
					If lHelp
						If IsInCallStack("CTBA500")
							Help( " ", 1, "ValidaConta",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
						Else
							Help(" ",1,"NOCLASSE")
						EndIf
					EndIf
					lRet := .F.
					lSintetica := .T.
				EndIf
			EndIf
		EndIf

		If !lGetDados
			If cTipo == "1"
				CtbExibe(cConta,"1",@oDescDeb,,lRet)
			ElseIf cTipo == "2"
				CtbExibe(cConta,"2",,@oDescCrd,lRet)
			EndIf
		EndIf
		If lCache
			aAdd(__aCTBConta, {lRet, {cConta,cTipo,lHelp,cEmpAnt,cFilCT1}, {lAchou,lSintetica,CT1->(Recno())} } )
		Endif
	Endif

Endif

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaCust³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Centro de Custo no Lcto Contabil                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Centro de Custo Extra Contabil                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaCusto(cCusto,cTipo,oDescCCD,oDescCCC,lGetDados,lHelp)

Local aSaveArea 	:= GetArea()
Local lRet			:= .T.
Local nPosCC
Local lAchou 		:= .F.
Local lSintetica 	:= .F.
Local nRecCTT
Local cFilCTT		:= xFilial('CTT')
Local lCache 		:= Ctb_IsCache(2)
Local bCusto 		:= {|x| 	x[2,1] == cCusto .and. ;
								x[2,2] == cTipo .and.;
								x[2,4] == cEmpAnt .and.;
								x[2,5] == cFilCTT .and.;
								x[2,3] == lHelp }
DEFAULT lHelp		:= .T.

If CtbInUse()
    //procura no cache dos Centros de Custo ja pesquisados
	If lCache .And. ! Empty(__aCTBCusto) .And. ( nPosCC := Ascan( __aCTBCusto, bCusto) ) > 0
		lRet 		:= __aCTBCusto[nPosCC, 1]
		lAchou 		:= __aCTBCusto[nPosCC, 3, 1]
		lSintetica 	:= __aCTBCusto[nPosCC, 3, 2]
		nRecCTT 	:= __aCTBCusto[nPosCC, 3, 3]
		lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !lRet .And. !lAchou .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidaCusto",,STR0111 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Centro de Custo inválido ou não preenchido."###"Linha: "
			Else
				Help("  ", 1, "NOCUSTO")
			EndIf
		EndIf

		If !lRet .And. lAchou .And. lSintetica .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidaCusto",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
			Else
				Help(" ",1,"NOCLASSE")
			EndIf
		EndIf

		If !lGetDados .And. lRet

			CTT->(dbGoto(nRecCTT))     // posiciona por causa da descricao

			If cTipo == "1"
				CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
			EndIf
		EndIf

	Else

		lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !Empty(cCusto)
			dbSelectArea("CTT")
			dbSetOrder(1)
			If __CtbFilVld = Nil
				__CtbFilVld := ExistBlock("CtbFilVld")
			Endif

			If __CtbFilVld
				cFilCtt := ExecBlock("CtbFilVld", .F., .F., "CTT")
			Else
				cFilCtt := xFilial()
			Endif

			If !dbSeek(cFilCtt+cCusto)
				If lHelp
					If IsInCallStack("CTBA500")
						Help( " ", 1, "ValidaCusto",,STR0111 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Centro de Custo inválido ou não preenchido."###"Linha: "
					Else
						Help("  ", 1, "NOCUSTO")
					EndIf
				Endif
				lRet := .F.
			Else
				lAchou := .T.
			EndIf
			If lRet
				If CTT->CTT_CLASSE != "2"				// Centro de Custo Sintetico
					If lHelp
						If IsInCallStack("CTBA500")
							Help( " ", 1, "ValidaCusto",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
						Else
							Help(" ",1,"NOCLASSE")
						EndIf
					EndIf
					lRet := .F.
					lSintetica := .T.
				EndIf
			EndIf
		EndIf

		If !lGetDados
			If cTipo == "1"
				CtbExibeCC(cCusto,"1",@oDescCCD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeCC(cCusto,"2",,@oDescCCC,lRet)
			EndIf
		EndIf
		If lCache
			aAdd(__aCTBCusto, {lRet, {cCusto,cTipo,lHelp,cEmpAnt,cFilCTT}, {lAchou,lSintetica,CTT->(Recno())} } )
		EndIf
	EndIf

Endif

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidItem ³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Item Contabil  no Lcto Contabil                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Item  contabil                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidItem(cItem,cTipo,oDescItD,oDescItC,lGetDados,lHelp)

Local aSaveArea 	:= GetArea()
Local lRet			:= .T.
Local nPosItem
Local lAchou 		:= .F.
Local lSintetica 	:= .F.
Local nRecCTD
Local lCache 		:= Ctb_IsCache(3)
Local cFilCTD		:= xFilial('CTD')
Local bItem 		:= {|x| 	x[2,1] == cItem .and. ;
								x[2,2] == cTipo .and.;
			 					x[2,4] == cEmpAnt .and.;
								x[2,5] == cFilCTD .and.;
								x[2,3] == lHelp }
DEFAULT lHelp		:= .T.

If CtbInUse()
    //procura no cache dos Itens Contabeis ja pesquisados
	If lCache .And. ! Empty(__aCTBItem) .And. ( nPosItem := Ascan( __aCTBItem, bItem) ) > 0
		lRet 		:= __aCTBItem[nPosItem, 1]
		lAchou 		:= __aCTBItem[nPosItem, 3, 1]
		lSintetica 	:= __aCTBItem[nPosItem, 3, 2]
		nRecCTD 	:= __aCTBItem[nPosItem, 3, 3]
		lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !lRet .And. !lAchou .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidItem",,STR0112 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Item Contábil inválido ou não preenchido."###"Linha: "
			Else
				Help(" ", 1, "NOITEM")
			EndIf
		EndIf

		If !lRet .And. lAchou .And. lSintetica .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidItem",,STR0110 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
			Else
				Help(" ",1,"NOCLASSE")
			EndIf
		EndIf

		If !lGetDados .And. lRet

			CTD->(dbGoto(nRecCTD))     // posiciona por causa da descricao

			If cTipo == "1"
				CtbExibeIt(cItem,"1",@oDescItD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeIt(cItem,"2",,@oDescItC,lRet)
			EndIf

		EndIf

	Else

		lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !Empty(cItem)
			dbSelectArea("CTD")
			dbSetOrder(1)
			If !dbSeek(xFilial()+cItem)
				If lHelp
					If IsInCallStack("CTBA500")
						Help( " ", 1, "ValidItem",,STR0112 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Item Contábil inválido ou não preenchido."###"Linha: "
					Else
						Help(" ", 1, "NOITEM")
					EndIf
				EndIf
				lRet := .F.
			Else
				lAchou := .T.
			EndIf
			If lRet
				If CTD->CTD_CLASSE != "2"				// Item Sintetico
					If lHelp
						If IsInCallStack("CTBA500")
							Help( " ", 1, "ValidItem",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
						Else
							Help(" ",1,"NOCLASSE")
						EndIf
					EndIf
					lRet := .F.
					lSintetica := .T.
				EndIf
			EndIf
		EndIf

		If !lGetDados
			If cTipo == "1"
				CtbExibeIt(cItem,"1",@oDescItD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeIt(cItem,"2",,@oDescItC,lRet)
			EndIf
		EndIf
		If lCache
			aAdd(__aCTBItem, {lRet, {cItem,cTipo,lHelp,cEmpAnt,cFilCTD}, {lAchou,lSintetica,CTD->(Recno())} } )
		EndIf
	EndIf

Endif

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³ValidaCLVL³ Autor ³ Pilar S. Albaladejo   ³ Data ³ 24.07.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida Classe de Valor no Lcto Contabil                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. / .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Classe de Valor                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ValidaCLVL(cCLVL,cTipo,oDescCVD,oDescCVC,lGetDados,lHelp)

Local aSaveArea 	:= GetArea()
Local lRet			:= .T.
Local nPosClasse
Local lAchou 		:= .F.
Local lSintetica 	:= .F.
Local nRecCTH
Local cFilCTH		:= xFilial('CTH')
Local lCache 		:= Ctb_IsCache(4)
Local bClasse 		:= {|x| 	x[2,1] == cCLVL .and. ;
			 					x[2,2] == cTipo .and.;
			 					x[2,4] == cEmpAnt .and.;
								x[2,5] == cFilCTH .and.;
			 					x[2,3] == lHelp }

DEFAULT lHelp  		:= .T.

If CtbInUse()
    //procura no cache dos Itens Contabeis ja pesquisados
	If lCache .And. ! Empty(__aCTBClVlr) .And. ( nPosClasse := Ascan( __aCTBClVlr, bClasse) ) > 0
		lRet 		:= __aCTBClVlr[nPosClasse, 1]
		lAchou 		:= __aCTBClVlr[nPosClasse, 3, 1]
		lSintetica 	:= __aCTBClVlr[nPosClasse, 3, 2]
		nRecCTH 	:= __aCTBClVlr[nPosClasse, 3, 3]
		lGetDados 	:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !lRet .And. !lAchou .And. lHelp
			If IsInCallStack("CTBA500")
//				Help(" ", 1, "NOCLVL")
				Help( " ", 1, "ValidaCLVL",,STR0113 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Código da Classe de Valor inválido ou não preenchido."###"Linha: "
			Else
				Help(" ", 1, "NOCLVL")
			EndIf
		EndIf

		If !lRet .And. lAchou .And. lSintetica .And. lHelp
			If IsInCallStack("CTBA500")
				Help( " ", 1, "ValidaCLVL",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
			Else
				Help(" ",1,"NOCLASSE")
			EndIf
		EndIf

		If !lGetDados .And. lRet

			CTH->(dbGoto(nRecCTH))     // posiciona por causa da descricao

			If cTipo == "1"
				CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
			EndIf

		EndIf

	Else

		lGetDados 		:= Iif(Empty(lGetdados),.f.,lGetDados)

		If !Empty(cCLVL)
			dbSelectArea("CTH")
			dbSetOrder(1)
			If !dbSeek(xFilial()+cCLVL)
				If lHelp
					If IsInCallStack("CTBA500")
//						Help(" ", 1, "NOCLVL")
						Help( " ", 1, "ValidaCLVL",,STR0113 + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Código da Classe de Valor inválido ou não preenchido."###"Linha: "
					Else
						Help(" ", 1, "NOCLVL")
					EndIf
				EndIf
				lRet := .F.
			Else
				lAchou := .T.
			EndIf

			If lRet
				If CTH->CTH_CLASSE != "2"				// Classe de Valor Sintetico
					If lHelp
						If IsInCallStack("CTBA500")
							Help( " ", 1, "ValidaCLVL",,STR0110  + CRLF + STR0108 + TMP->CT2_LINHA , 1, 0 ) //"Classe da entidade contábil digitada não pode ser sintética."###"Linha: "
						Else
							Help(" ",1,"NOCLASSE")
						EndIf
					EndIf
					lRet := .F.
					lSintetica := .T.
				EndIf
			EndIf

		EndIf

		If !lGetDados
			If cTipo == "1"
				CtbExibeCV(cCLVL,"1",@oDescCVD,,lRet)
			ElseIf cTipo == "2"
				CtbExibeCV(cCLVL,"2",,@oDescCVC,lRet)
			EndIf
		EndIf
		If lCache
			aAdd(__aCTBClVlr, {lRet, {cCLVL,cTipo,lHelp,cEmpAnt,cFilCTH}, {lAchou,lSintetica,CTH->(Recno())} } )
		EndIf
	EndIf

Endif

RestArea(aSaveArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³ NGSD1100I³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Inclusao de insumo no registro da NFE                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Obs.      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSd1100i(cAliasTPZ)
Local cOrdem,lFound
Local lQTDCON     := .F.

Private lTEMSEQR  := NgVerify("STL")
Private lSEQTPZ   := NgVerify("TPZ")

DEFAULT cAliasTPZ := "TRBTPZ"

dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek("TPZ_QTDCON")
   lQTDCON := .T.
EndIf

dbSelectArea("SD1")
If !Empty(SD1->D1_ORDEM) .And. !(Alltrim(SF1->F1_ESPECIE) $ "CTA/CTE/CTF/CTM/CTR")
	cOrdem := SD1->D1_ORDEM
	dbSelectArea("STJ")
	dbSetorder(1)
	If DbSeek(xFilial("STJ") + cOrdem)
		lFOUND   := .F.

		//Lança insumo para OS ja terminada
		lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)

		dbSelectArea("STL")
		dbSetorder(7)  // ORDEM DE NUMSEQ
		dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
		While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
			STL->TL_NUMSEQ == SD1->D1_NUMSEQ

			If Trim(STL->TL_CODIGO) == Trim(SD1->D1_COD) .and. ;
				Trim(STL->TL_ORDEM)  == cOrdem
				lFound := .T.
				Exit
			Endif
			DbSkip()
		End

		If !lFOUND .AND. SD1->D1_TIPO != 'D'
			// Verifica se a OS e uma OS em Lote e se já possui insumo aplicado
			dbSelectArea("TR8")
			dbSetOrder(02)
			If dbSeek(xFilial("TR8")+CORDEM)
				dbSelectArea("STL")
				dbSetOrder(01)
				dbSeek(xFilial("STL")+CORDEM)
				While STL->(!Eof()) .and.  STL->TL_ORDEM == CORDEM
					If cValToChar(STL->TL_SEQRELA) > "0" .and. Empty(STL->TL_NUMSEQ)
						RecLock("STL",.F.)
						dbDelete()
						MsUnLock("STL")
					EndIf
					dbSelectArea("STL")
					STL->(dbSkip())
				End
			EndIf
			NGSD1GESTL(CORDEM,SD1->D1_COD)//Grava Insumo realizado

			NGSD1STLSCOM()

			dbSelectArea("STJ")
			Reclock("STJ",.F.)
			STJ->TJ_TIPORET := "S"
			MsUnlock("STJ")
			If lTermino
				NGFINAL(STJ->TJ_ORDEM,STJ->TJ_PLANO,STJ->TJ_DTPRINI,STJ->TJ_HOPRINI,STJ->TJ_DTPRFIM,STJ->TJ_HOPRFIM)
			EndIf

			//Grava a garantia do insumo
			dbSelectArea("SD1")
			If FieldPos("D1_GARANTI") > 0
				If SD1->D1_GARANTI == "S"
					dbSelectArea(cAliasTPZ)
					If dbSeek(SD1->D1_ITEM)
						dbSelectArea("TPZ")
						RecLock("TPZ",.T.)
						TPZ->TPZ_FILIAL := xFilial("TPZ")
						TPZ->TPZ_CODBEM := STJ->TJ_CODBEM
						TPZ->TPZ_TIPORE := STL->TL_TIPOREG
						TPZ->TPZ_CODIGO := (cAliasTPZ)->TPZ_CODIGO
						TPZ->TPZ_LOCGAR := (cAliasTPZ)->TPZ_LOCGAR
						TPZ->TPZ_ORDEM  := (cAliasTPZ)->TPZ_ORDEM
						TPZ->TPZ_PLANO  := STJ->TJ_PLANO
						If lSEQTPZ
							TPZ->TPZ_SEQREL := STL->TL_SEQRELA
						EndIf
						TPZ->TPZ_SEQUEN := STL->TL_SEQUENC
						If Empty(STL->TL_DTFIM)
							TPZ->TPZ_DTGARA := STL->TL_DTINICI
						Else
							TPZ->TPZ_DTGARA := STL->TL_DTFIM
						EndIf
						TPZ->TPZ_QTDGAR := (cAliasTPZ)->TPZ_QTDGAR
						TPZ->TPZ_UNIGAR := (cAliasTPZ)->TPZ_UNIGAR
						TPZ->TPZ_CONGAR := (cAliasTPZ)->TPZ_CONGAR
						If lQTDCON
							TPZ->TPZ_QTDCON := (cAliasTPZ)->TPZ_QTDCON
						Endif
						MsUnlock("TPZ")
					EndIf
				EndIf
			EndIf
		ElseIf SD1->D1_TIPO == 'D'
			nQtdeDevol := SD1->D1_QUANT
			aOldArea := GetArea()
			dbSelectArea("SD1")
			dbSetOrder(01)
			If dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
				dbSelectArea("STL")
				dbSetOrder(07)
				dbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
				While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_NUMSEQ == SD1->D1_NUMSEQ
					If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM
						RecLock("STL",.f.)
						If nQtdeDevol >= STL->TL_QUANTID
							dbDelete()
						Else
							nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
							STL->TL_QUANTID -= nQtdeDevol
							STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID
						Endif
						STL->(MsUnlock())
					Endif
					dbSkip()
				End
			Endif
			dbSelectArea("STL")
			dbSetorder(1)
			If !dbSeek(xFilial("STL")+SD1->D1_ORDEM)
				dbSelectArea("STJ")
				dbSetorder(1)
				If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
					RecLock("STJ",.F.)
					STJ->TJ_TIPORET := " "
					MsUnlock("STJ")
				Endif
			Else
				dbSelectArea("STJ")
				dbSetorder(1)
				If dbSeek(xFilial("STJ")+SD1->D1_ORDEM)
					RecLock("STJ",.F.)
					STJ->TJ_TIPORET := "S"
					MsUnlock("STJ")
				Endif
			Endif
			RestArea(aOldArea)
		Endif
	Endif
Endif
DbSelectArea("SD1")

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGGARANSD1³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inclusao de garantia do produto utilizado na manutencao     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Integracao de entrada das NF com SIGAMNT                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Obs.      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGGARANSD1(cAliasTPZ)
Local nOPGA2 := 0, lQTDCON := .F.
Local nORDEM  := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ORDEM" })
Local nCODIDO := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_COD" })
Local nITEM   := aSCAN(aHEADER,{|x| TRIM(UPPER(x[2])) == "D1_ITEM" })
Private  nQtde  := 0, nQtdeC := 0,cUni   := " ",cCont := " "
DEFAULT cAliasTPZ := "TRBTPZ"

If ExistBlock("NGGARESSD1")
   ExecBlock("NGGARESSD1",.F.,.F.)
Else
   If M->D1_GARANTI = "S" .And. (Empty(acols[n][nORDEM]) .Or. Empty(acols[n][nCODIDO]))
      MsgInfo(STR0067,STR0068) //"Para informar a garantia é necessário informar a ordem de serviço e código do produto."  # "NÃO CONFORMIDADE"
      Return .F.
   EndIf

   dbSelectArea("SX3")
   dbSetOrder(2)
   If dbSeek("TPZ_QTDCON")
      lQTDCON := .T.
   EndIf

   aUni     := {" ",STR0069,STR0070,STR0020}  //"Dia"#"Semana"#"Mes"
   aCont    := {" ",STR0071,STR0072}  //"Contador 1" # "Contador 2"
   cLocaliz := Space(Len(TPS->TPS_CODLOC))
   cNomLoc  := Space(20)

   If M->D1_GARANTI = "S"

      NGIFDBSEEK("STJ",aCols[n,nORDEM],1)
      lTemCG1 := If(NGSEEK("ST9",STJ->TJ_CODBEM,1,"T9_TEMCONT") <> "N",.T.,.F.)
      lTemCG2 := If(NGIFDBSEEK("TPE",STJ->TJ_CODBEM,1,.F.),.t.,.f.)

      dbSelectArea(cAliasTPZ)
      If dbSeek(acols[n][nITEM])

         If !Empty((cAliasTPZ)->TPZ_LOCGAR)
            cLocaliz := (cAliasTPZ)->TPZ_LOCGAR
            NGDESLOC((cAliasTPZ)->TPZ_LOCGAR)
         EndIf
         cUni := " "
         nQtde := (cAliasTPZ)->TPZ_QTDGAR
         If (cAliasTPZ)->TPZ_UNIGAR == "D"
            cUni := STR0069 //"Dia"
         ElseIf (cAliasTPZ)->TPZ_UNIGAR == "S"
            cUni := STR0070 //"Semana"
         ElseIf (cAliasTPZ)->TPZ_UNIGAR == "M"
            cUni := STR0020 //"Mes"
         EndIf

         If !Empty((cAliasTPZ)->TPZ_CONGAR)
            cCont := If((cAliasTPZ)->TPZ_CONGAR == "1",STR0071,STR0072) //"Contador 1" # "Contador 2"
         EndIf
         If lQTDCON
            nQtdeC := (cAliasTPZ)->TPZ_QTDCON
         EndIf
      EndIf

      If !lQTDCON

         Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

         @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
         @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
         @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

         @ 45,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
         @ 45,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
         @ 45,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
         @ 45,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1)

         @ 60,008 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
         @ 60,040 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2)

         Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered

      Else
         Define Msdialog oDlg1 From  000,000 To 280,550 Title STR0073 Pixel  //"Garantia"

         @ 1.5,.5 To 3.5,34 LABEL STR0078 OF oDlg1 //"Localizacao"
         @ 30,008 Say Oemtoansi(STR0074) Size 47,07 Of oDlg1 Pixel  //"Local"
         @ 30,040 MsGet cLocaliz Size 38,08 Of oDlg1 Pixel Picture '@!' F3 "TPS" Valid NGDESLOC(cLocaliz)
         @ 30,100 MsGet oNomLoc Var cNomLoc Of oDlg1 Pixel Picture '@!' When .F. Size 90,08

         @ 4.0,.5 To 6.0,34 LABEL STR0073+" "+STR0079+" "+STR0080 OF oDlg1 //"Garantia"#"por"#"Tempo"
         @ 65,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
         @ 65,040 MsGet nQtde Size 38,08 Of oDlg1 Pixel Valid positivo(nQtde) Picture '@E 999,999,999'
         @ 65,100 Say Oemtoansi(STR0076) Size 47,07 Of oDlg1 Pixel  //"Unidade"
         @ 65,132 Combobox cUni Items aUni Size 40,50 OF oDLG1 Pixel Valid NGVALINGA(cUni,cCont,1,nQtde)

         @ 6.5,.5 To 8.5,34 LABEL STR0073+" "+STR0079+" "+STR0081 OF oDlg1  //"Garantia"# "por"# "Contador"
         @ 100,008 Say Oemtoansi(STR0075) Size 47,07 Of oDlg1 Pixel  //"Qde"
         @ 100,040 MsGet nQtdeC Size 38,08 Of oDlg1 Pixel  Valid positivo(nQtdeC) Picture '@E 999,999,999' When lTemCG1 .Or. lTemCG2
         @ 100,100 say OemtoAnSi(STR0077) Size 47,07 Of oDlg1 Pixel  //"Tp Contador"
         @ 100,132 Combobox cCont Items aCont Size 40,50 Of oDLG1 Pixel Valid NGVALINGA(cUni,cCont,2,nQtdeC) When lTemCG1 .Or. lTemCG2

         Activate Msdialog oDlg1 On Init EnchoiceBar(oDlg1,{||nOPGA2:=2,If(!NGVALCAMGA(nQtde,cUni,cCont,nQtdeC),nOPGA2 := 1,oDlg1:End())},{||nOPGA2:=1,oDlg1:End()}) Centered
      Endif

      If nOPGA2 == 2

         //Grava informacoes de garantia no arquivo temporario
         dbSelectArea(cAliasTPZ)
	      If dbSeek(acols[n][nITEM])
	         RecLock(cAliasTPZ,.F.)
	      Else
	         RecLock(cAliasTPZ,.T.)
	         (cAliasTPZ)->TPZ_ITEM := acols[n][nITEM]
	      EndIf
	      (cAliasTPZ)->TPZ_CODIGO := acols[n][nCODIDO]
	      (cAliasTPZ)->TPZ_LOCGAR := cLocaliz
	      (cAliasTPZ)->TPZ_ORDEM  := acols[n][nORDEM]
		   (cAliasTPZ)->TPZ_QTDGAR := nQtde
		   (cAliasTPZ)->TPZ_UNIGAR := cUni
		   If cCont == STR0071 //"Contador 1"
		      (cAliasTPZ)->TPZ_CONGAR := "1"
		   ElseIf cCont == STR0072 //"Contador 2"
		      (cAliasTPZ)->TPZ_CONGAR := "2"
		   Else
		      (cAliasTPZ)->TPZ_CONGAR := ""
		   EndIf

		   If lQTDCON
		      (cAliasTPZ)->TPZ_QTDCON := nQtdeC
		   EndIf
		   MsUnLock(cAliasTPZ)
      EndIf
   EndIf
EndIf

Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGDESLOC  ³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Consistencia para mostrar a descricao da Localizacao        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGDESLOC(cLocaliz)

dbSelectArea("TPS")
dbSetOrder(1)
If dbSeek(xFilial("TPS")+cLocaliz)
   cNomLoc := TPS->TPS_NOME
EndIf

Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGVALINGA ³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Validacao dos campos de garantia                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGVALINGA(cUni,cCont,nTipo,nQtd)

dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek("TPZ_QTDCON")
   If nTipo =2
      If Empty(cCont) .And. !Empty(nQtd)
         MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NÃO CONFORMIDADE"
         Return .f.
      EndIf
   Else
      If Empty(cUni) .And. !Empty(nQtd)
         MsgStop(STR0083,STR0068) //"Informe a unidade." #"NÃO CONFORMIDADE"
         Return .f.
      EndIf
   EndIf
Else
   If nTipo =2
      If !Empty(cUni) .And. !Empty(cCont)
         MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador." # "NÃO CONFORMIDADE"
         Return .f.
      EndIf
   Else
      If !Empty(cUni) .And. !Empty(cCont)
         MsgStop(STR0085,STR0068) // "Nao pode ter contador a garantia controlada por tempo." # "NÃO CONFORMIDADE"
         Return .f.
      EndIf
   EndIf
Endif
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGVALCAMGA³ Autor ³ Elisangela Costa      ³ Data ³03/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida todos os campos de garantia que foram informados     ³±±
±±³          ³no botao de OK                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGVALCAMGA(nQtde,cUni,cCont,nQtdeC)

dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek("TPZ_QTDCON")

   If Empty(cCont) .And. nQtdeC == 0 .And. Empty(cUni) .And. nQtde == 0
      MsgStop(STR0086,STR0068) //"Entre com as informações necessárias para gravar a garantia do insumo." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

   If Empty(cCont) .And. nQtdeC > 0
      MsgStop(STR0082,STR0068) //"Informe qual o tipo do contador." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

   If !Empty(cCont) .And. nQtdeC == 0
      MsgStop(STR0087,STR0068) //"Informe a quantidade para a garantia controlada por contador." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

   If Empty(cUni) .And. nQtde > 0
      MsgStop(STR0088,STR0068) // "Informe a unidade para a garantia controlada por tempo." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

   If !Empty(cUni) .And. nQtde == 0
      MsgStop(STR0089,STR0068) // "Informe a quantidade para a garantia controlada por tempo." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

Else

   If Empty(cCont) .And. Empty(cUni) .And. nQtde == 0
      MsgStop(STR0086,STR0068) // "Entre com as informações necessárias para gravar a garantia do insumo." # "NÃO CONFORMIDADE"
      Return .f.
   EndIf

   If nTipo =2
      If !Empty(cUni) .And. !Empty(cCont)
         MsgStop(STR0084,STR0068) //"Nao pode ter unidade a garantia controlada por contador."# "NÃO CONFORMIDADE"
         Return .f.
      EndIf
   Else
      If !Empty(cUni) .And. !Empty(cCont)
         MsgStop(STR0085,STR0068) //"Nao pode ter contador a garantia controlada por tempo." # "NÃO CONFORMIDADE"
         Return .f.
      EndIf
   EndIf

   If nQtde == 0 .And. (!Empty(cCont) .Or. !Empty(cUni))
      MsgStop(STR0090,STR0068) //""Informe a quantidade." # NÃO CONFORMIDADE"
      Return .f.
   EndIf

Endif

If  !MNT400GF(lTemCG1,lTemCG2)
   Return .f.
EndIf

Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSD1STLSCOM³ Autor ³In cio Luiz Kolling  ³ Data ³14/07/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os campos complementares do SD1 para STL              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function NGSD1STLSCOM()
Local nVP      := 0
Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
Local aESTRUT  := {}

DbSelectArea("STL")
aESTRUT := DbStruct()

RecLock("STL",.F.)
DbSelectArea("SD1")
For nVP := 1 To Fcount()
   ny := Fieldname(nVP)
   nc := "STL->TL"+Alltrim(Substr(ny,3,Len(ny)))
   cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
   If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
      If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
         nx   := "SD1->"+Fieldname(nVP)
         &nc. := &nx.
      Endif
   Endif
Next
MsUnlock("STL")
Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³NGSTLSD3SCOM³ Autor ³In cio Luiz Kolling  ³ Data ³14/07/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os campos complementares do STL para SD3 e vice versa ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Paramentro³vALIAP  - Alias do arquivo com os valores - Obrigatorio     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICO                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function NGSTLSD3SCOM(vALIAP)
Local nVP      := 0
Local cPRER    := If(vALIAP = "STL","D3","TL")
Local cALIVAL  := If(vALIAP = "STL","STL","SD3")
Local cALIREC  := If(vALIAP = "STL","SD3","STL")
Local vVETCAMN := {"_FILIAL","_NUMSEQ","_ORDEM"}
Local aESTRUT  := {}

DbSelectArea(cALIREC)
aESTRUT := DbStruct()

RecLock(cALIREC,.F.)
DbSelectArea(cALIVAL)
For nVP := 1 To Fcount()
   ny := Fieldname(nVP)
   nc := cALIREC+"->"+cPRER+Alltrim(Substr(ny,3,Len(ny)))
   cCAMPP := Alltrim(Substr(ny,3,Len(ny)))
   If Ascan(vVETCAMN, {|x| x == Alltrim(Substr(ny,3,Len(ny)))}) = 0
      If Ascan(aESTRUT, {|x| Alltrim(Substr(x[1],3,Len(x[1]))) == cCAMPP}) > 0
         nx   := cALIVAL+"->"+Fieldname(nVP)
         &nc. := &nx.
      Endif
   Endif
Next
MsUnlock(cALIREC)
Return .t.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³ ULTSEQ1  ³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Incrementa a sequencia do insumo (proxima sequencia)       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Obs.      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function UltSeq1()
Local cSEQ := "0  ",lPRIMLO := .T.
Local nSEQ := 0
OLDKEY := INDEXORD()
DbSelectArea("STL")
DbSetOrder(3)
DbSeek(xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO)

While !Eof() .And. STL->TL_FILIAL == xFILIAL('STL') .And. STL->TL_ORDEM == STJ->TJ_ORDEM;
   .And. STL->TL_PLANO == STJ->TJ_PLANO
   If lTEMSEQR
      If Val(stl->tl_seqrela) > 0
         If Val(STL->TL_SEQRELA) > Val(cSEQ)
            cSEQ := STL->TL_SEQRELA
         Endif
      Else
         If isDigit(Substr(stl->tl_seqrela,1,1))
         Else
            cSEQ := If(lPRIMLO,stl->tl_seqrela,If(stl->tl_seqrela > cSEQ,stl->tl_seqrela,cSEQ))
            lPRIMLO := .F.
         Endif
      Endif
   Endif
   nSEQ := MAX(nSEQ,STL->TL_SEQUENC)
   DbSkip()
End
DbSetOrder(1)
If lTEMSEQR
   If !lPRIMLO
      //cSEQR := PADL(Soma1(cSEQ),3)
      cSEQR := PADL(Soma1Old(cSEQ),3)
   Else
      //cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1(cSEQ),3))
      cSEQR := If(Val(cSEQ) = 0,'1',PADL(Soma1Old(cSEQ),3))
   Endif
Else
   cSEQR := If(nSEQ == 0,1,nSEQ+1)
Endif
Return cSEQR

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGSD1100E³ Autor ³ Nilton Pereira        ³ Data ³13/07/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Exclusao de insumo no registro da NFE ( ESTORNO )          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Integracao de entrada das NF com SIGAMNT                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³OBS       ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSd1100e()
Local OLDALI,CORDEM
OldAli := Alias()

If !Empty(SD1->D1_ORDEM)
   cORDEM := SD1->D1_ORDEM
   DbSelectArea("STJ")
   DbSetorder(1)

   IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
      stj->tj_termino == 'N'
      DbSelectArea("STL")
      DbSetorder(7)

      IF DbSeek(xFilial("STL")+SD1->D1_NUMSEQ)
         DbSelectArea("STN")
         DbSetorder(1)
         If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
            While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
               STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
               .And. STN->TN_SEQRELA = STL->TL_SEQRELA
               RecLock("STN",.F.)
               dbDelete()
               MSUNLOCK("STN")
               DbSkip()
            End
         EndIf
         DbSelectArea("SD1")
         If FieldPos("D1_GARANTI") > 0 .And. SD1->D1_GARANTI == "S"
            DbSelectArea("TPZ")
            DbSetOrder(2)
            cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
            If DbSeek(xfilial("TPZ")+cChaTPZ)
               While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                  TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ
                  RecLock("TPZ",.F.)
                  dbDelete()
                  MSUNLOCK("TPZ")
                  DbSkip()
               End
            EndIf
         EndIf
         DbSelectArea("STL")
         RecLock("STL",.F.)
         dbDelete()
         MSUNLOCK("STL")
      Endif

		If SD1->D1_TIPO == 'D' .And. NGCADICBASE("TL_NOTFIS","A","STL",.F.) .And. NGCADICBASE("TL_SERIE","A","STL",.F.)
			dbSelectArea("STL")
			dbSetOrder(4)
			If dbSeek(xFilial("STL")+SD1->D1_ORDEM)
				aOldArea := GetArea()
				While !Eof() .AND. STL->TL_FILIAL == xFilial("STL") .AND. STL->TL_ORDEM == SD1->D1_ORDEM
					If STL->TL_TIPOREG == "P" .AND. STL->TL_ORIGNFE == "SD1" .AND. STL->TL_ORDEM == SD1->D1_ORDEM .AND.;
						STL->TL_NOTFIS == SD1->D1_NFORI .AND. STL->TL_SERIE == SD1->D1_SERIORI

						RecLock("STL",.F.)

						nCustoNovo := (STL->TL_CUSTO/STL->TL_QUANTID)
						STL->TL_QUANTID += SD1->D1_QUANT
						STL->TL_CUSTO := nCustoNovo * STL->TL_QUANTID

						MsUnlock("STL")
					Endif
					dbSelectArea("STL")
					dbSkip()
				End
				RestArea(aOldArea)
			Else
				dbSelectArea("SD1")
				aOldArea := GetArea()
				dbSetOrder(01)
				If	dbSeek(xFilial("SD1")+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_COD)
					NGSD1GESTL(SD1->D1_ORDEM,SD1->D1_COD)
				Endif
				RestArea(aOldArea)
			Endif
		Endif

      DbSelectArea("STL")
      DbSetorder(1)

      If !DbSeek( xFilial("STJ") + cORDEM)
         DbSelectArea("STJ")
         RecLock("STJ",.F.)
         STJ->TJ_TIPORET := " "
         MsUnlock("STJ")
      Else
         RecLock("STJ",.F.)
         STJ->TJ_TIPORET := "S"
         MsUnlock("STJ")
      Endif
   Endif
Endif

DbSelectArea(OldAli)
Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³ NGSD3240I³ Autor ³ Nilton Pereira        ³ Data ³ 30/07/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Atualizacao apos a gravacao de movto. interno              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±³          ³                                                            ³±±
±±³          ³ Objetivo: Gravar a Requisicao no SIGAMNT                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function NGsd3240i(nLinha)

	Local CORDEM,LFOUND,CTIPOREG,vVDATFIM,nLinSD3 := If(nLinha = Nil .Or. nLinha = 0,1,nLinha)
	Local aTercProd := {}
	Local lTercProd := .F.
	Local cAliasTar := ""

	Private lTEMSEQR := NgVerify("STL")
	Private dDtMDO   := Ctod("  /  /  "),cHoMDO := Space(5)

	If !Empty(SD3->D3_ORDEM) .and. SubStr(SD3->D3_CF,1,2) == "RE"
		cORDEM := SD3->D3_ORDEM
		DbSelectArea("STJ")
		DbSetorder(1)

		If DbSeek(xFilial("STJ") + cORDEM)
	   		lFOUND   := .F.

			//Recebe os Produtos de Terceiros do parametro
			aTercProd := aClone(NGProdMNT("T"))
			lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(SD3->D3_COD) }) > 0)

			cTIPOREG := If(lTercProd, "T", "P")

       		If cTIPOREG = "P"
          		If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
             		While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
								STL->TL_ORDEM = STJ->TJ_ORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
						If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
							dDtMDO := STL->TL_DTINICI
							cHoMDO := STL->TL_HOINICI
							Exit
						Endif
						Dbskip()
             		End
          		Endif
	       Endif

			DbSelectArea("STL")
       		DbSetorder(7)
       		DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
       		While !Eof() .and. STL->TL_FILIAL == xFilial("STL") .and. ;
          				STL->TL_NUMSEQ == SD3->D3_NUMSEQ

          		If Trim(STL->TL_CODIGO) == Trim(SD3->D3_COD) .and. ;
             		Trim(STL->TL_ORDEM)  == cORDEM
             		lFound := .T.
             		Exit
          		Endif
          		DbSkip()
       		End

       		If !lFOUND
        		nSEQSTL := ULTSEQ1()
				DbSelectArea("STL")
				Reclock("STL",.T.)
				STL->TL_FILIAL  := xfilial('STL')
				STL->TL_ORDEM   := cORDEM
				STL->TL_PLANO   := STJ->TJ_PLANO
				STL->TL_CODIGO  := SD3->D3_COD
				STL->TL_TIPOREG := cTIPOREG
				If !Empty(SD3->D3_NUMSA)
					cAliasTar := GetNextAlias()

					BeginSQL Alias cAliasTar

						SELECT TL_TAREFA, TL_DESTINO
						FROM %table:STL%
							WHERE	TL_FILIAL = %xFilial:STL%
								AND TL_NUMSA = %exp:SD3->D3_NUMSA%
								AND TL_ITEMSA = %exp:SD3->D3_ITEMSA%
								AND %NotDel%
					EndSQL

					If (cAliasTar)->( !EoF() )
						STL->TL_TAREFA  := (cAliasTar)->TL_TAREFA
						STL->TL_DESTINO := (cAliasTar)->TL_DESTINO
					Else
						STL->TL_TAREFA  := '0'
						STL->TL_DESTINO := If(cTIPOREG = 'T',' ','A')	
					EndIf

					(cAliasTar)->( dbCloseArea() )
				Else
					STL->TL_TAREFA  := '0'
					STL->TL_DESTINO := If(cTIPOREG = 'T',' ','A')
				EndIf
          		STL->TL_USACALE := 'N'
          		STL->TL_GARANTI := 'N'
		  		If lTEMSEQR
		 	 		STL->TL_SEQRELA := nSEQSTL
	  	  		Else
		 	 		STL->TL_SEQUENC := nSEQSTL
		  		Endif
				STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD3->D3_UM)
				STL->TL_QUANTID := SD3->D3_QUANT
				STL->TL_NUMSEQ  := SD3->D3_NUMSEQ
				STL->TL_DTINICI := SD3->D3_EMISSAO
				STL->TL_HOINICI := Substr( Time(), 1, 5 )

				If cTIPOREG = "T"
					vVDATFIM := NGDTHORFIM(SD3->D3_EMISSAO,Substr( Time(), 1, 5 ),SD3->D3_QUANT)
					STL->TL_DTFIM := vVDATFIM[1]
					STL->TL_HOFIM := vVDATFIM[2]
				Else
					STL->TL_DTFIM := SD3->D3_EMISSAO
					STL->TL_HOFIM := Substr( Time(), 1, 5 )
				EndIf
				
				STL->TL_REPFIM  := 'S'
				STL->TL_CUSTO   := SD3->D3_CUSTO1
				STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

				If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
					STL->TL_DTINICI := dDtMDO
					STL->TL_HOINICI := cHoMDO
					STL->TL_DTFIM   := dDtMDO
					STL->TL_HOFIM   := cHoMDO
				Endif

				If FieldPos("TL_ORIGNFE") > 0
					STL->TL_ORIGNFE := 'SD3'
				Endif

				If FieldPos("TL_NOTFIS") > 0
					STL->TL_NOTFIS := SD3->D3_DOC
				Endif

		  		MSUNLOCK("STL")

          		NGSTLSD3SCOM("SD3")

				DbSelectArea("STJ")
				Reclock("STJ",.F.)
				STJ->TJ_TIPORET := "S"
				MsUnlock("STJ")
	   		Endif
		Endif
    	If  NGD3GARANT()  .And. SD3->D3_GARANTI = "S"
       		If Type("aMntGarant") == "A"
          		nLSD3 := Ascan(aMntGarant,{|x| x[11] = nLinSD3 })
          		If nLSD3  > 0
             		NGGRVGARAN(aMntGarant,nLSD3,STL->TL_SEQRELA)
          		EndIf
       		EndIf
		EndIf
	Endif
	DbSelectArea("SD3")

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ NGSD3240E³ Autor ³ Nilton Pereira        ³ Data ³ 04/11/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Atualizacao apos a gravacao de movto. interno ( ESTORNO )  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ OBS.:    ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function NGSd3240e()
Local OLDALI,CPLANO,CORDEM
Private lRegVir := .f.,nDifVir := 0, nACUMFIF := 0
OldAli := Alias()
If !Empty(SD3->D3_ORDEM)
   cPLANO := SUBSTR(SC2->C2_OBS,7,6)
   cORDEM := SD3->D3_ORDEM
   DbSelectArea("STJ")
   DbSetorder(1)

   IF DbSeek(xFilial("STJ") + cORDEM) .and. stj->tj_situaca == 'L' .and.;
      stj->tj_termino == 'N'
      DbSelectArea("SF5")
      DbSetorder(1)
      DbSeek(xFilial("SF5") + M->D3_TM)

      If sf5->f5_tipo == "R"
         DbSelectArea("STL")
         DbSetorder(7)

         IF DbSeek(xFilial("STL")+SD3->D3_NUMSEQ)
            DbSelectArea("STN")
            DbSetorder(1)
            If DbSeek(xFilial("STN")+STL->TL_ORDEM+STL->TL_PLANO+STL->TL_TAREFA+STL->TL_SEQRELA)
               While !Eof() .And. STN->TN_FILIAL = Xfilial("STN") .And.;
                  STN->TN_ORDEM = STL->TL_ORDEM .And. STN->TN_TAREFA = STL->TL_TAREFA;
                  .And. STN->TN_SEQRELA = STL->TL_SEQRELA
                  RecLock("STN",.F.)
                  dbDelete()
                  MSUNLOCK("STN")
                  DbSkip()
               End
            EndIf
            DbSelectArea("SD3")
            If NGCADICBASE("D3_GARANTI","A","SD3",.F.)  .And.   SD3->D3_GARANTI == "S
               DbSelectArea("TPZ")
               DbSetOrder(2)
               cChaTPZ := STJ->TJ_ORDEM+STJ->TJ_PLANO+STL->TL_SEQRELA
               If DbSeek(xfilial("TPZ")+cChaTPZ)
                  While !Eof() .And. TPZ->TPZ_FILIAL = Xfilial("TPZ") .And.;
                     TPZ->TPZ_ORDEM+TPZ->TPZ_PLANO+TPZ->TPZ_SEQREL = cChaTPZ

                     RecLock("TPZ",.F.)
                     dbDelete()
                     MSUNLOCK("TPZ")
                     DbSkip()
                  End
               EndIf
            EndIf
            DbSelectArea("STL")
            RecLock("STL",.F.)
            dbDelete()
            MSUNLOCK("STL")
         Endif

         DbSelectArea("STL")
         DbSetorder(1)

         If !DbSeek( xFilial("STJ") + cORDEM)
            DbSelectArea("STJ")
            RecLock("STJ",.F.)
            STJ->TJ_TIPORET := " "
            MsUnlock("STJ")
         Else
            DbSelectArea("STJ")
	         RecLock("STJ",.F.)
	         STJ->TJ_TIPORET := "S"
	         MsUnlock("STJ")
         Endif
      Endif
   Endif
Endif

If nModulo != 19
	DbSelectArea("SX6")
	DbSetorder(1)
	If GetNewPar("MV_NGMNTFR","N") = "S"
      nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
	   If nOrdId > 0
	      DbSelectArea("TQN")
	      DbSetorder(nOrdId)

	      If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
	         // PROCESSO COPIADO DO MNTA655

				DbSelectArea("ST9")
				DbSetOrder(16)
				If DbSeek(TQN->TQN_FROTA)
					cFilBem	:= ST9->T9_FILIAL
				EndIf
				aRetTPN := NgFilTPN(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS)
				cFilTPN := aRetTPN[1]
				If cFilTPN = " "
					cFilTPN := TQN->TQN_FILIAL
				EndIf

	         lSegCont := NGCADICBASE("TQN_POSCO2","A","TQN",.F.)

	         //Referentes ao primeiro contador
	         aARALTC := {'STP','stp->tp_filial','stp->tp_codbem',;
	                     'stp->tp_dtleitu','stp->tp_hora','stp->tp_poscont',;
	                     'stp->tp_acumcon','stp->tp_vardia','stp->tp_viracon'}
	         aARABEM := {'ST9','st9->t9_poscont','st9->t9_contacu',;
	                     'st9->t9_dtultac','st9->t9_vardia'}

	         DbSelectArea(aARALTC[1])
	         Dbsetorder(5)
	         If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
	            nRECNSTP := Recno()
	            nRECASTP := 0
	            lULTIMOP := .T.
	            nACUMFIP := 0
	            nCONTAFP := 0
	            nVARDIFP := 0
	            dDTACUFP := Ctod('  /  /  ')
	            DbSkip(-1)
	            If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
	               &(aARALTC[3]) = TQN->TQN_FROTA
	               nACUMFIP := &(aARALTC[7])
	               dDTACUFP := &(aARALTC[4])
	               nCONTAFP := &(aARALTC[6])
	               nVARDIFP := &(aARALTC[8])
	               nRECASTP := Recno()
	            Endif
	            Dbgoto(nRECNSTP)

	            nACUMDEL := stp->tp_acumcon

	            DbSelectArea(aARALTC[1])
	            RecLock(aARALTC[1],.F.)
	            Dbdelete()
	            MsUnlock(aARALTC[1])
	            MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)
	            DbSelectArea(aARALTC[1])
	            If nRECASTP > 0
	               Dbgoto(nRECASTP)
	               DbSkip()
	               If !Eof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
	                  &(aARALTC[3]) = TQN->TQN_FROTA
	               Else
	                  NGATUCONT(STP->TP_CODBEM,STP->TP_DTLEITU,STP->TP_POSCONT,;
	                            STP->TP_ACUMCON,STP->TP_VARDIA,1,.f.,.f.)
	               Endif
	            Endif
	         Endif

	          //Referentes ao segundo contador
	         If lSegCont
	            dbSelectArea("TPE")
	            dbSetOrder(1)
	            If DbSeek(If(NGSX2MODO("TPE")="E",cFilBem,xFilial("TPE"))+TQN->TQN_FROTA)
	               aARALTC := {'TPP','tpp->tpp_filial','tpp->tpp_codbem',;
	                           'tpp->tpp_dtleit','tpp->tpp_hora','tpp->tpp_poscon',;
	                           'tpp->tpp_acumco','tpp->tpp_vardia','tpp->tpp_viraco'}
	               aARABEM := {'TPE','tpe->tpe_poscon','tpe->tpe_contac',;
	                           'tpe->tpe_dtulta','tpe->tpe_vardia'}
	               DbSelectArea(aARALTC[1])
	               Dbsetorder(5)
	               If Dbseek(xFilial(aARALTC[1],cFilTPN)+TQN->TQN_FROTA+Dtos(TQN->TQN_DTABAS)+TQN->TQN_HRABAS)
	                  nRECNSTP := Recno()
	                  nRECATPP := 0
	                  lULTIMOP := .T.
	                  nACUMFIP := 0
	                  nCONTAFP := 0
	                  nVARDIFP := 0
	                  dDTACUFP := Ctod('  /  /  ')
	                  DbSkip(-1)
	                  If !Eof() .And. !Bof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
	                     &(aARALTC[3]) = TQN->TQN_FROTA
	                     nACUMFIP := &(aARALTC[7])
	                     dDTACUFP := &(aARALTC[4])
	                     nCONTAFP := &(aARALTC[6])
	                     nVARDIFP := &(aARALTC[8])
	                   Endif
	                   Dbgoto(nRECNSTP)

	                   nACUMDEL := TPP->TPP_ACUMCO

	                   DbSelectArea(aARALTC[1])
	                   RecLock(aARALTC[1],.F.)
	                   Dbdelete()
	                   MsUnlock(aARALTC[1])

	                   MNTA875ADEL(TQN->TQN_FROTA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,2,cFilTPN,cFilTPN)

	                   DbSelectArea(aARALTC[1])
	                   If nRECATPP > 0
	                      Dbgoto(nRECATPP)
	                      DbSkip()
	                      If !Eof() .And. &(aARALTC[2]) = xFilial(aARALTC[1],cFilTPN) .And.;
	                         &(aARALTC[3]) = cCodfrot
	                      Else
	                         NGATUCONT(TPP->TPP_CODBEM,TPP->TPP_DTLEIT,TPP->TPP_POSCON,;
	                                   TPP->TPP_ACUMCO,TPP->TPP_VARDIA,"2",.f.,.f.)
	                      Endif
	                   Endif
	               Endif
	            EndIf
	         EndIf
	         NGDelTTVAba(TQN->TQN_NABAST)

	         DbSelectArea("TQN")
	         RecLock("TQN",.F.)
	         Dbdelete()
	         MsUnlock("TQN")

	      Endif
	   Endif
	Endif
Endif

DbSelectArea(OldAli)
return nil

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³NGDTHORFIM³ Autor ³Inacio Luiz Kolling    ³ Data ³04/08/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Calcula a data e hora fim a partir de uma data e hora       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GENERICA                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NGDTHORFIM(dVDATI,cVHORI,nQTDHO)
Local cINI  := HTOM(cVHORI),cDAT := dVDATI
Local nHINT := Int(nQTDHO)
Local nREST := (nQTDHO-nHINT) * 100
Local cFIM  := If(GetMv("MV_NGUNIDT") = "D",cINI+(nQTDHO * 60),cINI+((nHINT * 60)+nREST))
Local nSOMA := 0

While cFIM > 1440
   nSOMA++
   cFIM -= 1440
End
dDATF  := cDAT+nSOMA
cHORAF := MTOH(cFIM)
Return {dDATF,cHORAF}

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³  HTOM    ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte horas em minutos                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Parametros -> cTime -> Horas em 99:99                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function HTOM(cTIME)
Local nHORA,nMINUTO,POS

POS := At(":",cTIME)
If POS == 0;Return 0;End
nHORA   := Val(Substr(cTIME,1,(POS-1)))
nMINUTO := Val(Substr(cTIME,(POS+1)))
Return (nHORA*60)+nMINUTO

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³  MTOH    ³ Autor ³ NG INFORMATICA        ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Converte minutos em horas                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Parametros -> nMINUTO                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MTOH(nMINUTO)
Local nHoras,nRest,cRet,cHoraC := Alltrim(Str(nMINUTO))
Local nPonVi := At(".",cHoraC)
If nPonVi = 0
   nPonVi := At(",",cHoraC)
EndIf

nHoras := INT(nMINUTO / 60)
nRest  := INT(nMINUTO % 60)

If nPonVi = 0
   nPonVi := At(",",cHoraC)
EndIf
If nPonVi > 0
   nMinuM := Val(Substr(cHoraC,nPonVi+1,1))
   If nMinuM > 5
      nRest += 1
   Endif
EndIf

cRet   := StrZero(nHoras,2) + ":" + StrZero(nRest,2)

If nHORAS > 99
   cRET := StrZero(nHoras,3) + ":" + StrZero(nRest,2)
EndIf
If nHORAS > 999
   cRet := StrZero(nHoras,4) + ":" + StrZero(nRest,2)
EndIf
If nHORAS > 9999
   cRet := StrZero(nHoras,5) + ":" + StrZero(nRest,2)
EndIf
If nHORAS > 99999
   cRet := StrZero(nHoras,6) + ":" + StrZero(nRest,2)
EndIf
Return cRET

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³GetAutoPar  ³ Autor ³ Eduardo Motta   		  ³ Data ³ 26/02/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para retornar parametros em array de rotina Automatica ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ GetAutoPar(cPar,aRotAuto,uDef)								 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cPar     - Nome do parametro          						 ³±±
±±³          ³aRotAuto - Array da rotina automatica						     ³±±
±±³          ³uDef     - Valor default do parametro, caso nao exista     	 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetAutoPar(cPar,aArray,uDef)
Local nPos := aScan(aArray,{|x|Upper(AllTrim(x[1]))==AllTrim(Upper(cPar))})
Local uRet
If nPos == 0
   uRet := uDef
Else
   uRet := aArray[nPos,2]
EndIf
Return uRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ AvalCond ³ Autor ³ Henry Fila            ³ Data ³ 14.11.03  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para avaliar condicao de pagamento 				   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpA1 := AvalCond(ExpN1,ExpC1,ExpN2,ExpD1,ExpN3,ExpA2)	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array contEndo os valores e os vencimentos de cada  ³±±
±±³			 ³ 		  parcela.											   ³±±
±±³			 ³ ExpN1 = Valor total a ser parcelado.                        ³±±
±±³			 ³ ExpC1 = Codigo da condicao de pagamento a ser considerada.  ³±±
±±³			 ³ ExpN2 = Valor do IPI destacado para condicao que obrigue o  ³±±
±±³			 ³ 		  IPI a entrar na 1a parcela.                          ³±±
±±³			 ³ ExpD1 = Data inicial para considerar desdobramento 		   ³±±
±±³			 ³ ExpN3 = Valor do ICMS Solidario                             ³±±
±±³			 ³ ExpA2 = Array contEndo a sigla e valor dos impostos calcula-³±±
±±³			 ³ 		  dos para os paises Internacionais (MercoSul...)	   ³±±
±±³			 ³ ExpA3 = Array contendo dados semelhantes ao que teria no    ³±±
±±³			 ³ 		  SE4 												   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³	MOTIVO DA ALTERACAO                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Rogerio F.G. ³18/11/97³B.HUR ³Alt Cond Pagto Tipo 9                    ³±±
±±³ Rogerio F.G. ³24/11/97³B.HUR ³Ajuste Valor Cond Pagto tipo 8           ³±±
±±³ Lucas        ³29.06.98³16770A³Adaptacao para os impostos MercoSul...   ³±±
±±³ Aline C.Vale ³13.09.99³xxxxxx³Consistencia do ultimo dia da cond. 3    ³±±
±±³ Aline C.Vale ³20.09.99³18368A³Acerto na Cond.Pgto.Tipo 7               ³±±
±±³ Aline C.Vale ³25.10.99³24332A³Tratar Junta IPI na Cond.Pgto.Tipo 8     ³±±
±±³ Sandro       ³02.03.00³xxxxxx|funcionamento sem a existencia da codicao³±±
±±³              ³        ³      |cadastrada no SE4                        ³±±
±±³Bruna Zechetti³30.12.09³      ³Ajustada a validação nos campos FB_JNS e ³±±
±±³              ³        ³      |E4_SOMSUB, para poder definir a regra de ³±±
±±³              ³        ³      |geração (se E4_SOMSUB = 2, deverá        ³±±
±±³              ³        ³      ³subtrair do valor da(s) parcelas ate     ³±±
±±³              ³        ³      |finalizar o valor de retenção do IVA).   ³±±
±±³Ivan Haponczuk³15.07.10³      ³Adicionado tratamento para localizacao   ³±±
±±³              ³        ³      |fiscal Venezuela, ajusta parcelas de     ³±±
±±³              ³        ³      |acordo com a natureza.                   ³±±
±±³Felipe Seolin ³28.07.10³      ³Adicionado tratamento para localizacao   ³±±
±±³              ³        ³      |fiscal Venezuela, pesquisa natureza com  ³±±
±±³              ³        ³      |pedido para entrada.                     ³±±
±±³Felipe Seolin ³06.08.10³      ³Adicionado tratamento para localizacao   ³±±
±±³              ³        ³      |fiscal Venezuela, ajusta valor retencao  ³±±
±±³Felipe Seolin ³09.08.10³      ³Ajuste no tratamento para localizacao    ³±±
±±³              ³        ³      |fiscal Venezuela, ajusta parcelas de     ³±±
±±³              ³        ³      |acordo com a natureza.                   ³±±
±±³Ivan Haponczuk³08.04.11³      ³Ajuste no tratamento para localizacao    ³±±
±±³              ³        ³      |fiscal Republica dominicana, ajusta      ³±±
±±³              ³        ³      |parcelas de acordo com a natureza.       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION AvalCond(nValTot,cCond,nValIpi,dData0,nValSolid,aImpVar,aE4,nAcrescimo,aDados,nInicio3,aDias3)

Local cAlias := Alias()
Local nRegSE4:=SE4->(Recno())
Local lPorcent
Local aArr
Local aElem
Local cString
Local dProx
Local nWeek
Local nDIfDay
Local i
Local j
Local x      := 0
Local nC     := 0
Local bData
Local bValor
Local aVenc  := { }
Local nDup   := 0
Local nValor := 0
Local nReg   := 0
Local cChave := ""
Local cChave1:= ""
Local nParcelas
Local cParcela
Local nValPed	:= 0
Local nDias
Local n
Local nValor9    := 0
Local nX         := 0
Local lVista     := .f.
Local lEntrada   := .f.

Local nDIf:=0
Local aTipo3     := {}
Local nAux3

Local lPVista    := .F.
Local aTP8       := {}
Local aCondEsp3  := {}
Local nValTp8    := 0

Local cE4_CODIGO := aDados[1] //SE4->E4_CODIGO
Local cE4_COND	 := aDados[2] //SE4->E4_COND
Local cE4_TIPO	 := aDados[3] //SE4->E4_TIPO
Local cE4_DDD	 := aDados[4] //SE4->E4_DDD
Local cE4_IPI	 := aDados[5] //SE4->E4_IPI
Local cE4_SOLID	 := aDados[6] //SE4->E4_SOLID
Local cE4_ACRES  := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
Local nMaxTipo9  := 26
Local cMv1Dup    := ""
Local aVencTlp   := {}

Local nVlrParc   := 0
Local nVlrAcum1  := 0
Local nLoop      := 0
Local nValDup    := nValTot
Local nSomaTp9   := 0
Local nAuxC
Local aTipoC     := {}
LOCAL nDia       := 0
LOCAL nMes       := 0
LOCAL nAno       := 0
LOCAL dVenc      := CTOD('  /  /  ')
LOCAL nContA     := 0
LOCAL nContB     := 0
LOCAL nDtVenc
Local dDiaAnt	 := CTOD('  /  /  ')	// Armazena o dia que foi utilizado anteriormente
Local nDiaValid	 := 0					// Guarda o ultimo dia valido do mes
Local nlRetIVA	:= 0
Local nlRIVA	:= 0
Local clTpCF	 := ""
Local llAgRet	 := .F.
Local nlVlrIVA	:= 0
Local nlBaseIVA	:= 0
Local nlAlqIVA	:= 0
Local cAux
Local clAgen	:= GetMV("MV_AGENTE")
Local clNaturez := ""
local ccdnat    := ""
Local cImpRet	 := ""
Local nValImp    := 0
Local nValRetImp := 0
Local nlRImp	 := 0
Local nTotRet	 := 0
Local nlPosImp	 := 0
Local nlValAux	 := 0
Local lXFis		 := .F.
Local clCodTes   := ""
Local clPedido   := ""
Local lFinc021 := IsInCallStack("FINC021")
Local nContParc  := 1
Local cCpoParc   := ""
Local nValParc   := 0
Local dDtParc    := cToD("//")
DEFAULT nAcrescimo := 0
DEFAULT aDias3     := {}

If __lCndTipo3 == NIL
	__lCndTipo3 := SuperGetMv("MV_CNDTP3",.F.,.F.)
EndIf

If __lIPI == NIL
	__lIPI       := (GetMV("MV_IPITP9") == "S")
EndIf

If __lDiaCont == NIL
	__lDiaCont   := (SuperGetMv("MV_DIACONT",.F.,"1") == "1") //Considera o dia atual no calculo
EndIf

If __cCalcImpV == NIL
	__cCalcImpV  := GetMV("MV_GERIMPV")
EndIf
If __cMv_Agente == NIL
	__cMv_Agente := SuperGetMV("MV_AGENTE")
EndIf
If __nTamE1Valor == NIL
	__nTamE1Valor := TamSX3( "E1_VALOR"  )[2]
EndIf
If __ProcName == NIL
	__ProcName := ProcName(1)
EndIf
lXFis			:= (MaFisFound() .And. __ProcName<>"EXECBLOCK")

If cPaisLoc == 'COL'

	aAreaSFC	 := GetArea()
	dbSelectArea("SFC")
	dbSetOrder(2)
	dbSeek(xFilial("SFC") + SF4->F4_CODIGO)
	cCodigo:=SF4->F4_CODIGO
	If !lXFis
		While !(SFC->(Eof())) .And. cCodigo==SFC->FC_TES
				clCodTes := SF4->F4_CODIGO
				//dbSelectArea("SFC")
				//dbSetOrder(2)
				If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV0") //Retenção IVA
						cImpRet		:= SFC->FC_IMPOSTO
						nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RV0"})
						If nlPosImp	> 0
							nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
						EndIf

						If cModulo $ "FAT"
							clTpCF	:= SA1->A1_TPESSOA
							llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
						ElseIf cModulo $ "COM"
							clTpCF	:= SA2->A2_TPESSOA
						EndIf

				Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RF0" )//Retenção TIMBRE
						cImpRet		:= SFC->FC_IMPOSTO
						nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RF0"})
						If nlPosImp	> 0
							nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
						EndIf

						If cModulo $ "FAT"
							clTpCF	:= SA1->A1_TPESSOA
							llAgRet	:= Iif(SA1->A1_RETFUEN == 'S',.T.,.F.)
						ElseIf cModulo $ "COM"
							clTpCF	:= SA2->A2_TPESSOA
							llAgRet	:= Iif(SubStr(__cMv_Agente,3,1) == 'S',.T.,.F.)
						EndIf

				Elseif dbSeek(xFilial("SFC") + SF4->F4_CODIGO +  "RC0" )//Retenção ICA
						cImpRet		:= SFC->FC_IMPOSTO
						nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == "RC0"})
						If nlPosImp	> 0
							nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
						EndIf

						If cModulo $ "FAT"
							clTpCF	:= Iif(SA1->A1_TIPO<>'3','1','0')
							llAgRet	:= Iif(SA1->A1_RETICA == 'S',.T.,.F.)
						ElseIf cModulo $ "COM"
							clTpCF	:= Iif(SA2->A2_TIPO<>'3','1','0')
							llAgRet	:= Iif(SubStr(__cMv_Agente,2,1) == 'S',.T.,.F.)
						EndIf
				EndIf
			SFC->(DbSkip())
			EndDo
	ElseIf TYPE("acols") <> "U"
		clCodTes := SF4->F4_CODIGO
		SFB->(DbSeek(xFilial("SFB")+"RV0"))
		For nx:=1 to Len(acols)
			nPospd:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_TES"} )
			If nPospd==0
				nPospd:= aScan(aHeader,{|x| AllTrim(x[2]) == "D2_TES"} )
			EndIf
			If nPospd==0 //para pedidos de venta
				nPospd := aScan(aHeader,{|x| AllTrim(x[2]) == "C6_TES"} )
			EndIf
			If nPospd==0 //para pedidos de compra
				nPospd := aScan(aHeader,{|x| AllTrim(x[2]) == "C7_TES"} )
			EndIf

			If !acols[nx][Len(acols[1])] .And. !Empty(acols[nx][nPospd])
				If MsSeek(xFilial("SFC") + MaFisRet(Nx,"IT_TES")+ "RV0") //Retenção IVA
						SFB->(DbSeek(xFilial("SFB")+"RV0"))
						cImpRet		:= SFC->FC_IMPOSTO
						If SFC->FC_INCDUPL == '2'
							nValRetImp 	:= nValRetImp + (MaFisRet(Nx,"IT_VALIV2") )
						ElseIf SFC->FC_INCDUPL == '1'
							nValRetImp 	:= nValRetImp - (MaFisRet(Nx,"IT_VALIV2") )
						EndIf

						cJNs:=SFB->FB_JNS

				EndIf
				If MsSeek(xFilial("SFC") + MaFisRet(Nx,"IT_TES")+ "RF0") //Retenção TIMBRE
						SFB->(DbSeek(xFilial("SFB")+"RF0"))
						cImpRet		:= SFC->FC_IMPOSTO

						If SFC->FC_INCDUPL == '2'
							nValRetImp 	:= nValRetImp + (MaFisRet(Nx,"IT_VALIV4") )
						ElseIf SFC->FC_INCDUPL == '1'
							nValRetImp 	:= nValRetImp - (MaFisRet(Nx,"IT_VALIV4") )
						EndIf
				EndIf
				If MsSeek(xFilial("SFC")+ MaFisRet(Nx,"IT_TES")+ "RC0") //Retenção ICA
						SFB->(DbSeek(xFilial("SFB")+"RC0"))

						cImpRet		:= SFC->FC_IMPOSTO

						If SFC->FC_INCDUPL == '2'
							nValRetImp 	:= nValRetImp + (MaFisRet(Nx,"IT_VALIV7") )
						ElseIf SFC->FC_INCDUPL == '1'
							nValRetImp 	:= nValRetImp - (MaFisRet(Nx,"IT_VALIV7") )
						EndIf
				EndIf
			EndIf
		Next
	EndIf
	RestArea(aAreaSFC)

EndIf
If cPaisLoc == 'EQU'
	If !lXFis
		clCodTes := SF4->F4_CODIGO
		dbSelectArea("SFC")
		dbSetOrder(2)
		If dbSeek(xFilial("SFC") + SF4->F4_CODIGO + "RV") //Retenção IVA
			cAux:=Substr(FC_IMPOSTO,1,2)
			While SFC->FC_FILIAL==xFilial("SFC") .And. SFC->FC_TES==SF4->F4_CODIGO .And. cAux=="RV"
				cImpRet		:= SFC->FC_IMPOSTO
				nlPosImp	:= aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
				If nlPosImp	> 0
					nValRetImp 	:= Round(aImpVar[nlPosImp,2],2)
				EndIf
			    DbSkip()
				cAux:=Substr(FC_IMPOSTO,1,2)
			Enddo
			If cModulo $ "FAT"
				llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
			EndIf
			If cModulo $ "FAT"
				clTpCF := SA1->A1_AGENRET
			ElseIf cModulo $ "COM"
				clTpCF := iif (SubStr(__cMv_Agente,1,1)=="S","1","0")
			EndIf

		EndIf
	Else
		clCodTes := MaFisRet(N,"IT_TES")
		dbSelectArea("SFC")
		dbSetOrder(2)
		If dbSeek(xFilial("SFC") +  clCodTes + "RV") //Retenção IVA
			cAux:=Substr(FC_IMPOSTO,1,2)
			While FC_FILIAL==xFilial("SFC") .And. FC_TES==clCodTes .And. cAux=="RV"
				cImpRet		:= SFC->FC_IMPOSTO
				nValRetImp 	:= Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
			    DbSkip()
				cAux:=Substr(FC_IMPOSTO,1,2)
			Enddo
			If cModulo $ "FAT"
				llAgRet	:= Iif(SA1->A1_AGENRET == '1',.T.,.F.)
			EndIf
			If cModulo $ "FAT"
				clTpCF := SA1->A1_AGENRET
			ElseIf cModulo $ "COM"
				clTpCF := iif (SubStr(clAgen,1,1)=="S","1","0")
			EndIf
		EndIf
	Endif
EndIf

If cPaisLoc == "DOM"
	dbSelectArea("SFC")
	SFC->(dbSetOrder(2))
	If SFC->(dbSeek(xFilial("SFC")+SF4->F4_CODIGO))
		Do While SFC->FC_FILIAL == xFilial("SFC") .and. SFC->FC_TES == SF4->F4_CODIGO .and. SFC->(!EOF())
			If SFC->FC_INCDUPL <> "3"
				If !lXFis
					nlPosImp := aScan(aImpVar,{|x| Alltrim(x[1]) == SFC->FC_IMPOSTO})
					If nlPosImp	> 0
						nValImp += Round(aImpVar[nlPosImp,2],2)
					EndIf
				Else
					dbSelectArea("SFB")
					SFB->(dbSetOrder(1))
					If SFB->(dbSeek(xFilial("SFB")+SFC->FC_IMPOSTO))
						nValImp += Round(MaFisRet(,"NF_VALIV"+SFB->FB_CPOLVRO),2)
					EndIf
				EndIf
			EndIf
			SFC->(dbSkip())
		EndDo
	EndIf
EndIf

If aE4 <> NIL
   cE4_CODIGO 	:= aE4[1]
   cE4_COND		:= aE4[2]
   cE4_TIPO		:= aE4[3]
   cE4_DDD 		:= aE4[4]
   cE4_IPI		:= aE4[5]
   cE4_SOLID	:= aE4[6]
   If Len(aE4) >= 7
	   cE4_ACRES    := aE4[7]
   EndIf
Endif
If dData0 == NIL
	dData0 := dDataBase
EndIf

If aImpVar == NIL
	aImpVar := {}
EndIf

nValSolid := Iif(nValSolid == Nil,0,nValSolid)
aElem:=aArr:={ }
nValIpi:=Iif(nValIpi==NIL,0,nValIpi)

DbSelectArea("SE4")
dbSetOrder(1)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Somente dar o seek se o registro corrente for != do desejado. 	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (cE4_CODIGO != cCond .Or. Empty(cE4_CODIGO)) .and. aE4 == NIL
	DbSeek(cFilial+cCond)
	If !Found() .Or. (cCond == "CN" .and. lLoja)
		nDup := 1
		dProx := dData0
		AADD(aVenc,{ dProx , nValTot })
		DbGoTo(nRegSE4)
		Return(aVenc)
	EndIf

   cE4_CODIGO 	:= SE4->E4_CODIGO
   cE4_COND		:= SE4->E4_COND
   cE4_TIPO		:= SE4->E4_TIPO
   cE4_DDD 		:= SE4->E4_DDD
   cE4_IPI		:= SE4->E4_IPI
   cE4_SOLID	:= SE4->E4_SOLID
    cE4_ACRES   := IIf(SE4->(FieldPos("E4_ACRES"))<>0,SE4->E4_ACRES,"N")
EndIf

cString:=cE4_COND

While Len(cString) > 0
	AADD(aElem,Parse(@cString))
End

aArr := aClone( aElem )

FOR i:=1 TO Len(aArr)
	aArr[i]:=Val(aArr[i])
	If aArr[i] == 0
		lPVista := .T.
	EndIf
Next

If cE4_TIPO == "3" .And. Len(aDias3) > 0

	Aadd(aCondEsp3,aArr[1])
	Aadd(aCondEsp3,If(Type("nInicio3") == "U",aArr[2],nInicio3))
	For nX := 1 to Len(aDias3)
		Aadd(aCondEsp3,aDias3[nX])
	Next
	aArr := aCondEsp3

Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para o campo E4_DDD												  ³
//³	  D = Data do dia 															  ³
//³	  L = Fora o dia																  ³
//³	  S = Fora a semana															  ³
//³	  Z = Fora a dezena															  ³
//³	  Q = Fora a quinzena														  ³
//³	  F = Fora o mes																  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cE4_TIPO <> "9" .And.;
	cE4_TIPO <> "7"
	If cE4_DDD $ "D "
		dProx := dData0
	ElseIf cE4_DDD == "L"
		dProx   := dData0 + 1
	ElseIf cE4_DDD == "S"
		nDias   := Dow(dData0)
		If nDias == 7						  // Sabado
			dProx := dData0 + 1
		ElseIf nDias == 6 				  // Sexta
			dProx := dData0 + 2
		ElseIf nDias == 5 				  // Quinta
			dProx := dData0 + 3
		ElseIf nDias == 4 				  // Quarta
			dProx := dData0 + 4
		ElseIf nDias == 3 				  // Terca
			dProx := dData0 + 5
		ElseIf nDias == 2 				  // Segunda
			dProx := dData0 + 6
		ElseIf nDias == 1 				  // Domingo
			dProx := dData0 + 7
		EndIf
	ElseIf cE4_DDD == "Z"
		nDia := day(dData0)
		nMes := month(dData0)
		nAno := year(dData0)
		If nDia >= 01 .And. nDia <= 10
			nDia := 11
		ElseIf nDia >= 11 .And. nDia <= 20
			nDia := 21
		Else
			nDia := 01
			nMes := nMes + 1
		EndIf

		If nMes == 13
			nMes := 01
			nAno := nAno + 1
		EndIf
		nDia	  := strzero(nDia,2)
		nMes	  := strzero(nMes,2)
		nAno	  := substr(lTrim(str(nAno)),3,2)
		dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
	ElseIf cE4_DDD == "Q"
		nMes := month(dData0)
		nAno := year (dData0)
		If day(dData0) > 15
			nDia := 01
			nMes		:= nMes + 1
		Else
			nDia := 16
		EndIf
		If nMes == 13
			nMes		:= 01
			nAno := nAno + 1
		EndIf
		nDia	  := strzero(nDia,2)
		nMes	  := strzero(nMes,2)
		nAno	  := substr(lTrim(str(nAno)),3,2)
		dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
	ElseIf cE4_DDD == "F"
		nDia := 01
		nMes := month(dData0) + 1
		nAno := year (dData0)
		If nMes == 13
			nMes		:= 01
			nAno := nAno + 1
		EndIf
		nDia	  := strzero(nDia,2)
		nMes	  := strzero(nMes,2)
		nAno	  := substr(lTrim(str(nAno)),3,2)
		dProx   := CtoD(nDia+"/"+nMes+"/"+nAno,"ddmmyy")
	EndIf
Else
	dProx := dData0
EndIf

If cE4_TIPO == "1"
	For i:= 1 TO Len(aArr)
		If __lDiaCont
			If ( aArr[i] > 0 )
				aArr[i] -= 1
			EndIf
		Endif
		AADD(aVenc,{ dProx + aArr[i], 0 })
	Next i
ElseIf cE4_TIPO == "2"
	For i:= 1 TO Val(Subs(cCond,2,1))
		If i == 1
			dProx += (Val(cE4_COND) * Val(Subs(cCond,1,1)))
		Else
			dProx += (Val(cE4_COND) * Val(Subs(cCond,3,1)))
		EndIf
		AADD(aVenc,{ dProx , 0 })
	Next i
ElseIf cE4_TIPO == "3"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Dados do Array - aArr								³
	//³	[1] - Numero de duplicatas a gerar					³
	//³	[2] - Intervalo entre as duplicatas 				³
	//³	[3]...[n] - Dias possiveis de vencimento no mes     ³
	//³		Obs. : Se o primeiro vencto for 00, a primeira  ³
	//³				 duplicata sera a vista, caso haja 00 nos³
	//³				 nos outros venctos sera desconsiderado. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

    nDtVenc := aArr[3]

	If aArr[3] == 00				// Primeira parcela a vista
		If __lCndTipo3 .And. Len(aDias3) == 0
	  		aArr[3] := Day(dProx)
	  		nAux3    := 3
		Else
			nAux3 := 4
			lVista:= .T.
		Endif
	Else
		nAux3 := 3
	EndIf

	For n := nAux3 To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
		If aArr[n] != 00
			Aadd(aTipo3,aArr[n])
		EndIf
	Next n

	If Len(aTipo3) != 0
		aTipo3 := aSort(aTipo3)		//  Colocar em ordem crescente de vencimentos
		For i := 1 to aArr[1]
			If !lVista
				If i == 1
					dProx += aArr[2]
				Else
					dDiaAnt	:= dProx
					dProx ++
					dProx	:= If(Day(dProx)>30,dProx+1,dProx)
				EndIf
				nDia := Day(dProx)
				nMes := Month(dProx)
				nAno := Year(dProx)

				If nDtVenc <> 00 .or. i <> 1
					For n := 1 to Len(aTipo3)
						If nDia <= aTipo3[n]
							nDia		:= aTipo3[n]
							nDiaValid 	:= nDia
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Caso seja seja zero o dia de vencimento, valida se a diferenca entre a nova data ³
							//³e a antiga eh maior que 1 , isso por que no caso de vencimentos iniciado 31/01   ³
							//³com o intervalo de 30 dias , sera da seguinte forma ( 31/01 , 02/03 , 31/03 )    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
								nDiaValid := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
							EndIf
							If nDtVenc <> 0 .OR. (nDtVenc == 0 .AND.;
									CTOD(StrZero(nDiaValid,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy") - dDiaAnt > 1 )
								lEntrada:=.T.
							EndIf
							Exit
						EndIf
					Next n
					If !lEntrada
						nDia := aTipo3[1]
						nMes := Iif((nMes+1) > 12,1 ,nMes+1)
						nAno := Iif( nMes == 1, (nAno+1), nAno)
					EndIf
				Endif
			Else
				lVista := .F.
				nDia := Day(dProx)
				nMes := Month(dProx)
				nAno := Year(dProx)
			EndIf
			If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
				nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
			EndIf

			dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")

			AADD(aVenc, { dProx , 0 } )
			lEntrada := .F.
		Next i
	Else
		For i:=1 To aArr[1]
			nDia := Day(dProx)
			nMes := Month(dProx)
			nAno := Year(dProx)
			If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
				nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
			EndIf
			dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
			AADD(aVenc, { dProx , 0 } )
			dProx+=aArr[2]
		Next i
	EndIf
ElseIf cE4_TIPO == "4"
	For i:=1 To aArr[1]
		dProx   += aArr[2]
		For x:=1 to 7
			If Dow(dProx) == aArr[3]
				Exit
			EndIf
			dProx++
		Next i
		AADD(aVenc,{ (dProx), 0 } )
	Next i
ElseIf cE4_TIPO == "5"
	If Len(aArr) == 3 .And. !lFinc021
		For i:= 1 TO aArr[2] //Val(Subs(cCond,2,1))
			If i == 1
				dProx += aArr[1]
			Else
				dProx += aArr[3]
			EndIf
			AADD(aVenc,{ dProx , 0 })
		Next i
	Else
		AADD(aVenc,{ dData0 , 0 })
	EndIf
ElseIf cE4_TIPO == "6"
	For i:=1 To aArr[1]
		If i==1
			dProx += aArr[2]
		Else
			dProx   += aArr[4]
		EndIf
		For x:=1 to 7
			If DOW(dProx) == aArr[3]
				Exit
			EndIf
			dProx++
		Next x
		AADD(aVenc,{ (dProx), 0 } )
	Next i
ElseIf cE4_TIPO == "7"
	// Descricao da Condicao de Pagamento Tipo 7
	// Cadastrar na Condicao 13 parametros separados por virgula onde o sistema
	// ira considerar o 1o parametro como o numero de parcelas e os outros 12
	// como as datas fixas de vencimento referente ao mes, ex.:
	// 10,1,2,3,4,5,6,7,8,9,10,11,12 (serao 10 parcelas com vencimento no dia
	// referente ao mes, ou seja o mes 4 vai vencer no dia 4)
	nDia := Day( dData0 )
	nMes := Month( dData0 )
	nAno := Year( dData0 )
	If cE4_DDD == "F"  //Fora o mes
		nMes ++
		nAno := If(nMes > 12, nAno+1, nAno)
		nMes := If(nMes>12,1,nMes)
	EndIf
	If cE4_DDD == "Q"  //Fora a quinzena
		If day(dData0) > 15
			nDia := 01
			nMes := nMes + 1
		Else
			nDia := 16
		EndIf
		If nMes == 13
			nMes := 01
			nAno := nAno + 1
		EndIf
	EndIf
	While Len(aVenc) < aArr[1]  //Numero de Parcelas
		If (Len( aArr ) # 13)
			aAdd( aVenc,{ dData0,0 } )
			Exit
		EndIf
		nDia := aArr[nMes+1]
		If !Empty(aArr[nMes+1])
			If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
				nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
			EndIf
			If !lFinc021
				dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
			EndIf
			If funname()== "FINC021"
				If lFinc021
					dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
				EndIf
			Endif
			If dProx >= dData0
				AADD(aVenc, { dProx , 0 } )
			EndIf
		EndIf
		nMes ++
		If (nMes > 12)
			nAno++
			nMes := 1
		EndIf
	End
ElseIf cE4_TIPO == "8"
	aTP8:=ArrayTP8(cE4_COND)
	If cE4_IPI == "J"
		nValTot -= nValIPI
	EndIf
	For i := 1 to Len(aTP8)
		AAdd(aVenc,{dProx+aTP8[i][1],Round((nValTot/100)*aTP8[i][2],2)})
		nValTp8 += Round((nValTot/100)*aTP8[i][2],2)
	Next i
	If cE4_IPI == "J"
		aVenc[1][2] += nValIPI
		nValTp8 += nValIPI
		nValTot += nValIPI
	EndIf
	If nValTp8 != nValTot
		aVenc[Len(aVenc)][2] += Round(nValTot - nValTp8,2)
	EndIf
ElseIf cE4_TIPO == "9"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se pode estender a tipo 9 ate 36 parcelas                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cMv1Dup := GetMV( "MV_1DUP" )
	If Len( cMv1Dup ) > 1 .And. Len( cMv1Dup ) == Len( SE1->E1_PARCELA )
		nMaxTipo9 := 36
	EndIf

	cParcela  := "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0"
	nParcelas := GETMV("MV_NUMPARC")
	cChave := "C5_DATA"+Subs(cParcela,nParcelas,1)
	cChave1:= "C5_PARC"+Subs(cParcela,nParcelas,1)
	DbSelectArea("SX3")
	nReg := Recno()
	DbSetOrder(2)
	If nParcelas > 4
		If !DbSeek(cChave) .or. !DbSeek(cChave1)
			nParcelas := 4
		EndIf
	Else
		nParcelas := 4
	EndIf
	DbSetOrder(1)
	If !Empty (cAlias)
		DbSelectArea(cAlias)
	Endif
	
	bData := { |x| "C5_DATA" + x }
	bValor:= { |x| "C5_PARC" + x }		

	nValPed := 0
	// Valor Total das Parcelas
	For i:= 1 to nParcelas
		cCpoParc := ""
		If cPaisLoc <> "BRA" .And. i > 36
			cCpoParc := StrZero(nContParc,2)
			nContParc++
		Else
			cCpoParc := Substr(cParcela,i,1)
		EndIf 
		If SC5->(ColumnPos("C5_PARC" + cCpoParc)) > 0
			nValPed += SC5->&(EVAL(bValor,cCpoParc))
		EndIf
	Next i

	If Trim(cE4_COND) == "0"
		// VerIfica se IPI ja esta nas parcelas
		If !__lIPI ; nValtot-= nValIPI ; EndIf
	EndIf
	nContParc := 1
	For i:= 1 to nParcelas
		cCpoParc := ""
		If cPaisLoc <> "BRA" .And. i > 36
			cCpoParc := StrZero(nContParc,2)
			nContParc++
		Else
			cCpoParc := Substr(cParcela,i,1)
		EndIf 
		If SC5->(ColumnPos("C5_PARC" + cCpoParc)) > 0
			nValParc := SC5->&(EVAL(bValor,cCpoParc))
		EndIf
		If SC5->(ColumnPos("C5_DATA" + cCpoParc)) > 0
			dDtParc := SC5->&(EVAL(bData,cCpoParc))
		EndIf
		If !Empty(dDtParc) .And. !Empty(nValParc)
			If Trim(cE4_COND) == "%"
				If i == 1
					If cE4_IPI == "J"
						nSomaTp9 := nValIPI
						nValTot -= nValIPI
					EndIf
					If cE4_SOLID == "J"
						nSomaTp9 += nValSolid
						nValTot -= nValSolid
					EndIf
					If cE4_ACRES == "J"
						nSomaTp9 += nAcrescimo
						nValTot  -= nAcrescimo
					EndIf
				Else
					nSomaTp9 := 0
				EndIf
				If nValPed > 100
					nValor := nValTot * (((nValParc/nValPed)*100) / 100 )
				Else
					nValor := nValTot * (nValParc / 100 )
				EndIf
				nValor += nSomaTp9
			Else
				// achar o % referente ao valor
				nValor := nValParc / nValPed
				nValor := nValTot * nValor
				// os quant. presentes em C5_PARCn referem-se a valores
				nValor := IIf(Abs(nValor - nValParc ) <= 1, nValParc, nValor)
			EndIf
			AADD(aVenc,{ dDtParc, nValor } )
		EndIf
	Next i
ElseIf cE4_TIPO == "C"
	If aArr[1] <> 0				// Primeira parcela a vista
		If Len(aDias3) == 0
	  		nAuxC := 1
		Else
			nAuxC := 2
			lVista := .T.
		Endif
	Else
		nAuxC := 1
	EndIf

	For n:=nAuxC To Len(aArr)	// Elimino a parcela 00 e crio array dos possiveis dias vencto
		If Day(dDataBase) != 00
			Aadd(aTipoC,Day(dDataBase))
		EndIf
	Next n

	If Len(aTipoC) != 0
		aTipoC:= aSort(aTipoC)		//  Colocar em ordem crescente de vencimentos
		For i:=1 to aArr[1]
			If !lVista
				If i == 1
					dProx+= 0
				Else
					dProx:= If(Day(dProx)>30,dProx+1,dProx)
				EndIf
				nDia:= Day(dProx)
				nMes:= Month(dProx)
				nAno:= Year(dProx)
				If !lEntrada
					If i <> 1
						nDia := nDia
						nMes := Iif((nMes+1) > 12,1 ,nMes+1)
						nAno := Iif( nMes == 1, (nAno+1), nAno)
						lEntrada:= .F.
					EndIf
				EndIf
			Else
				lVista := .F.
				nDia := Day(dProx)
				nMes := Month(dProx)
				nAno := Year(dProx)
			EndIf
			If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
				nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
			EndIf
			dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
			AADD(aVenc, { dProx , 0 } )
			lEntrada := .F.
		Next i
	Else
		For i:=1 To aArr[1]
			nDia := Day(dProx)
			nMes := Month(dProx)
			nAno := Year(dProx)
			If nDia > Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
				nDia := Day(LastDay(CTOD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")))
			EndIf
			dProx := CTOD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4),"ddmmyy")
			AADD(aVenc, { dProx , 0 } )
			dProx+=0
		Next i
	EndIf
ELSEIF cE4_TIPO == 'D'
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Os campos do E4_COND, separados por Virgulas, correspondem ³
	//³ aos Meses dos Vencimentos, a partir da Data de Emissao.    ³
	//³ Ex.: Na Emissao em 30/05/07 e E4_COND = '0,2,3,4' os Ven-  ³
	//³ cimentos serao: 30/05, 30/07, 30/08 e 30/09 de 2007.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	FOR nContA := 1 TO LEN(aArr)
		nDia := DAY(dProx)
		nMes := MONTH(dProx)
		nAno := YEAR(dProx)
		FOR nContB := 1 TO aArr[nContA]
			nAno := nAno+IIF(nMes==12,1,0)
			nMes := IIF(nMes==12,1,nMes+1)
		NEXT nContB
		IF !EMPTY(CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))
			dVenc := CTOD(STRZERO(nDia,2)+'/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy')
		ELSE
			dVenc := LASTDAY(CTOD('01/'+STRZERO(nMes,2)+'/'+STRZERO(nAno,4),'ddmmyy'))+1
		ENDIF
		AADD(aVenc,{dVenc,0})
	NEXT nContA
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³		Desdobramento dos valores baseado no numero de duplicatas	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nDup:=Len(aVenc)

If !(cE4_TIPO $ "89A")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Desdobrar valores dos impostos variaveis baseando se campo FB_JNS ³
	//³ de cada imposto correspondente. 											 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄLucasÄÙ
	If __cCalcImpV == "S" .And. Len(aImpVar) > 0

		nIniLoop := 1

		For nC := 1 To Len(aImpVar)
			SFB->( DbSetOrder(1) )
			SFB->( DbSeek( xFilial("SFB")+AllTrim(aImpVar[nC][1])) )

			If SFB->FB_JNS $ "JS" .And. cPaisLoc <> 'COL'
				aVenc[1][2] := If( nC==1,aImpVar[nC][2],aVenc[1][2] + aImpVar[nC][2] )
				nValTot -= aImpVar[nC][2]
				nIniLoop := 2
			EndIf
			If cE4_ACRES $ "JS"
				aVenc[1][2] := nAcrescimo
				nValTot     -= nAcrescimo
				nIniLoop    := 2
			ElseIf cE4_ACRES $ "V" .And. lPVista
				nValTot     -= nAcrescimo
			EndIf

			If !("S" $ SFB->FB_JNS + cE4_ACRES)
				nIniLoop := 1
			EndIf
		Next nC

		If nIniLoop == 2
			nValor := Round( nValTot / (nDup-1) ,2 )
		Else
			nValor := Round( nValTot / nDup ,2 )
		EndIf


	    If llAgRet
			nlRImp	:= nValRetImp
		EndIf
		For i := nIniLoop TO nDup

			If nlRImp > 0 .And. cPaisLoc == 'COL'
				If SFB->FB_JNS == 'J'
					dbSelectArea("SFC")
					dbSetOrder(2)
					If  !lxFis .and.dbSeek(xFilial("SFC") + clCodTes + cImpRet)
						Do Case
							Case FC_INCDUPL == '2' //.And. FC_INCNOTA <> '2'
								nValRetImp := nValor - nlRImp
								If nValRetImp >= 0
									aVenc[i][2] += Round(nValRetImp,2)
									nlRImp	:= 0
								Else
									aVenc[i][2] += 0
									nlRImp	:= Round((nValRetImp * (-1)),2)
								EndIf
							Case FC_INCDUPL == '1'
								aVenc[i][2] += Round(nValor + nlRImp,2)
								nlRImp	:= 0
							Otherwise
								aVenc[i][2] += Round(nValor,2)
								nlRImp	:= 0
						EndCase
					Else
						If nValRetImp <> 0
							aVenc[i][2] += Round(nValRetImp,2)
							nlRImp	:= 0
						Else
							aVenc[i][2] += 0
							nlRImp	:= Round((nValRetImp * (-1)),2)
						EndIf
					EndIf
				EndIf
			elseIf nlRImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
				dbselectarea("SED")
				SED->(Dbsetorder(1))
				dbSeek(xFilial("SED") + SC5->C5_NATUREZ)
				dbSelectArea("SFC")
				dbSetOrder(2)
				If dbSeek(xFilial("SFC") + clCodTes + cImpRet)
					Do Case
						Case SED->ED_RATRET == '1'
							nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
							nValRetImp := nValor - nlRImp
							If nValRetImp >= 0
								aVenc[i][2] += Round(nValRetImp,2)
								nlRImp	:= 0
							Else
								aVenc[i][2] += 0
								nlRImp	:= Round((nValRetImp * (-1)),2)
							EndIf
						Otherwise
		   					nValor := Round( nValTot / nDup ,2 )
							aVenc[i][2] += Round(nValor,2)
							nlRImp	:= 0
					EndCase
				EndIf
			ElseIf nValRetImp > 0 .and. clTpCF == '1' .and. cPaisLoc == 'VEN'
				If Type("SC5->C5_NATUREZ") <> "U"
					clNaturez := SC5->C5_NATUREZ
				EndIf
				DBSelectArea("SED")
				SED->(DBSetOrder(1))
				If DBSeek(xFilial("SED") + clNaturez)
					Do Case
						Case SED->ED_RATRET == '1'
							nValor	:= Round((nValTot + nValRetImp) / nDup,2)
							nTotRet	:= nValor - nValRetImp
							If nTotRet >= 0
								aVenc[i][2]	+= Round(nTotRet,2)
								nValRetImp	:= 0
							Else
								aVenc[i][2]	+= 0
								nValRetImp	:= Round((nTotRet * (-1)),2)
							EndIf
						OtherWise
							nValor		:= Round(nValTot / nDup,2)
							aVenc[i][2]	+= Round(nValor,2)
							nValRetImp	:= 0
					EndCase
				Else
					nValor	:= Round((nValTot + nValRetImp) / nDup,2)
					nTotRet	:= nValor - nValRetImp
					If nTotRet >= 0
						aVenc[i][2]	+= Round(nTotRet,2)
						nValRetImp	:= 0
					Else
						aVenc[i][2]	+= 0
						nValRetImp	:= Round((nTotRet * (-1)),2)
					EndIf
				EndIf
			ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

				If Type("M->C5_NATUREZ") <> "U"
					clNaturez := M->C5_NATUREZ
				ElseIf Type("SC5->C5_NATUREZ") <> "U"
					clNaturez := SC5->C5_NATUREZ
				Else
					clNaturez := ""
				EndIf

				dbSelectArea("SED")
				SED->(dbSetOrder(1))
				If SED->(dbSeek(xFilial("SED")+clNaturez))
					If SED->ED_RATRET == "1"
						nValor      := Round((nValTot-nValImp)/nDup,2)
						aVenc[i][2]	+= Round(nValor+nValImp,2)
						nValImp := 0
					Else
						nValor		:= Round(nValTot / nDup,2)
						aVenc[i][2]	+= Round(nValor,2)
						nValImp     := 0
					EndIf
				Else
					nValor		:= Round(nValTot / nDup,2)
					aVenc[i][2]	+= Round(nValor,2)
					nValImp     := 0
				EndIf

			Else
				aVenc[i][2] += nValor
			EndIf
			If cE4_ACRES $ "V" .And. lPVista
				nValor += Round( nAcrescimo / (nDup-i) ,2 )
				lPVista  := .F.
			EndIf
		Next i

	Else

		nIniLoop := 1

		If cE4_IPI $ "JS"
			aVenc[1][2] := nValIPI
			nValTot -= nValIPI
			nIniLoop := 2
		EndIf

		If cE4_SOLID $ "JS"
			aVenc[1][2] += nValSolid
			nValTot -= nValSolid
			nIniLoop := 2
		EndIf

		If cE4_ACRES $ "JS"
			aVenc[1][2] += nAcrescimo
			nValTot     -= nAcrescimo
			nIniLoop    := 2
		ElseIf cE4_ACRES $ "V" .And. lPVista
			nValTot     -= nAcrescimo
		EndIf

		If !("S" $ cE4_IPI + cE4_SOLID + cE4_ACRES)
			nIniLoop := 1
		EndIf

		If nIniLoop == 2
			nValor := Round( nValTot / (nDup-1) ,2 )
		Else
			nValor := Round( nValTot / nDup ,2 )
		EndIf

		For i := nIniLoop TO nDup

			If nValRetImp > 0 .And. cPaisLoc == 'COL'
				SFB->( DbSetOrder(1) )
				DbSelectArea("SFC")
				SFC->(DbSetOrder(2))
				aVenc[i][2] := Round(nValor,2)
				If !lXFIS .and. DbSeek(xFilial("SFC") + clCodTes + cImpRet )


					While !(SFC->(EOF())) .And. clCodTes== SFC->FC_TES
					  SFB->( DbSeek( xFilial("SFB") + SFC->FC_IMPOSTO ))
				      If SFB->FB_JNS $ 'J/S'
							Do Case
								Case FC_INCDUPL == '2' /*.And. FC_INCNOTA <> '2'*/
									nTotRet := aVenc[i][2] - nValRetImp
									If nTotRet >= 0
										aVenc[i][2] :=aVenc[i][2] - nValRetImp//  Round(nTotRet,2)
										nValRetImp := 0
									Else
										aVenc[i][2] += 0
										nValRetImp	:= Round((nTotRet * (-1)),2)
									Endif
								Case FC_INCDUPL == '1'
									aVenc[i][2] := Round(nValor + nValRetImp,2)
							EndCase
						EndIf
						SFC->(DbSKip())
					EndDo
				ElseIf lXfis
					If nValRetImp <> 0
						aVenc[i][2] :=aVenc[i][2] - nValRetImp//  Round(nTotRet,2)
						nValRetImp := 0
					Else
						aVenc[i][2] += 0
						nValRetImp	:= Round((nTotRet * (-1)),2)
					Endif
				EndIf
			elseIf nValRetImp > 0 .And. clTpCF == '1' .And. cPaisLoc == 'EQU'
				IF SC7->C7_NATUREZ <> " "
					dbselectarea("SED")
					SED->(Dbsetorder(1))
					dbSeek(xFilial("SED") + SC7->C7_NATUREZ)
				EndIf
				DbSelectArea("SFC")
				SFC->(DbSetOrder(2))
				If DbSeek(xFilial("SFC") + clCodTes + cImpRet )
					Do Case
						Case SED->ED_RATRET == '1'
							nValor := Round( (nValTot + nValRetImp) / nDup ,2 )
							nTotRet := nValor - nValRetImp
							If nTotRet >= 0
								aVenc[i][2] += Round(nTotRet,2)
								nValRetImp := 0
							Else
								aVenc[i][2] += 0
								nValRetImp	:= Round((nTotRet * (-1)),2)
							Endif
						OtherWise
		   					nValor := Round( nValTot / nDup ,2 )
							aVenc[i][2] += Round(nValor,2)
							nValRetImp := 0
					EndCase
				Endif
			ElseIf nValImp > 0 .and. cPaisLoc == "DOM"

				If Type("SC7->C7_NATUREZ") <> "U"
					clPedido := aCols[1][17]
					If AllTrim(clPedido) <> ""
						DBSelectArea("SC7")
						DBSetOrder(1)
						If DBSeek(xFilial("SC7") + clPedido)
							clNaturez := SC7->C7_NATUREZ
						EndIf
					EndIf
				EndIf

				If Type("M->C5_NATUREZ") <> "U"
					clNaturez := M->C5_NATUREZ
				ElseIf Type("M->F1_NATUREZ") <> "U"
					clNaturez := M->F1_NATUREZ
				ElseIf Type("M->F2_NATUREZ") <> "U"
					clNaturez := M->F2_NATUREZ
				EndIf

				dbSelectArea("SED")
				SED->(dbSetOrder(1))
				If SED->(dbSeek(xFilial("SED")+clNaturez))
					If SED->ED_RATRET == "1"
						nValor      := Round((nValTot-nValImp)/nDup,2)
						aVenc[i][2]	+= Round(nValor+nValImp,2)
						nValImp := 0
					Else
						nValor		:= Round(nValTot / nDup,2)
						aVenc[i][2]	+= Round(nValor,2)
						nValImp     := 0
					EndIf
				Else
					nValor		:= Round(nValTot / nDup,2)
					aVenc[i][2]	+= Round(nValor,2)
					nValImp     := 0
				EndIf

			Else
				aVenc[i][2] += nValor
			EndIf
			If cE4_ACRES $ "V" .And. lPVista
				nValor += Round( nAcrescimo / (nDup-i) ,2 )
				lPVista  := .F.
			EndIf
		Next i
	EndIf
Else
	If Trim(cE4_COND) == "0"  .and.  nValPed < nValTot
		If Len(aVenc) > 0
			nDup:=Len(aVenc)
			nDIf := nValTot - nValPed
			If NoRound(nDIf,4) > 0
				aVenc[nDup][2] += nDIf
			EndIf
			nDIf := nValIpi / nDup
			If !__lIPI
				For i:=1 To nDup
					aVenc[i][2] += nDIf
				Next
			EndIf
		EndIf
	ElseIf Trim(cE4_COND) == "0"  .and.  nValPed >= nValTot
		If Len(aVenc) > 0
			nDup:=Len(aVenc)
			aVenc[nDup][2] -= nValIpi
			nDIf := nValIPI / nDup
			If nValIPI == 0
				aVenc[nDup][2] += nDIf
			Else
				If !__lIPI
					For i:=1 To nDup
						aVenc[i][2] += nDIf
					Next
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Trata diferenca de centavo nas parcelas              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nLoop := 1 to Len(aVenc)
	nVlrParc := NoRound( aVenc[nLoop][2], __nTamE1Valor )
	nVlrAcum1 += nVlrParc

	If ( Len(aVenc)==nLoop .And. nValDup <> 0) .And. !cPaisLoc$"COL|VEN"
		nVlrParc += nValDup - nVlrAcum1
	EndIf
    // reatribui com o novo valor da parcela
	aVenc[nLoop][2] := nVlrParc

Next nLoop
//
// Template de GEM - Gestao de Empreendimentos Imobiliarios
//
If ExistTemplate("GMCondicao")
	aVencTlp := ExecTemplate("GMCondicao",.F.,.F.,{cE4_CODIGO,dData0,nValDup,.F.})
	If !Empty(aVencTlp)
		aVenc := aClone(aVencTlp)
	EndIf
EndIf

SE4->(DbGoTo(nRegSE4))

Return(aVenc)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³D3Valido  ºAutor  ³Fernando J. Siquini º Data ³ 18/10/2004  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Avalia se o registro posicionado no SD3 eh valido.         º±±
±±º          ³ !!!Atencao!!! Deve-se posicionar no SD3 a ser testado      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Void                                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ .T. se o registro for valido, .F. se o registro nao for    º±±
±±º          ³ valido.                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Advanced Protheus                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function D3Valido(cAlias)

Static lEstornado := Nil
Static lD3Servico := Nil
Static lD3Valido  := Nil

Local lRet       := .T.
Local lRetPE     := .T.
Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cCQ			:= GetMvNNR('MV_CQ','98')

Default cAlias     := 'SD3'

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se considera registros estornados no SD3            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lEstornado := If(lEstornado==NIL, GetMV('MV_D3ESTOR', .F., 'N')=='S', lEstornado)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se considera registros com Servico de WMS no SD3    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lD3Servico := If(lD3Servico==NIL, IIF(lWmsNew,.F.,GetMV('MV_D3SERVI',.F.,'N')=='S'), lD3Servico)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o ponto de Entrada D3Valido existe               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lD3Valido := If(lD3Valido==NIL, ExistBlock('D3VALIDO'), lD3Valido)

If lD3Valido
	lRetPE := ExecBlock('D3VALIDO', .F., .F., cAlias)
	lRet   := If(ValType(lRetPE)=='L', lRetPE, lRet)
EndIf

Do While lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao considera Registros Estornados                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lEstornado .And. !Empty((cAlias)->D3_ESTORNO)
		lRet := .F.
		Exit
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao considera Registros referentes a servicos de WMS Nao Executados ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lD3Servico .And. !Empty((cAlias)->D3_SERVIC) .And. !(lWmsNew .And. IntDL((cAlias)->D3_COD))
		If (cAlias)->D3_TM > '500' .And. !((cAlias)->D3_LOCAL == cCQ) //-- Saidas nao serao consideradas (quando o servico for executado ira gerar outro registro no SD3)
			lRet := .F.
			Exit
		EndIf
	EndIf

	Exit
EndDo

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure MAT006                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function VerIDProc()
Return '001'

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc2³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure FIN001                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function VerIDProc2()
Return '011'




/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NGSD3TQN³ Autor ³ Marcos Wagner Junior  ³ Data ³05.1.2010   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Faz a consistencia da delecao do abastecimento (tqn)        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MNT         	                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NGSD3TQN()
Local lRet := .t.
Local aOldArea := GetArea()

If nModulo != 19
	DbSelectArea("SX6")
	DbSetorder(1)
   If GetNewPar("MV_NGMNTFR","N") = "S"
      nOrdId := NGRETORDEM("TQN","TQN_FILIAL+TQN_NUMSEQ")
	   If nOrdId > 0
	      DbSelectArea("TQN")
	      DbSetorder(nOrdId)

	      If DbSeek(xFilial("TQN")+SD3->D3_NUMSEQ)
	         // PROCESSO COPIADO DO MNTA655
				//Verifica Historico de Contador de Bomba
				If lRet .AND. !MNT655LOTE() //Se foi pelo Abastecimento em Lote nao podera alterar
					ApMsgInfo(STR0092) //"Para realizar o estorno utilize a rotina de Abastecimento em Lote do módulo de Manutenção de Ativos."
					lRet := .f.
				Endif

				If lRet .AND. !MNTA655OK(STR0093) //"Excluído"
				   lRet := .f.
				Endif

				If lRet .AND. NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,"'2'") .Or. ;
					NGVDHBomba(TQN->TQN_POSTO,TQN->TQN_LOJA,TQN->TQN_TANQUE,TQN->TQN_BOMBA,TQN->TQN_DTABAS,TQN->TQN_HRABAS,,"'3'")
					ShowHelpDlg(STR0001,{STR0094},3,; //"Atençäo"###"Estorno não permitido pois já existe Aferição de Bomba com data/hora superior a este abastecimento."
												{STR0095},3) //"Exclua as Aferições cadastradas com data/hora superior a este abastecimento pelo módulo de Manutenção de Ativos."
					lRet := .F.
				EndIf

				If lRet .AND. !Empty(TQN->TQN_DTCON)
					If !MsgYesNo(STR0096) //"Abastecimento relacionado já foi conciliado! Deseja continuar?"
						lRet := .f.
					Endif
				Endif

			Endif
		Endif
	Endif
Endif

RestArea(aOldArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsaFilTrf  ³ Autor ³ Emerson Rony Oliveira ³ Data ³ 13/04/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Analisa parametro MV_FILTRF, que define se serao utilizados ³±±
±±³ 		 | os novos campos "A1_FILTRF" e "A2_FILTRF" no processo de    ³±±
±±³ 		 | transferencia entre filiais. A ausencia do parametro ou     ³±±
±±³ 		 | conteudo .F. indica o uso padrao da rotina, ou seja, sera   ³±±
±±³ 		 | utilizado o CNPJ para identificar o cliente/fornecedor      ³±±
±±³ 		 | durante o processo de transferencia entre filiais. Se o     ³±±
±±³ 		 | conteudo for .T. entao serao usados os novos campos das     ³±±
±±³ 		 | tabelas SA1 e SA2. (UPDEST39)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico (default .F.)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA310, MATA103, MATA410, MATR715                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsaFilTrf()
Local lRet := GetMV("MV_FILTRF",.F.,.F.) // .F. == indica funcionamento padrao da rotina -- atraves do CNPJ do cliente/fornecedor

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MtValidFil ³ Autor ³ Emerson Rony Oliveira ³ Data ³ 13/04/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica a existência da filial enviada como parametro.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico (default .F.)                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA020, MATA030                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MtValidFil(cChave)
Local aArea := GetArea()
Local lRet  := .T.

dbSelectArea("SM0")
dbSetOrder(1)
If !MsSeek(cChave)	// Tenta localizar a Empresa+Filial enviadas no parametro cChave
	Help(" ",1,"SAVALFIL")
	lRet := .F.
EndIf

MsSeek(cEmpAnt+cFilAnt)
RestArea(aArea)

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ NGSD1GESTL ºAutor  ³Marcos Wagner Jr. º Data ³  30/03/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Geracao do insumo (STL) atraves de inclusao de SC1         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATXFUNB                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NGSD1GESTL(_CORDEM,_CCODIGO)
Local lTermino  := .f.
Local lTercProd := .f.
Local aTercProd := {}
Local cDestino  := "", cCodigo := "", cTipoReg := ""
Private lTEMSEQR  := NgVerify("STL")
Private dDtMDO    := Ctod("  /  /  "),cHoMDO := Space(5)

//Recebe os Produtos de Terceiros do parametro
aTercProd := aClone(NGProdMNT("T"))
lTercProd := ( aScan(aTercProd, {|x| AllTrim(x) == AllTrim(_CCODIGO) }) > 0)
cTipoReg := If(lTercProd, "T", "P")
nSEQSTL := ULTSEQ1()
If cTipoReg == "T"
	cCodigo  := SD1->D1_FORNECE
Else
	cCodigo  := SD1->D1_COD
	cDestino := "A"
EndIf

If cTIPOREG = "P"
	If NGIFFILSEEK("STL",xFILIAL("STL")+STJ->TJ_ORDEM+STJ->TJ_PLANO,1,.F.)
		While !Eof() .And. STL->TL_FILIAL = Xfilial("STL") .And.;
						STL->TL_ORDEM = _CORDEM .And. STL->TL_PLANO = STJ->TJ_PLANO
			If Alltrim(STL->TL_SEQRELA) <> "0" .And. STL->TL_TIPOREG = "M"
				dDtMDO := STL->TL_DTINICI
				cHoMDO := STL->TL_HOINICI
				Exit
			Endif
			Dbskip()
		End
	Endif
Endif

dbSelectArea("STJ")
dbSetorder(1)
If dbSeek(xFilial("STJ")+_CORDEM)
	lTermino := If(STJ->TJ_TERMINO == "S",.T.,.F.)
Endif

dbSelectArea("STL")
dbSetorder(1)  // ORDEM DE NUMSEQ
Reclock("STL",.T.)
STL->TL_FILIAL  := xfilial('STL')
STL->TL_ORDEM   := _CORDEM
STL->TL_PLANO   := STJ->TJ_PLANO
STL->TL_CODIGO  := cCodigo
STL->TL_TIPOREG := cTipoReg
STL->TL_TAREFA  := '0'
STL->TL_USACALE := 'N'
STL->TL_GARANTI := 'N'
If lTEMSEQR
	STL->TL_SEQRELA := nSEQSTL
Else
	STL->TL_SEQUENC := nSEQSTL
Endif
STL->TL_UNIDADE := If(cTIPOREG = "T","H",SD1->D1_UM)
STL->TL_QUANTID := SD1->D1_QUANT
STL->TL_NUMSEQ  := SD1->D1_NUMSEQ
STL->TL_DTINICI := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
STL->TL_HOINICI := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
If cTIPOREG = "T"
	vVDATFIM := NGDTHORFIM(SD1->D1_DTDIGIT,'08:00',SD1->D1_QUANT)
	STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,vVDATFIM[1])
	STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,vVDATFIM[2])
Else
	STL->TL_DTFIM := If(lTermino,STJ->TJ_DTMRFIM,SD1->D1_DTDIGIT)
	STL->TL_HOFIM := If(lTermino,STJ->TJ_HOMRFIM,'08:00')
EndIf
STL->TL_DESTINO := cDestino
STL->TL_REPFIM  := 'S'
STL->TL_CUSTO   := SD1->D1_CUSTO
STL->TL_NUMOP   := Substr(SD1->D1_OP,1,6)
STL->TL_ITEMOP  := Substr(SD1->D1_OP,7,2)
STL->TL_SEQUEOP := Substr(SD1->D1_OP,9,3)
STL->TL_TIPOHOR := ALLTrim(GETMV("MV_NGUNIDT"))

If cTIPOREG = "P" .And. !Empty(dDtMDO) .And. !Empty(cHoMDO)
	STL->TL_DTINICI := dDtMDO
	STL->TL_HOINICI := cHoMDO
	STL->TL_DTFIM   := dDtMDO
	STL->TL_HOFIM   := cHoMDO
Endif

If FieldPos("TL_ORIGNFE") > 0
	STL->TL_ORIGNFE := 'SD1'
Endif

If FieldPos("TL_FORNEC") > 0
	STL->TL_FORNEC := SD1->D1_FORNECE
Endif

If FieldPos("TL_LOJA") > 0
	STL->TL_LOJA := SD1->D1_LOJA
Endif

If FieldPos("TL_NOTFIS") > 0
	STL->TL_NOTFIS := SD1->D1_DOC
Endif

If FieldPos("TL_SERIE") > 0
	STL->TL_SERIE := SD1->D1_SERIE
Endif

// Multi-Moeda [ UPDMNT39 ]
// Define '1' como valor default para moeda, representando a moeda padrao do pais [ TL_CUSTO = SD3->D3_CUSTO1 ]
If FieldPos("TL_MOEDA") > 0
	STL->TL_MOEDA := "1"
Endif

If lTermino
	STL->TL_OBSERVA := STR0103+DtoC(STL->TL_DTFIM)+"."+Chr(13)+; //"Insumo lançado após a finalização da O.S. em: "
							  STR0104+DtoC(SD1->D1_DTDIGIT)+"." //"Data de lançamento: "
EndIf

MSUNLOCK("STL")

/*Ponto de entrada que será executado após a aplicação do insumo,
com o intuito de finalizar a O.S. via Documento de Entrada da Nota Fiscal.*/
If ExistBlock("NGFIMOS")
	ExecBlock("NGFIMOS",.F.,.F.)
EndIf

Return .t.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Ctb_IsCache ºAutor  ³Microsiga         º Data ³  12/06/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function Ctb_IsCache(nCache)
If __lCacheIs == Nil
	__lCacheIs := ( GetNewPar( "MV_CTBCACH" , "1" ) == "1" )   //"0"=Nao Trabalha com Cache "1"=Trabalha com Cache
EndIf
Return(__lCacheIs)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AtuVldEnt ºAutor  ³Microsiga           º Data ³  01/07/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualizacao do cache de validacao das entidades contabeis. º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AtuVldEnt(cEntid, cCodigo)
Local nPos 		:= 0
Local bPesq  	:= {|x| 	x[2,1] == cCodigo }

If cEntid == "CT1" .And. Ctb_IsCache(1) .And. !Empty(__aCTBConta) .And. ( nPos := Ascan( __aCTBConta, bPesq) ) > 0
	__aCTBConta[nPos][2][1] := ""
Endif

If cEntid == "CTT" .And. Ctb_IsCache(2) .And. !Empty(__aCTBCusto) .And. ( nPos := Ascan( __aCTBCusto, bPesq) ) > 0
	__aCTBCusto[nPos][2][1] := ""
Endif

If cEntid == "CTD" .And. Ctb_IsCache(3) .And. !Empty(__aCTBItem) .And. ( nPos := Ascan( __aCTBItem, bPesq) ) > 0
	__aCTBItem[nPos][2][1] := ""
Endif

If cEntid == "CTH" .And. Ctb_IsCache(4) .And. !Empty(__aCTBClVlr) .And. ( nPos := Ascan( __aCTBClVlr, bPesq) ) > 0
	__aCTBClVlr[nPos][2][1] := ""
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsaD2DTDIG ³ Autor ³ Isaias Florencio      ³ Data ³19/12/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Analisa parametro MV_D2DTDIG, que define se sera utilizado  ³±±
±±³ 		   ³ o campo "D2_DTDIGIT" no lugar do campo "D2_EMISSAO" nos    ³±±
±±³ 		  ³ relatorios MATR275, MATR900, MATR911 e MATC030               ³±±
±±³ 		  ³ Obs.: Somente em ambiente localizado para ARGENTINA,        ³±±
±±³          ³  PERU e MEXICO.                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATR275, MATR900, MATR911 e MATC030                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsaD2DTDIG()
Local aArea     := GetArea()
Local aAreaSIX  := {}
Local lAchouL   := .F.
Local lAchouM   := .F.
Local lRet      := .F.

If (cPaisLoc $ "ARG|PER|MEX")
	lRet := SuperGetMV("MV_D2DTDIG",.F.,.F.)
    // Verificar se os indices criados atraves do UPDEST38 existem no SIX
    If lRet
		lAchouL := ESTFwSIXUtil():ExistIndex( 'SD2', 'L', .F. )
		lAchouM := IIf( lAchouL, ESTFwSIXUtil():ExistIndex( 'SD2', 'M', .F. ), lAchouM )
		lRet 	:= ( lAchouL .And. lAchouM )
    EndIf
	
EndIf

RestArea(aArea)
Return lRet


//---------------------------------------------------------------------------
/*/{Protheus.doc} LimMotRead
Função para Limpar a variavel __aMotRead para carregamento do array de motivo de baixa

@author Igor Fricks
@since 07/06/2018
@version 12.1.17
/*/
//---------------------------------------------------------------------------
Function LimMotRead()

	__aMotRead := Nil

Return

